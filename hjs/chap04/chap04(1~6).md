# 4장 : 트렌지스터에서 CPU로, 이보다 더 중요한 것은 없다(1~6)

# 4.1 이 작은 장난감을 CPU라고 부른다.

## 4.1.1 위대한 발명

프로그래머가 작성한 프로그램이 아무리 복잡해도 소프트웨어가 수행하는 기능은 최종적으로 이 트렌지스터의 간단한 개폐 작업으로 완성된다.

## 4.1.2 논리곱, 논리합, 논리부정

트렌지스터라는 스위치를 기초삼아 다음의 세 가지 회로를 만들 수 있다.

- 스위치 두 개가 동시에 켜질 때만 전류가 흐르고 등이 켜진다.  **→ 논리곱 게이트**
- 두 스위치 중 하나라도 켜져 있으면 전류가 흐를 수 있으며 등이 켜진다. **→ 논리합 게이트**
- 스위치를 닫으면 전류가 흘러 등이 켜지지만, 스위치를 열면 전류가 흐르지 않고 등이 꺼진다. → **논리부정 게이트**

## 4.1.3 논리적 완전성

- **논리적 완전성** : 논리곱 게이트, 논리합 게이트, 논리부정 게이트로 모든 논리 함수를 표현할 수 있다.

  → 이 세 게이트를 통해 어떤 논리함수도 구현할 수 있으며, 이외에는 어떤 형태의 논리 게이트 회로도 필요하지 않다. 이는 논리적으로 완전하다고 간주된다.


## 4.1.4 연산 능력은 어디서 나올까?

CPU는 0과 1의 2진법만 알고 있으므로, 2진법으로 덧셈을 하면 다음과 같다.

- 0+0의 결과는 0 이며, 자리 올림수도 0이다.
- 0+1의 결과는 1이며, 자리 올림수는 0이다.
- 1+0의 결과는 1이며, 자리 올림수는 0이다.
- 1+1의 결과는 0이며, 자리 올림수는 1이다.

자리 올림수를 보면, 두 입력값이 모두 1일 때만 1이다 → 논리곱 게이트

결과를 보면, 두 입력값이 서로 다르면 결과가 1이고, 두 입력값이 서로 같으면 결과가 0이다 → 배타적 논리합

⇒ 논리곱 게이트와 베타적 논리합 게이트 한 개를 조합하면 2진법 덧셈을 구현할 수 있다.

논리 게이트를 사용하여 덧셈 작업 및 다른 산술 연산을 설계할 수 있다. CPU는 전문적으로 계산을 담당하는 모듈이 있는데, 바로 **ALU**라는 산술 논리 장치이다.

## 4.1.5 신기한 기억 능력

입력과 출력은 이를 저장할 곳이 있어야 하므로 정보를 저장할 수 있는 회로가 필요하다.

- 부정 논리곱 게이트
    - 논리곱 연산을 처리한 후 논리부정 연산을 처리
    - 1과 0을 입력했다면 논리곱 연산 결과는 0이며, 이를 다시 논리부정으로 처리하면 1
- S-R 래치
    - 단자 S와 R에 1이 입력되는 한 회로는 두 가지 상태를 가진다.
    - 입력 a에 따라 출력이 달라짐:


        | 입력 a | B | A | b |
        | --- | --- | --- | --- |
        | 1 | 0 | 1 | 0 |
        | 0 | 1 | 0 | 1 |
    - 이처럼 회로는 상태를 기억할 수 있으므로 정보저장이 가능하다.
- D 래치 (D 단자 기반 저장)
    - S와 R을 동시에 제어하여 정보를 저장하지만, 실제 저장에 필요한 정보는 1비트이다.

  → 이를 더 간편하게 저장하기 위해 D 단자를 사용한다.

    - D = 0 → 저장되는 값은 0
    - D ≠ 0 → 저장되는 값은 1
    - 이 회로는 마치 1비트를 저장하는 사물함처럼 동작한다.


이렇게 하면 1비트를 보다 간편하게 저장할 수 있으며, 이 회로는 마치 1비트를 저장하는 사물함처럼 동작한다.

## 4.1.6 레지스터와 메모리의 탄생

- 더 많은 비트를 저장하려면 단순히 1비트를 저장하는 회로를 여러 개 복제하여 나란히 붙이면 된다.
  → 이렇게 구성된 회로를 레지스터라고 한다.
- 많은 정보를 저장하고, 저장된 위치를 구분하기 위해, 8비트를 1바이트로 정하고, 각 바이트에는 고유한 번호, 즉 주소가 부여된다. 이제 회로에 저장된 정보를 주소를 통해 읽거나 쓸 수 있게 되었다.
  → 이 과정을 통해 메모리가 탄생하게 되었다.
- 레지스터와 메모리는 모두 회로에 의존한다. 따라서 전원이 공급되는 동안에는 정보를 저장할 수 있지만, 전원이 끊기면 저장된 정보는 모두 사라진다.

  → 메모리가 전원이 꺼지면 데이터를 유지할 수 없는 이유이다.


## 4.1.7 범용장치

논리곱, 논리합, 논리부정 게이트를 사용하여 모든 논리 함수를 표현할 수 있다고 해도 모든 논리함수를 논리곱, 논리합, 논리부정 게이트를 사용해서 구현할 필요는 없다. 마찬가지로 모든 연산 논리를 반드시 회로 같은 하드웨어로 구현할 필요도 없다.

→ 하드웨어는 변하지 않지만 소프트웨어는 변할 수 있기에 변하지 않는 하드웨어에 서로 다른 소프트웨어를 제공하면 하드웨어가 완전히 새로운 기능을 구현할 수 있다.

이것이 바로 컴퓨터를 **범용 연산 장치**라고 하는 이유로, 컴퓨터 과학의 창시자인 엘런 튜링 제안한 것이다.

## 4.1.8 하드웨어의 기본 기술 : 기계 명령

CPU가 연산을 수행하기 위해서는 무엇을 해야 하는지 알려주는 **기계 명령어**가 필요하다.  기계 명령어는 앞서 설명한 조합 회로를 통해 실행된다. 하지만 명령어의 종류는 매우 많기 때문에 체계적인 정리가 필요하다.

CPU는 복잡한 판단이나 선택을 하지 않는다. 단지 연산 능력만 제공하면 되고, 어떤 값을 연산할지는 프로그래머가 정해주면 된다. 즉, CPU는 도구이고, 피연산자는 외부에서 주어진다고 보면 된다.

→ 이러한 CPU의 동작 방식은 **명령어 집합**이라는 표현 방식을 통해 구현된다.

- 명령어 집합은 CPU가 이해할 수 있는 모든 명령어들의 모음이다.
- 명령어 집합을 통해 CPU는 어떤 동작을 언제 어떻게 해야 하는지 알 수 있다.

결국 CPU는 명령어 집합을 바탕으로 작동하며, 복잡한 연산을 회로를 통해 순차적으로 처리하는 구조이다.

## 4.1.9 소프트웨어와 하드웨어 간 인터페이스 : 명령어 집합

명령어 집합(instruction set)은 CPU가 실행할 수 있는 명령어(opcode)와, 그 명령어에 필요한 피연산자(operand)를 묶은 것이다. CPU마다 구조가 다르기 때문에, 서로 다른 종류의 CPU는 서로 다른 명령어 집합을 가진다.

명령어 집합에서 하나의 명령어가 수행할 수 있는 작업은 매우 단순하다. 우리가 고급 언어로 작성한 프로그램이 아무리 복잡하더라도, 결국에는 모두 단순한 명령어들로 분해되어 CPU에서 순차적으로 실행된다. 이로 인해 CPU는 복잡한 일을 처리하는 것처럼 보이지만, 실제로는 매우 기초적인 연산을 반복할 뿐이다.

- 시스템 계층의 관점에서 보면, **명령어 집합**은 소프트웨어와 하드웨어가 만나는 지점이다.

  명령어 집합 위에는 소프트웨어 세계가 있고, 아래에는 하드웨어 세계가 존재한다. 따라서 명령어 집합은 소프트웨어와 하드웨어가 서로 통신하는 인터페이스 역할을 한다.

- 기계 명령어 하나가 할 수 있는 일은 매우 제한적이다.

  그래서 사람이 이해하고 작성하기 쉬운 **고급 프로그래밍 언어**가 등장했고, 이를 CPU가 이해할 수 있도록 기계 명령어로 변환해 주는 도구가 바로 **컴파일러**이다.


## 4.1.10 회로의 지휘자

회로는 여러 구성 요소로 이루어져 있으며, 일부는 데이터를 계산하는 데 사용되고, 일부는 정보를 저장하는 데 사용된다.

- 예를 들어, 가장 간단한 덧셈인 1 + 1을 계산할 때, 두 숫자는 각각 레지스터 R1과 R2에 저장된다.
- 레지스터는 어떤 값이든 저장할 수 있는 회로이다.

가산기가 작동할 때, R1과 R2에 반드시 1이 저장되어 있도록 보장하기 위해 회로 전체를 조율하는 지휘자 역할이 필요하다. 이 지휘자 역할을 수행하는 것이 바로 CPU의 **클럭(clock signal)**이다.

- 클럭 신호는 전압의 변화로 주기적인 신호를 생성하며, 클럭 신호가 변화할 때마다 전체 회로의 상태, 각 레지스터의 값이 함께 갱신된다.
- 이로 인해 회로가 순차적이고 동기화된 방식으로 안정적으로 작동할 수 있게 된다.

CPU의 클럭 주파수(clock rate)는 다음을 의미한다.

- 클럭 주파수는 1초 동안 클럭 신호가 몇 번 전환되는지를 나타낸다.
- 클럭 주파수가 높을수록 CPU는 1초에 더 많은 동작을 처리할 수 있게 된다.

## 4.1.11 CPU의 탄생

계산을 수행할 수 있는 산술 논리 장치, 정보를 저장하는 레지스터, 각 작업을 조율해 주는 클럭 신호가 갖추어졌을 때, 이 요소들을 하나로 묶은 것을 중앙 처리 장치, 즉 **CPU 또는 프로세서**라고 한다.

CPU는 컴퓨터 시스템에서 가장 핵심적인 부품이다. 명령어를 실행할 CPU가 없다면 컴퓨터는 단순한 하드웨어 덩어리에 불과하다. 다시 말해, CPU가 있어야 비로소 컴퓨터가 '동작'할 수 있는 상태가 되는 것이다.

CPU는 프로그램 명령어를 하나씩 읽고 해석하며 실행한다. 이처럼 중요한 기능을 담당하기 때문에 CPU는 컴퓨터 시스템의 모든 것과 깊이 관련되어 있다. 메모리, 저장장치, 입출력 장치 등 모든 부품은 결국 CPU와 연결되어 협력하게 되어 있다.

결국 CPU는 컴퓨터의 두뇌이자 중심이며, 모든 동작을 가능하게 만드는 핵심 장치이다.

---

# 4.2 CPU는 유휴 상태일 때 무엇을 할까?

## 4.2.1-2 프로세스 관리와 스케줄링

프로그램이 메모리에서 실행되면 **프로세스**라는 형태로 존재하게 된다.프로세스가 생성되면 **운영체제**가 이를 관리하고, CPU가 어떤 프로세스를 실행할지 결정하는 **스케줄링**을 담당하게 된다.

- 운영체제는 프로세스를 효율적으로 관리하기 위해  대기열(queue)을 이용한다.
    - 운영체제는 실행 준비가 된 프로세스들을 대기열에 넣고, 순서대로 또는 규칙에 따라 실행하게 한다.
- 운영체제는 각 프로세스에  우선순위(priority)를 부여할 수 있다.
    - 이 우선순위에 따라 스케줄러는 어떤 프로세스를 먼저 실행할지 결정하게 된다.
    - 상황에 따라 우선순위는 변경될 수 있다.

프로세스 스케줄링은 운영체제가 구현해야 하는 핵심 기능 중 하나이다.

## 4.2.3 대기열 상태 확인 : 더 나은 설계

운영체제는 대기열을 이용하여 프로세스를 준비한다. 준비 완료 대기열이 비어 있다면 이는 현재 운영체제가 스케줄링해야 하는 프로세스가 없고, CPU가 유휴 상태에 있다는 것을 의미한다.

```c
if(queue.empty()) {
	do_something
}
```

이런 방식으로 코드를 작성하는 것은 겉보기에는 간단해 보인다. 하지만 커널 코드는 예외 처리 구문, 특히 `if`문과 같은 조건 검사로 가득한 경우가 많아서 코드가 번잡해지고 가독성이 떨어지게 된다.

→ 따라서 예외 처리가 없는 더 나은 구조를 고민해야 한다.

그 방법 중 하나는 대기열을 항상 채워 두는 것이다. 이렇게 하면 스케줄러는 대기열에서 항상 실행 가능한 프로세스를 찾을 수 있게 된다. 이는 연결 리스트에서 일반적으로 **감시자 노드**(sentinel node)를 사용하는 이유와 같다.

→ 감시자 노드를 사용하면 `null` 여부를 검사하는 별도의 조건문을 제거할 수 있다.

이와 같은 원리를 커널 설계에 적용한 것이 바로 **유휴 프로세스(**idle process)이다. 유휴 프로세스는 시스템에 실행할 프로세스가 전혀 없을 때 스케줄러가 대신 실행시키는 가짜 작업이다.

- 유휴 프로세스는 항상 준비 완료 상태이며, 우선순위는 가장 낮다.

→ 이를 통해 커널은 예외 상황 없이 항상 정상적인 흐름을 유지할 수 있다.

## 4.2.4 모든 것은 CPU로 돌아온다

CPU 설계자는 시스템에 유휴 상태가 존재할 가능성을 일찍이 인지하고, 이를 대비해 하나의 기계 명령어를 설계했는데, 바로 정지를 의미하는 **HALT 명령어**이다.

- CPU 내부의 일부 모듈을 절전 상태로 전환하여 전력 소비를 크게 줄인다.
- 일반적으로 HALT 명령어도 실행을 위해 명령어 순환(cycle)에 배치되는데, 그 이유는 가능한 한 절전 상태를 유지하는 것이 목적이기 때문이다.
- **특권 명령어**이다. 즉, 커널 모드의 CPU만 실행할 수 있으며, 일반 프로그래머가 작성한 응용 프로그램 명령어에서는 직접 실행할 수 없다.

응용 프로그램이 실행되다가 HALT 명령어를 실행한다는 것은, 시스템 내에 더 이상 실행할 준비가 된 프로세스가 없다는 의미이다.

## 4.2.5 유휴 프로세스와 CPU의 저전력 상태

컴퓨터 시스템에서 HALT 명령어는 CPU가 유휴 상태일 때 전력 소비를 줄이기 위해 설계된 특권 명령어이다. 이 명령어는 CPU 내부 일부 모듈을 절전 상태로 전환하며, 시스템에서 실행할 프로세스가 없을 때 반복해서 실행된다.

- HALT 명령어는 이미 준비되어 있으며, 이를 지속적으로 실행하는 순환 구조가 존재한다.

  → 즉, 작업 프로세스는 구현되어 있고 본질적으로 HALT 명령어를 계속 실행하는 루프가 동작한다.


스케줄러는 실행 가능한 프로세스가 없을 때 유휴 프로세스를 실행하여 CPU가 저전력 상태로 진입하도록 한다.

```c
c
복사편집
while (1) {
    while (!need_resched()) {
        cpuidle_idle_call();
    }
}

```

위 코드에서 `cpuidle_idle_call()` 함수는 최종적으로 HALT 명령어를 실행한다.

- 실제 운영체제 커널(예: 리눅스)에서는 다양한 CPU 절전 모드를 지원하며, 유휴 시간을 예측해 적절한 절전 상태로 진입한다.
- CPU마다 얕은 수면 상태부터 깊은 수면 상태까지 여러 단계의 절전 모드가 존재한다.

정리하면, 컴퓨터 시스템이 유휴 상태일 때 CPU가 가장 많이 실행하는 명령어는 HALT 명령어이며, 이를 통해 시스템의 전력 소모를 최소화한다.

## 4.2.6 무한 순환 탈출 : 인터럽트

앞서 설명한 순환은 `while(1)`과 같은 무한 순환 구조이다. 내부에 `break` 문이나 `return` 문이 없는 무한순환 구조이지만, 다른 프로그램은 정상적으로 동작한다. 이유는 다음과 같다.

- 컴퓨터 운영체제는 일정 시간마다 타이머 인터럽트를 발생시킨다.
- CPU는 인터럽트 신호를 감지하여 운영체제 내부의 인터럽트 처리 프로그램을 실행한다.
- 인터럽트 처리 함수는 현재 프로세스가 실행 준비가 되었는지 판단한다.
- 실행 준비가 된 프로세스가 있으면 중단되었던 프로세스를 다시 실행한다.
- 실행 준비가 되어 있지 않으면 현재 프로세스를 일시 중지시키고, 스케줄러가 준비 완료 상태인 다른 프로세스를 선택하여 실행한다.

예를 들어, 앞서 다룬 유휴 프로세스가 타이머 인터럽트로 인해 일시 중지되면, 인터럽트 처리 함수는 시스템에 준비 완료된 다른 프로세스가 있는지 확인한다. 만약 없다면 유휴 프로세스를 계속 실행한다.

결론적으로, 프로그램에 무한 순환이 있더라도 운영체제는 타이머 인터럽트를 이용해 프로세스 스케줄링을 제어할 수 있으며, 무한 순환 때문에 운영체제가 멈추거나 실행하지 못하는 문제는 발생하지 않는다.

# 4.3 CPU는 숫자를 어떻게 인식할까?

컴퓨터 시스템이 2진법인 이유는 컴퓨터의 저수준 계층이 각각 켜고 끄는 스위치인 트렌지스터로 이루어져 있기 때문이다.

## 4.3.1 숫자 0와 양의 정수

비트 k개를 사용하면 정수 0부터 2의 k승 - 1까지의 수를 나타낼 수 있다. 예를 들어, 8비트(즉, k가 8)라고 가정하면 표현 가능한 범위는 0부터 255까지이다. 이는 부호 없는 정수의 경우이다.

이 범위는 모두 양의 정수이다. 그러나 실제 계산에서는 음수를 포함해야 할 때가 있는데, 이 경우 부호 있는 정수라고 부른다.

## 4.3.2 부호 있는 정수

비트가 4개 있으면 이를 이용하여 표현할 수 있는 부호 없는 정수는 0부터 15까지이다. 반면, 부호 있는 정수는 절반을 양수에 할당하고 나머지를 음수에 할당한다. 즉, 4비트 부호 있는 정수는 1부터 7까지를 양수로, -1부터 -8까지를 음수로 나누어 표현한다.

이 부호 표현 방법은 최상위 비트가 정수의 부호를 결정한다. 최상위 비트가 0이면 양수를 의미하고, 1이면 음수를 의미한다.

## 4.3.3 부호-크기 표현

수에 관한 표현 문제에는 세 가지 설계 방법이 있다.

첫 번째는 부호-크기 표현이다. 이 설계 방식은 매우 간단하다. 예를 들어, 4비트에서 0010은 +2를 의미하므로 최상위 비트를 1로 바꾸면 1010은 대응하는 음수인 -2가 된다. 이 방법은 간단하고 직접적이며, 인간의 사고방식에 가장 가깝다. 이를 부호-크기 표현이라고 한다.

그러나 이 방식에는 문제점이 있다. 바로 -0이라는 이상한 숫자가 나타난다는 점이다. 0000은 0을 의미하는데 반해, 1000은 -0을 표현한다. 0과 -0은 같은 숫자인데도 불구하고 별도의 값으로 존재한다는 문제가 있다.

## 4.3.4 1의 보수

부호-크기 표현은 너무 원시적이어서 사실상 설계 자체가 없는 것과 마찬가지이다. 예를 들어, 0010이 +2를 의미하면 이를 완전히 반전시킨 1101이 -2를 표시하는 방법이 있다. 이 방법을 1의 보수라고 한다.

1의 보수 표현 방식에도 -0이 존재한다. 0000은 0을 의미하고, 1의 보수인 1111은 -0을 의미한다. 따라서 1의 보수 표현 방식은 부호-크기 표현과 크게 다르지 않다.

이런 표현 방식에는 두 숫자를 더하는 데 문제가 있다.

## 4.3.5 간단하지 않은 두 수 더하기

부호-크기 방식에서 2는 0010이고, -2는 1010이다. 이때 컴퓨터는 2와 -2의 덧셈을 어떻게 수행하는가?
0010 + 1010 = 1100이다. 그러나 1100은 부호-크기 방식에 따르면 -4를 의미하므로, 이는 부호-크기 표현 방식과 모순된다.

이번에는 1의 보수를 보면 2는 0010이고, -2는 1101이다.
0010 + 1101 = 1111인데, 1111은 1의 보수 방식에서 -0에 해당한다.

컴퓨터의 덧셈은 가산기 조합 회로로 구현되지만, 부호-크기 표현 방식과 1의 보수 표현 방식은 덧셈을 보장하는 조합 회로를 추가하는 것이 불가피하다.

## 4.3.6 2의 보수

양수 2는 2진법으로 표현하면 0010이다. 하지만 -2에 대해서는 최상위 비트가 1이라는 것만 확실하다. 예를 들어, 0010 + 1??? = 0000 이라는 수식은 -2가 1110일 때 올바르다. 이 경우 2 + (-2)는 실제로 0이 된다. 이를 통해 다른 음수의 2진법 표현을 추론할 수 있다. 이 표현 방식에는 -0이 없다.

1과 0에 주목하면 각각 1111과 0000이다. -1(1111)에 1(0001)을 더하면 확실히 0000을 얻을 수 있지만, 자리 올림수(carry)가 존재하여 실제로 얻는 값은 10000이다. 하지만 이때 자리 올림수는 무시할 수 있다. 이 표현 방법에서는 가산기가 계산을 수행할 때 숫자 부호에 신경 쓸 필요가 없다.

이것이 현대 컴퓨터에서 사용되는 2의 보수이다. 2의 보수는 -0이라는 표현이 없으며, 1의 보수로 표현된 양수에 1을 더하면 2의 보수에 대응하는 음수가 된다.

## 4.3.7 CPU는 숫자를 알고 있을까?

2의 보수 표현을 이용하여 2 + (-2)를 계산할 때는 10진법 계산 방법과 마찬가지로 오른쪽에서 왼쪽으로 덧셈을 수행한다.

- 자리 올림수가 발생하면 그 올림수는 다음 자리의 계산에 포함된다.
- 예를 들어, 0010 + 1110 = 10000 이 된다.

가산기는 이 과정에서 숫자가 양수인지 음수인지 구분하지 않는다.

- 0010이라는 비트열이 어떤 숫자인지 가산기 자체는 알지 못한다.
- 단지 두 비트의 배타적 논리합(XOR) 연산이 덧셈 결과의 각 비트가 되며, 두 비트의 논리곱(AND) 연산이 자리 올림수로 작용한다는 것만 인지한다.

보다 정확히 말하면, 컴파일러가 이러한 의미를 이해하고 있어야 한다. CPU는 명령을 실행하는 부분일 뿐이며, 프로그래밍 언어를 직접 이해하지는 못한다. 프로그래머는 사고를 프로그램 코드로 표현하고, 컴파일러는 이 코드를 CPU가 이해할 수 있는 0과 1로 이루어진 기계어 명령어로 변환한다.

따라서 소프트웨어가 CPU가 실행한 결과를 사람이 이해할 수 있도록 해석하는 역할을 한다. CPU는 인간의 개념을 이해하지 못하며, 단지 인간이 제어해서 주어진 작업을 처리할 뿐이다.

---

# 4.4 CPU가 if문을 만났을 때

## 4.4.1 -2 메가펙토리와 파이프라인

CPU 자체를 하나의 메가팩토리(megafactory)로 볼 수 있다. CPU는 주어진 기계 명령어를 순차적으로 처리하는 역할을 한다. 하나의 기계 명령어는 다음과 같은 네 단계로 처리된다.

1. *명령어 인출 (Instruction Fetch)*
2. *명령어 해독 (Instruction Decode)*
3. *실행 (Execute)*
4. *결과 저장 또는 다시 쓰기 (Write Back)*

이 네 단계는 각각 별도의 하드웨어 회로를 통해 수행된다.실제 CPU 내부에서는 하나의 명령어를 위 네 단계를 넘어서 수십 개의 미세한 단계로 더 쪼개어 실행할 수도 있다.

오늘날의 CPU는 기계 명령어를 *초당 수십억 개* 처리할 수 있을 만큼 성능이 높다.이를 가능하게 해주는 핵심 기술 중 하나가 바로 파이프라인(pipeline) 구조이다.

## 4.4.3 IF가 파이프라인을 만나면

- 프로그래머가 작성한 `if` 문은 일반적으로 컴파일러에 의해 조건부 점프 명령어로 변환된다.

  → 이 명령어는 분기(branch)의 역할을 한다. 조건이 참이면 특정 위치로 점프하고, 거짓이면 다음 명령어를 순차적으로 실행한다.

- 하지만 조건부 점프 명령어는 실행되기 전까지 점프 여부를 알 수 없기 때문에 파이프라인에 영향을 준다. 파이프라인 구조에서는 명령어가 순차적으로 밀려 들어가야 하므로, 조건부 분기가 끝날 때까지 기다리면 파이프라인에 공백이 생겨 성능이 저하된다.

  → 즉, CPU는 조건부 점프 명령어의 실행 결과를 기다리지 않고 다음 명령어를 파이프라인에 미리 넣어야 한다.

- 이 상황에서 CPU는 다음 명령어가 분기 이후 명령어인지, 아니면 분기하지 않았을 때의 명령어인지를 결정해야 한다.

  → 이를 위해 사용하는 기술이 바로 분기 예측(branch prediction) 이다.


## 4.4.4 분기 예측

CPU는 분기 명령어를 실행하기 전에 다음에 어디로 분기할 가능성이 높은지를 미리 추측한다.

- 추측이 맞으면 파이프라인은 중단 없이 계속 실행된다.
- 추측이 틀리면 파이프라인에 들어간 잘못된 명령어들을 모두 무효화하여 성능 손실이 발생한다.

→ 이러한 추측 과정을 분기 예측이라고 한다.

배열이 정렬되어 있으면 CPU는 반복되는 패턴을 바탕으로 분기 결과를 잘 예측할 수 있다. 반대로 배열이 정렬되어 있지 않으면 분기 결과가 불규칙하게 발생하여 예측에 실패할 확률이 높아진다. 이 경우 분기 예측 실패로 인해 프로그램 전체 성능이 떨어진다.

성능을 중시하는 코드를 작성할 때는 if문을 CPU가 예측하기 쉬운 형태로 구성해야 한다. 이러한 이유로 프로그래밍 언어에는 `likely` 또는 `unlikely`와 같은 매크로가 존재한다. 이 매크로는 어떤 조건 분기가 더 자주 발생할지를 컴파일러에게 알려주는 역할을 한다. 컴파일러는 이 정보를 바탕으로 명령어를 최적화하여 성능을 향상시킨다.

성능 최적화는 항상 필요한 것은 아니며, 실제로 병목이 발생하는지 확인하는 과정이 선행되어야 한다.

이를 위해 perf 같은 분석 도구를 사용해 분기 예측 실패가 원인인지 파악할 수 있다.

---

# 4.5 CPU 코어 수와 스레드 수 사이의 관계는 무엇일까?

## 4.5.1 코드와 스레드

- CPU는 기계 명령어에 따라 프로세스와 스레드를 실행한다.

  운영 체제 입장에서 보면, CPU가 사용자 상태에서 실행하는 모든 명령어는 특정 스레드에 속해 있다.
  CPU 코어 수와 스레드 수 사이에는 직접적인 필연 관계가 없다.
  CPU는 하드웨어인 반면, 스레드는 소프트웨어 개념이며 더 정확하게는 실행 흐름이자 작업이다.
  따라서 단일 코어 시스템에서도 많은 스레드를 생성할 수 있다.

- CPU는 자신이 실행하는 명령어가 어떤 스레드에 속하는지를 이해하지 못한다.
  CPU는 이를 이해할 필요가 없고, 이 역할은 운영 체제가 담당한다.
  CPU가 하는 일은 단지 PC 레지스터의 주소에 따라 메모리에서 기계 명령어를 꺼내 실행하는 것이다.
- PC 레지스터는 다음에 실행할 기계 명령어의 주소를 가리키는 역할을 한다.
  CPU는 스레드나 프로세스를 인식하지 않고, 오직 명령어 단위로 작동할 뿐이다.
  스레드와 프로세스의 개념은 운영 체제가 CPU 위에서 정의하고 관리하는 것이다.

## 4.5.2 작업분할과 블로킹 입출력

- 단일 코어 시스템에서 CPU는 일정 시간 동안 단 하나의 스레드만 실행할 수 있다.

  따라서 여러 개의 스레드는 번갈아가며 실행되지만, 이는 진정한 병렬 처리라고 보기 어렵다.

- 스레드는 프로그래머에게 매우 편리한 추상화를 제공한다.
  하나의 작업을 여러 하위 작업으로 나눈 후, 각 작업을 별도의 스레드에 배치하면 운영 체제가 이를 스케줄링하여 실행할 수 있다.
- 블로킹 입출력 관련 작업은 전체 스레드를 일시 중지시킬 수 있다.
  블로킹 호출이 실행되면, 해당 호출 이후의 코드는 실행되지 않는다. 그러나 블로킹 입출력 코드를 별도의 스레드로 분리하면, 나머지 코드는 영향 없이 계속 실행될 수 있다.
- 특정 작업을 기다리지 않고 계속 진행하는 것이 중요할 때, 여러 스레드를 생성하고 작업을 나누어 실행해도 무방하다.
  이때 시스템이 단일 코어인지 다중 코어인지는 본질적으로 큰 상관이 없다.운영 체제가 스레드를 스케줄링하여 실행하는 방식에 따라 동작하기 때문이다.

## 4.5.3 다중 코어와 다중 스레드

- 다중 프로세스도 다중 코어를 최대한 활용할 수 있다. 하지만 프로세스 간 통신 방식이 복잡하고, 전환에 드는 비용과 같은 문제가 발생한다.
- 스레드는 이러한 문제에 대한 좋은 해결책이 되며, 다중 코어 시대의 주인공이 되었다.

  다중 코어를 효과적으로 활용하려면 시스템에 몇 개의 코어가 있는지를 알아야 한다. 일반적으로 생성되는 스레드 수는 코어 수와 일정한 선형 관계를 유지하는 것이 좋다.

1. 스레드가 계산만을 위한 것이고 입출력이나 동기화가 필요 없다면,
   → 코어당 스레드 하나가 가장 적절한 선택이 된다.
2. , 스레드에는 입출력이나 동기화가 필요하다면,
   → 스레드 수를 적당히 늘려 운영 체제가 CPU에 효율적으로 할당할 수 있도록 해야 한다.
3. 스레드 수가 일정 한계에 도달하면,

   → 운영 체제의 성능이 오히려 저하되기 시작한다. 한 스레드에서 다른 스레드로 전환할 때 부하가 증가하기 때문이다.


---

# 4.6 CPU 진화론(상) : 복잡 명령어 집합의 탄생

## 4.6.1-2  명령어 집합

모든 프로그램은 컴파일러를 통해 기계가 이해할 수 있는 명령어로 변환되어 실행 파일 형태로 저장되며, 이 파일은 실행 시 메모리에 적재된다. *CPU는 메모리에서 명령어를 읽고 단순히 이를 실행할 뿐*이며, 이 때문에 CPU 입장에서는 모든 프로그램이 단지 명령어의 나열일 뿐이다.

- CPU는 고유한 능력 범위, 즉 자신이 실행할 수 있는 기능의 범위를 가지고 있으며, 이러한 능력은 **명령어 집합** 형태로 정의된다.
- 명령어 집합은 CPU가 어떤 작업을 수행할 수 있는지를 명확히 알려주는 집합이며, 프로그래머는 이 명령어 집합 안에서 명령어를 선택하여 CPU에 지시를 내릴 수 있다.
- CPU는 이 명령어가 지시하는 작업을 정확히 수행하기에. 프로그래밍 시 중요한 기준이 될 뿐만 아니라, CPU의 하드웨어 설계 방향에도 영향을 미치는 핵심 요소이다.
- 서로 다른 CPU는 서로 다른 명령어 집합을 가지며, 이는 하드웨어 수준에서의 차이를 만들 뿐만 아니라 소프트웨어 개발 시의 호환성과 최적화 방식에도 큰 영향을 준다.

## 4.6.3 추상화

과거에는 대부분의 프로그램이 어셈블리어로 직접 작성되었기 때문에, 명령어 집합이 풍부하고 명령어 하나하나의 기능이 강력한 것이 중요하다고 여겨졌다.

프로그래머는 자주 사용하는 작업마다 직접 대응하는 명령어가 있는 것을 선호했으며, 이는 어셈블리어로 작성할 때 편리함과 효율성을 높이는 방식이었다. 만약 명령어가 적거나 단순했다면, 프로그래밍은 매우 복잡하고 번거로웠을 것이다.

이러한 접근은 고급 언어 개념과 기계 명령어 간의 **의미상 간격**(semantic gap) 을 좁히려는 시도로 볼 수 있다. 함수 호출, 순환 제어, 배열 접근, 복잡한 주소 지정 등 고급 언어에서 사용되는 개념들을 명령어 수준에서 지원해야 했기 때문이다. 또한 어셈블리어 기반 프로그래밍에서는 저장 공간을 얼마나 효율적으로 사용하는가도 중요한 고려 사항이었다.

## 4.6.4 코드로 저장공간을 차지한다.

오늘날의 컴퓨터는 기본적으로 폰 노이만 구조를 따른다. 이; 구조의 핵심 사상은 저장 개념에서 프로그램과 프로그램이 사욯아는 데이터에 어떤 차이도 없어야9하며, 모두 컴퓨터의 저장 장치ㅇ 안에 저장될 수 있어야 한다는 것이다. 모든 컴포팅 장치의 원조인 퐂ㄴ 노이만 구저ㅗ를 보여준다. 폰 노이만 구조에서 실행 파일은 기계 명령어와 데이터를 모두 포함하고 있다는 것을 알 수 있다 또 이것에서 프로그래머가 작성한 코드는 디스크 저장 공간을 차지하며 실행 시에는 메모리에 적재되므로 메모리 저장 공간을 차지하는다는 것을 알 수 있다. 동적 랩은 우리에게 익숙한 메모리인데, 이렇게 작은 메모리에 더 많은 프로그램을 적ㄱ재하려면 기계 명령어를 반드시 매우 세ㅣㄹ하게 설계해서 프로그램이 차지하는 저장 공간을 줄여아한다. 이에 다음 요구사항을 만족해야 한다.

1. 하나의 기계 명령어로 더 많은 작업을 완료할 수 있으므로 프로그래머가 더 휴율적으로 코드를 작성할 수 있게 해준다.
2. 기계명령어 길이가 고정되어 있지 않다. 기계명령어 길이가 가변적이므로 프로그램 자체가 차지하는 저장공간을 줄일 수 있다
3. 기계 명령어는 밀도를 높여 공간을 절약하려고 고도로 인코딩된다

## 4.6.5-6 필연적인 복잡 명령어 집합의 탄생

- 과거에는 편리한 프로그래밍과 저장 공간 절약을 위해 복잡한 명령어 집합의 필요성이 제기되었다.

  하지만 당시 CPU는 모두 직접 연결(hardwired) 방식이었기 때문에,

    - 명령어 실행은 빠르지만, 유연성이 낮고, 새로운 명령어 추가 시 설계·디버깅 복잡도가 크게 증가했다
    - 특히 명령어 길이가 가변적이고, 복잡한 연산이 포함되면 문제는 더욱 심각해졌다.

  → 해결책으로, 복잡한 명령어를 단순 명령어로 구성된 작은 프로그램으로 처리하는 방식이 등장했다.

- 이 작은 명령어들은 마이크로코드라 불리며, 소프트웨어적으로 정의되어 CPU 내부에 저장된다.
    - 복잡 명령어 추가 시 마이크로코드만 수정하면 되고
    - 하드웨어 수정이 거의 필요 없어, CPU 설계의 유연성과 유지보수성을 크게 향상시킬 수 있다.

  **→** 하지만 마이크로코드의 버그 수정은 일반 프로그램보다 수정이 훨씬 어렵고, 트랜지스터 소모가 크다**.**