# 4장 : 트렌지스터에서 CPU로, 이보다 더 중요한 것은 없다(7~9)

## 4.7 진화론(중): 축소 명령어 집합의 탄생

복잡 명령어 집합의 아직 초보 단계였던 컴파일러 기술과 저장 장치의 용량때문에 그 쓰임이 제한적이었지만, 기술이 발전함에 따라 그 제한이 완화되었다.

### **4.7.1 복잡함을 단순함으로**

- 파레토의 80-20 법칙: 일부가 전체를 지배한다

→ 기계 명령어 실행 빈도에도 유사하게 적용된다. CPU는 주로 전체 명령어 중 일부만 반복적으로 실행하며, 복잡한 명령어들은 자주 사용되지 않는다.

- 복잡 명령어들이 실제로는 마이크로코드를 통해 내부에서 단순 명령어로 분해되어 실행된다.

→  이로 인해 오히려 성능이 떨어지고 트랜지스터 낭비로 이어질 수 있음을 밝혔다.

- 마이크로코드는 CPU 내부에 존재하므로, 컴파일러가 이를 제어하거나 우회할 수 없다.

간단한 명령어 여러 개가 복잡한 하나의 명령어보다 더 빠를 수 있다는 점은, 복잡함을 굳이 유지할 필요가 있느냐는 근본적인 의문을 제기하게 만들었다.

### **4.7.2 축소 명령어 집합의 철학**

이러한 문제의식은 축소 명령어 집합(RISC) 철학으로 이어졌다. 핵심은 명령어를 단순화하고, 일정한 실행 시간 내에 처리되도록 하며, 복잡한 작업은 여러 간단한 명령어로 구성한다는 데 있다.

**1) 명령어 자체의 복잡성**

- 축소 명령어 집합은 복잡한 명령어를 단순한 명령어 여러 개로 나누는 방식

       Ex) ‘먹는다’ →  ‘한 입 베어 무는’ 

- 이로써 마이크로코드 없이도 CPU를 직접 제어할 수 있으며, 각 명령어는 더 작고 단순한 작업만 수행한다.

**2) 컴파일러**

- 축소 명령어 집합은 복잡한 작업을 컴파일러에 맡겨, 컴파일러가 CPU 실행을 더 정밀하게 제어할 수 있게 한다.
- 이는 ‘흥미로운 일은 컴파일러에 넘긴다’는 철학으로, 최적화에 유리하다.

**3) LOAD/STORE 구조**

- 복잡 명령어 집합은 한 명령어로 메모리 접근과 연산을 모두 처리하지만, 축소 명령어 집합은 연산과 메모리 접근을 분리하여 오직 LOAD와 STORE로만 메모리를 다룬다.
- 이로써 구조가 단순하고 예측 가능해진다.

메모리 접근은 여전히 필요하지만, 축소 명령어 집합에서는 LOAD와 STORE 명령어만이 이를 담당한다.

다른 명령어는 오직 레지스터만 다루며, 메모리에는 직접 접근할 수 없다.

## 4.7.3 복잡 명령어 집합과 축소 명령어 집합의 차이

CPU 내부에는 레지스터와 연산 장치인 ALU가 있다. 숫자가 각각 메모리 주소 A와 주소 B에 저장되어 있으면, 이 두 숫자를 곱한 값을 먼저 계산한 후, 그 결과를 다시 메모리 주소 A에 기록하는 과정을 가정한다.

1. 복잡 명령어 집합의 경우

복잡 명령어 집합 CPU에는 MULT라는 곱셈 명령어 실행 시 다음 동작이 수행된다.

- 메모리 주소 A의 데이터를 읽어 레지스터에 저장한다.
- 메모리 주소 B의 데이터를 읽어 레지스터에 저장한다.
- ALU가 레지스터 값을 이용해 곱셈 연산을 수행한다.
- 곱셈 결과를 다시 메모리에 쓴다.

이 모든 단계가 하나의 명령어로 처리된다.

→ 복잡 명령어가 단순히 명령어 자체가 복잡한 것이 아니라, 내부에서 수행하는 작업이 복잡함을 의미한다.

→ 복잡 명령어 집합은  고급 언어와 기계 명령어 간 차이를 줄여 프로그래머가 최소한의 코드로 작업할 수 있게 하고 프로그램 저장 공간도 절약하는 것을 목표로 한다.

2. 축소 명령어 집합의 경우

축소 명령어 집합에서 곱셈 작업을 완성하는 단계는 다음과 같다.

- 메모리 주소 A의 데이터를 읽어 레지스터에 저장한다.
- 메모리 주소 B의 데이터를 읽어 레지스터에 저장한다.
- ALU가 레지스터 값을 이용해 곱셈 연산을 수행한다.
- 곱셈 결과를 다시 메모리에 쓴다.

각 단계는 각각의 명령어에 대응되므로, 다음과 같은 명령어들을 순서대로 작성해야 한다.

```c
LOAD RA, A  
LOAD RB, B  
PROD RA, RB  
STORE A, RA  
```

→ 축소 명령어 집합은 더 많은 저장 공간을 필요로 하며, 프로그래머가 직접 어셈블리 코드를 작성할 때 더 번거롭다.

→ 그러나 축소 명령어 집합 설계의 본래 목적은 프로그래머가 직접 어셈블리어를 작성하지 않고 컴파일러가 기계 명령어를 자동 생성하도록 하는 데 있다.

## 4.7.4 명령어 파이프라인

1. 축소 명령어 집합(RISC)
- 명령어가 단순하고 실행 시간이 거의 동일하여, 복잡한 하드웨어 없이도 작동 가능하다.
- 단순한 구조 덕분에 트랜지스터를 절약할 수 있으며, 이를 다른 CPU 기능에 활용할 수 있다.
- 명령어 실행 시간이 일정하므로, 파이프라인 기술을 효과적으로 적용할 수 있다. 파이프라인 기술은 명령어 실행 시간을 단축하진 않지만, 처리 효율을 높여 CPU가 쉬지 않고 명령어를 연속적으로 처리할 수 있게 한다.
- RISC 구조는 파이프라인 효율을 극대화하도록 명령어 설계를 단순하고 균일하게 한다.

2. 복잡 명령어 집합(CISC)
- 명령어별 실행 시간이 불균형하여 파이프라인을 효율적으로 활용하기 어렵다.
- RISC 프로세서는 보통 5단계 파이프라인 구조를 사용하며, 명령어 하나를 1~2 클럭 주기에 실행할 수 있다. 반면 CISC는 명령어 하나 실행에 5~10 클럭 주기가 필요하다.
- RISC는 명령어 수는 많지만 마이크로코드가 없어 CPU가 작고 단순하며, 높은 클럭 주파수를 유지할 수 있다.

이로 인해 RISC 구조의 CPU는 CISC 구조에 비해 성능 면에서 더 우수하게 작동한다.

## 4.7.5 천하에 명성을 떨치다

1980년대 중반부터 축소 명령어 집합(RISC)을 사용하는 상용 CPU가 등장하기 시작하였고, 성능 우위로 인해 대부분의 CPU 제조업체가 RISC 설계를 따르기 시작하였다.

이 시기 x86은 복잡 명령어 집합 기반이었고, RISC에 비해 효율이 낮다는 평가를 받았다. 결과적으로 CISC는 암흑기에 접어들게 되었다.

---

# 4.8 CPU 진화론(하) : 절체절명의 위기에서 반격

복잡 명령어 집합(CISC) 진영에서 기존에 팔린 칩과 수많은 프로그램의 호환성 문제로 단순히 RISC로 전환하는 것은 어려웠다. 이때 하드웨어 엔지니어들은 소프트웨어에서의 ‘함수 인터페이스’ 개념처럼, 외부에 노출된 명령어 집합은 그대로 두되, 내부 구현 방식을 바꾸는 방법을 고안했다. 그 결과 등장한 것이 바로 ‘마이크로 명령어’ 개념이다.

## 4.8.1 이길 수 없다면 함께하라: RISC와 동일한 CISC

당시 RISC가 파이프라인 기술을 잘 활용해 성능 우위를 점한 반면, CISC는 명령어 실행 시간이 들쭉날쭉해 파이프라인 활용이 어려웠다.

이를 해결하기 위해 CISC 명령어를 CPU 내부에서 간단한 RISC 스타일의 **마이크로 명령어**로 변환하는 방법이 고안되었다.

이렇게 하면 외부에서는 기존 CISC 명령어를 그대로 사용하면서도, 내부에서는 일정한 실행 시간을 가진 마이크로 명령어로 처리할 수 있어 파이프라인 기술을 적극 활용할 수 있었다. 

## 4.8.2 하이퍼스레딩이라는 필살기

복잡 명령어 집합 진영은 내부 구조를 단순하게 만드는 것 외에도 또 다른 강력한 기술을 개발했는데, 그것이 바로 **하이퍼스레딩**이다.

기존에는 CPU 코어 하나가 한 번에 하나의 스레드만 실행할 수 있는 것으로 여겨졌지만, 하이퍼스레딩 기술이 적용된 경우, 하나의 물리적 CPU 코어가 마치 두 개의 코어처럼 작동해 동시에 두 개의 스레드를 처리할 수 있다.

이 기술의 원리는 다음과 같다.

- CPU 내부의 파이프라인 구조는 연속적으로 명령어를 처리하지만, 명령어 간의 종속성 때문에 파이프라인이 빈 상태가 되는 경우가 종종 발생한다.
  → 이 빈 공간에 다른 스레드의 명령어 흐름을 끼워 넣음으로써 CPU의 리소스를 더욱 효율적으로 활용할 수 있다.
  → 결과적으로 CPU가 아무 일도 하지 않고 대기하는 시간을 줄일 수 있어 전반적인 처리 속도가 개선된다.

중요한 점은 하이퍼스레딩이 운영 체제가 다루는 일반적인 스레드와는 다르다는 것이다.

- 소프트웨어 스레드는 운영 체제가 생성하고 관리하는 대상으로, 프로그래머가 인식할 수 있는 수준에서 존재한다.
- 반면 하이퍼스레딩은 CPU 하드웨어 자체에서 작동하는 기능으로, 운영 체제는 이를 직접 제어할 수 없다.
  → 운영 체제는 단지 시스템에 더 많은 CPU 코어가 존재하는 것처럼 인식할 뿐이며, 실제로는 물리적인 코어 수보다 적다.

## 4.8.3 장점은 취하고 약점은 보완하다: CISC와 RISC의 통합

- CISC에서 시작된 하이퍼스레딩 기술은 이후 RISC 진영에서도 도입되기 시작했으며, 일부 고성능 RISC CPU에서도 하이퍼스레딩이 활용되는 것을 볼 수 있다.
- CISC는 내부 구조를 RISC처럼 단순하게 바꾸고 있고, RISC 역시 CISC에서 사용되던 마이크로 명령어 방식을 일부 도입하고 있다.

결과적으로 두 구조는 처음 등장했을 때처럼 명확히 구분되지 않으며, 점점 서로 닮아가고 있는 추세이다.

그럼에도 불구하고 여전히 존재하는 몇 가지 차이점은 다음과 같다.

- RISC에서는 컴파일러가 더 큰 역할을 담당하며, 명령어 길이가 고정되어 있어 컴파일러가 최적화하기 유리하다.
  → CISC는 명령어 길이가 가변적이기 때문에 컴파일러 최적화가 다소 복잡하다.
- 메모리 접근 방식에서 RISC는 LOAD/STORE 구조를 유지하고 있다.
  → CISC는 연산 중 직접 메모리에 접근하는 방식도 사용한다.

이제 두 구조의 기술적 차이는 점점 작아지고 있으며, 상업적 관점에서는 거의 구분되지 않을 정도로 통합된 방향으로 발전하고 있다.

## 4.8.4 기술이 전부는 아니다: CISC와 RISC 간 상업적 전쟁

CISC(x86)와 RISC(ARM)의 경쟁은 단순히 기술적인 우열로만 결정되지 않았다. 1980~1990년대, RISC 아키텍처는 기술적으로 더 우수한 성능을 보여주며 등장했지만, 당시 x86 진영은 막강한 소프트웨어 생태계를 갖추고 있었다. 수많은 프로그램이 286 플랫폼에서 안정적으로 구동되고 있었고, 개발자들이 RISC 기반 소프트웨어를 준비하는 사이 x86은 성능 개선에 성공했다. 특히 인텔과 마이크로소프트의 윈텔 연합은 윈도 운영체제와 호환되는 소프트웨어를 중심으로 시장을 장악했고, 높은 출하량과 낮은 칩 설계 비용이라는 상업적 이점을 통해 RISC보다 유리한 위치를 점했다. x86은 RISC의 장점까지 흡수하며 기술적으로도 성장했고, 애플마저도 2006년 PowerPC(RISC 기반)를 버리고 x86으로 전환하면서 데스크톱 시장은 사실상 x86의 독주 체제가 되었다.

서버 시장에서도 유사한 양상이 펼쳐졌다. 한때 썬 마이크로시스템즈의 SPARC(RISC 기반)가 주도권을 잡았지만, 닷컴 버블 붕괴 이후 x86이 서버 영역마저 장악했다. 인텔의 개방적 전략은 RISC 진영의 폐쇄성과 대비되었고, 이로 인해 인텔은 상업적 성공을 거두며 ‘x86의 시대’를 열게 되었다.

그러나 2007년 아이폰의 등장은 모바일 시대의 시작이었고, ARM 기반 RISC 프로세서가 스마트폰 시장을 빠르게 지배하게 된다. 인텔과 마이크로소프트는 대응이 늦었고, 그 사이 ARM은 모바일 시장을 선점했다. 애플은 자체 설계한 A 시리즈 칩으로 성능을 높이며 결국 ARM 기반의 M1 칩을 통해 데스크톱 영역까지 진출했고, 인텔의 x86을 버리기에 이른다. ARM 아키텍처는 데스크톱에서도 다시 주목받기 시작한 것이다.

현재 x86은 여전히 데스크톱과 서버 시장에서 강세를 보이고 있으며, ARM은 모바일 시장을 주도하고 있다. 양측은 서로의 시장을 공략하고 있으나, 아직은 눈에 띄는 결과는 없다. 기술은 계속 진화하고 있으며, CISC와 RISC 간의 경쟁은 앞으로 더욱 흥미롭게 펼쳐질 전망이다.

---

# 4.9 CPU, 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 통달하기

컴퓨터 시스템에는 함수 호출, 시스템 호출, 프로세스·스레드 전환, 인터럽트 처리 등 중요한 구조들이 있다.

이들은 코드 재사용, 운영체제 요청, 다중 작업, 외부 장치 관리 등을 가능하게 하며, 컴퓨터 시스템의 핵심 기반이 된다.

## 4.9.1 레지스터

- CPU에 레지스터가 필요한 이유는 **속도** 때문이다.

레지스터는 메모리보다 약 100배 빠르게 접근할 수 있기 때문에, CPU가 계산 성능을 유지하려면 반드시 레지스터가 필요하다. 만약 레지스터 없이 메모리에만 의존한다면 계산 속도는 현저히 느려지게 된다.

- 프로세스가 생성되면, 실행할 코드와 데이터는 메모리에 적재되고, CPU는 명령어를 수행할 때 메모리의 데이터를 레지스터로 옮겨 계산에 사용한다.

레지스터와 메모리는 모두 정보를 저장하는 장치라는 점에서 본질적인 차이는 없지만, 레지스터는 훨씬 빠르고 비싸며 용량이 제한적이다. 따라서 프로세스 실행 중 필요한 데이터는 메모리에 저장해 두고, CPU가 사용할 때만 레지스터로 옮겨 일시적으로 보관하게 된다.

또한, 단순한 계산용 외에도 다양한 용도의 레지스터가 존재하며, 이들은 기능에 따라 여러 유형으로 나뉜다.

## 4.9.2 스택 포인터

모든 함수는 실행될 때 스택 프레임을 가지며, 이는 함수의 로컬 변수나 매개변수 등을 저장하는 독립된 메모리 공간이다.

- 함수가 호출될 때마다 새로운 스택 프레임이 생성
- 함수가 종료되면 해당 프레임이 제거
- 함수 호출의 깊이에 따라 스택 프레임 수는 변화

이렇게 생성된 스택 프레임들이 모여 스택 영역을 형성한다. 스택에서 가장 중요한 정보는 스택 상단이고,  이 위치는 스택 포인터가 가리키고 있어 현재의 함수 호출 상태를 추적할 수 있다.

또한 지금 어떤 명령어를 실행하고 있는지도 중요한데, 이 정보는 명령어 주소 레지스터가 가지고 있다.

## 4.9.3 명령어 주소 레지스터

**명령어 주소 레지스터**는 프로그램 카운터(Program Counter, PC)나 명령어 포인터(Instruction Pointer, IP)라고 부르기도 한다.  명령어주소 레지스터는 다음과 같이 동작한다.

- 프로그래머가 고급 언어로 작성한 코드는 컴파일러를 통해 일련의 기계 명령어로 변환된다. 이렇게 변환된 명령어들 중에서 CPU가 어떤 명령어를 실행할지는 PC 레지스터의 값에 의해 결정된다.
- 프로그램이 실행되면, 첫 번째로 실행할 명령어의 주소가 PC 레지스터에 저장된다. CPU는 이 주소를 이용해 메모리에서 해당 명령어를 가져와 실행하게 된다. 일반적인 경우에는 명령어가 순차적으로 실행되므로 PC의 값도 순차적으로 증가한다.

하지만 제어 흐름이 변경되는 명령어, 예를 들어 조건문이나 반복문, 함수 호출 및 반환 등은 새로운 명령어의 주소를 PC 레지스터에 직접 저장하여 실행 흐름을 바꾼다.

## 4.9.4 상태 레지스터

CPU에는 여러 종류의 레지스터가 있으며, 그중 하나가 **상태 레지스터**이다. 이 레지스터는 FLAGS 레지스터 또는 응용 프로그램 상태 레지스터라고도 불리며, 주로 다음과 같은 역할을 한다.

- 연산 결과에 대한 정보를 저장한다.

  EX) 덧셈 연산 중 자리 올림(carry)이 발생하거나, 값이 너무 커서 넘침(overflow)이 생길 경우, 그 결과가 상태 레지스터에 기록된다.


또한 CPU는 명령어를 실행할 때 두 가지 동작 상태를 가진다.

- 사용자 상태 (User Mode): 일반 프로그램이 실행되는 상태이며, 시스템 자원에 직접 접근할 수 없다.
- 커널 상태 (Kernel Mode): 운영체제 커널이 사용하는 상태로, 모든 명령어를 실행할 수 있다.

## 4.9.5 상태 정보

레지스터는 프로그램이 실행된 이후 현재까지의 CPU 상태를 보여주는 장치이다. 여기에 저장된 모든 정보를 상황 정보, 즉 컨텍스트라고 한다. 상황 정보는 프로그램 실행을 잠시 멈추거나, 중단된 지점에서 다시 시작할 수 있도록 해주는 중요한 요소이다.

이 정보를 저장하고 복원해야 하는 이유는, CPU가 명령어를 항상 순서대로 실행하는 것이 아니기 때문이다. 실제로 실행 흐름이 바뀌거나 멈추는 상황은 다양하다.

- 하나의 프로그램에서 다른 프로그램으로 전환되는 경우
- 사용자 상태에서 커널 상태로 바뀌는 경우
- 실행 중인 프로그램이 전환되거나 중단되는 경우
- 인터럽트로 인해 프로그램 실행이 갑자기 멈추는 경우

이러한 상황에서도 프로그램이 원래대로 실행을 계속하려면, CPU는 중단 전 상태를 저장해두어야 한다. 이후 이 상태를 복원하면 정확히 그 지점에서부터 실행을 다시 시작할 수 있다.

상황 정보의 저장과 복원은 다음 네 가지 기능의 핵심이 된다. 이 기능들은 모두 상황 정보 관리에 기반하여 동작한다.

- 함수 호출
- 시스템 호출
- 스레드 전환
- 인터럽트 처리

## 4.9.6 중첩과 스택

프로그램 실행 중에는 예상치 못한 중단과 재개가 자주 발생한다.

- 현실 상황으로 표현

  프로그래머가 코딩을 하다가 회의에 불려가고, 회의 중 전화가 와서 잠시 나간 후 다시 회의로 돌아오고, 마지막으로 자리로 복귀해 코딩을 이어가는 흐름

- 수학적으로 표현

  f(g(h(a)))와 같은 중첩 함수 호출 구조. h(a)를 먼저 계산하고, 그 결과를 g에 넘기고, 마지막으로 f에 적용해야 최종 결과를 얻을 수 있다.

- 웹 브라우징으로 표현

  페이지 A → B → C로 이동한 뒤, C부터 차례로 닫고 A로 돌아오는 구조와 같다.


이런 구조의 공통점은 다음과 같다.

- 가장 나중에 시작한 작업이 가장 먼저 끝난다.
- 가장 먼저 시작한 작업이 가장 마지막에 끝난다.
- 이를 후입선출, 즉 LIFO(Last In, First Out) 구조라고 한다.

이 구조를 처리하기 위해 사용하는 것이 바로 스택이다. 스택은 다음과 같은 중첩된 상황에서 중요한 역할을 한다.

- 함수 호출
- 시스템 호출
- 스레드 전환
- 인터럽트 처리

이처럼 중단과 복귀가 반복되는 작업 흐름에서, 스택은 실행 상태를 저장하고 복원하는 데 사용된다. 스택이라는 구조는 중첩 상황을 정확하게 처리할 수 있는 방식이다.

## 4.9.7 함수 호출과 실행시간.

함수를 호출할 때 어려운 점은 CPU가 호출된 함수의 첫 번째 명령어로 점프한 이후, 함수 실행이 끝나면 다시 원래 위치로 돌아와야 한다는 점이다. 이를 위해 함수 실행 전에 현재 상태를 보존하고, 실행 후에는 이를 정확히 복원해야 한다.

- 모든 함수는 실행 시 독립적인 저장 공간을 갖는다. 이 공간은 함수 실행 중 필요한 상태 정보를 담는데, 이를 **스택 프레임(stack frame)** 이라고 부른다.
- 예를 들어 함수 A가 함수 B를 호출하면, 함수 A의 실행 정보는 A의 스택 프레임에 저장된다. 이어서 B가 실행되고, B가 다시 함수 C를 호출하면, B의 실행 정보도 B의 스택 프레임에 저장된다.
- 이처럼 함수가 호출될 때마다 각각의 스택 프레임이 쌓이는데, 이 스택은 후입선출(LIFO, Last In First Out) 구조이다.

따라서 함수 A → B → C 순으로 호출되면, 스택에는 C, B, A 순서로 쌓이고, 함수 실행 완료 시에는 C부터 복원되어 실행이 끝난 후 B, 그리고 마지막으로 A로 돌아간다.

이 구조 덕분에 여러 함수가 중첩 호출되어도 각 함수의 상태를 안전하게 관리하며 정상적으로 실행 흐름을 유지할 수 있다.

## 4.9.8 시스템 호출과 커널 상태 스택

디스크 파일을 읽거나 쓰거나, 새로운 스레드를 생성하는 작업의 실제 주체는 운영 체제이다. 응용 프로그램은 **시스템 호출(system call)** 을 통해 운영 체제에 서비스를 요청하는 구조이다.

시스템 호출이 처리되는 과정은 다음과 같다.

1. 운영 체제도 내부적으로 관련 함수를 호출하여 요청을 처리한다.
2. 이때 필요한 실행 시간 스택은 **커널 상태 스택(kernel mode stack)** 이다.
3. 모든 사용자 상태 스레드는 대응하는 커널 상태 스택을 갖고 있으며, 사용자 스레드가 운영 체제 서비스를 요청하면 시스템 호출을 통해 이를 전달한다.
4. 시스템 호출은 특정 기계 명령어로 구현되어 있는데, 32비트 x86 시스템에서는 `INT` 명령어가 이에 해당한다.

시스템 호출 명령어가 실행되면 CPU는 다음과 같이 동작한다

- 사용자 상태에서 커널 상태로 전환한다.
- 해당 스레드에 대응하는 커널 상태 스택을 찾는다.
- 사용자 상태에서의 레지스터 값이나 실행 상황 정보가 커널 상태 스택에 저장된다.
- CPU는 커널 상태에서 운영 체제 코드를 실행하며, 커널 상태 스택은 함수 호출과 반환에 따라 크기가 변한다.

시스템 호출이 완료되면, 커널 상태 스택에 저장된 사용자 상태 실행 정보를 바탕으로 다시 사용자 상태로 전환되며, 사용자 프로그램 실행이 정상적으로 계속된다.

## 4.9.9 인터럽트와 인터럽트 함수 스택

**인터럽트**란 CPU의 현재 실행 흐름을 끊고 특정 인터럽트 처리 함수로 점프한 후, 함수 실행이 끝나면 다시 원래 위치로 돌아가는 구조이다. 인터럽트 처리 함수 역시 일반 함수와 마찬가지로 **실행 시간 스택**이 필요하다.

실행 시간 스택 구현 방식은 두 가지가 있다.

- 인터럽트 처리 함수가 별도의 스택 없이 **커널 상태 스택(kernel mode stack)** 을 공유하는 방식
- 인터럽트 처리 함수가 별도의 **ISR(Interrupt Service Routine) 스택** 을 가지는 방식
    - 이 경우 CPU마다 각자 고유한 인터럽트 처리 스택을 갖는다.


CPU는 사용자 상태에서 기계 명령어를 실행하는 도중 언제든 인터럽트가 발생할 수 있다.

1. 인터럽트 발생 시, 현재 실행 중인 프로그램은 일시 중지된다.
2. CPU는 인터럽트 처리 함수로 점프하며, 이때 사용자 상태에서 **커널 상태로 전환**된다.
3. 해당 스레드에 대응하는 커널 상태 스택을 찾아, 사용자 상태의 레지스터 및 실행 정보를 저장한다.
4. 인터럽트 처리 함수가 실행되며, 커널 상태 스택은 함수 호출과 반환에 따라 크기가 변한다.

인터럽트 처리 함수 실행 완료 후에는, 커널 상태 스택에 저장된 정보를 바탕으로 CPU 상태가 복원되고, 사용자 상태로 전환되어 중단된 프로그램이 계속 실행된다.

이 구조 덕분에 컴퓨터는 동시에 여러 작업을 원활히 처리할 수 있다.

## 4.9.10 스레드 전환과 커널 상태 스택

시스템에 스레드 A와 B가 있다고 가정할 때, 현재 스레드 A가 실행 중이다. 이때 시스템 내부의 타이머가 인터럽트 신호를 발생시키면 CPU는 이를 받아 현재 실행 중인 스레드 A의 실행을 일시 중지한다. 이후 CPU는 사용자 상태에서 커널 상태로 전환되고, 커널 내부에 있는 타이머 인터럽트 처리 프로그램을 실행하기 시작한다. 이 과정은 앞서 설명한 시스템 호출이나 인터럽트 처리와 동일한 방식으로 이루어진다.

타이머 인터럽트 처리 프로그램은 스레드 A에게 할당된 CPU 시간 조각이 모두 소진되었는지를 판단한다. 만약 시간이 남아 있다면, CPU는 다시 사용자 상태로 돌아가 스레드 A의 실행을 계속한다. 그러나 시간이 모두 사용되었다면 CPU는 다른 스레드, 예를 들어 스레드 B에게 CPU를 할당해야 한다. 이때 일어나는 작업이 바로 **스레드 전환(context switch)** 이다.

스레드 전환은 크게 두 가지 작업으로 나뉜다.

- **주소 공간 전환**

  스레드 A와 B가 서로 다른 프로세스에 속할 수 있기 때문에, 각기 다른 주소 공간을 가진다. 전환 시 이 주소 공간도 변경되어야 한다.

- **CPU 상황 정보 저장 및 복원**

  현재 실행 중인 스레드 A의 CPU 상황 정보를 저장하고, 스레드 B의 CPU 상황 정보를 복원하는 작업이다.


리눅스 운영체제에서는 모든 스레드가 프로세스 서술자(process descriptor)인 `task_struct` 구조체를 가지고 있으며, 이 구조체 내부의 `thread_struct`가 CPU 상황 정보를 저장하는 역할을 한다. 스레드 전환 시 CPU는 먼저 실행 중이던 스레드 A의 CPU 상태를 `task_struct`에 저장하고, 이어서 스레드 B의 `task_struct`에서 저장된 CPU 상태 정보를 복원한다. 이 과정은 마치 CPU가 스레드 A의 ‘기억’을 봉인하고 스레드 B의 ‘기억’을 꺼내어 스레드 B가 실행되도록 하는 것과 같다.

여기서 스레드 B의 ‘기억’이란 이전에 스레드 B가 실행되다 일시 중지된 상황을 말한다. 스레드 B는 자신이 일시 중지되었다는 사실을 알지 못하며, 단지 자신이 사용자 모드로 전환되어 실행을 계속해야 한다는 사실만 기억한다. 이후 스레드 B는 커널 상태 스택에 저장된 CPU 상황 정보를 기반으로 사용자 상태로 점프하여 마치 중단된 적 없던 것처럼 사용자 모드에서 실행을 계속한다.

결과적으로, 스레드 전환을 위해서는 다음 네 가지 상황에 대한 처리가 필요하다.

- 인터럽트 발생
- 시스템 호출
- CPU 상태 저장
- CPU 상태 복원

이 모든 구현은 CPU 상황 정보의 저장과 복원이 핵심이며, 스택과 같은 자료 구조를 활용하여 완성된다.