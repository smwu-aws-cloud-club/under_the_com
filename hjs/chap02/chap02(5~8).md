# 2장 : 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다(5-10)

## 5. 콜백 함수의 이해

### 콜백이 필요한 이유

```python
void make_donut(func f) {
	...
	f();
	...
} 
```

```python
void formed_C() {
	...
}

make_donut()
```

콜백 함수 코드는 직접 구현하고 다른 모듈이나 스레드에서 해당 함수를 호출해서 사용하면, 함수를 변수처럼 사용해서 코드를 요구에 따라 계속 바꿀 필요가 없다.

### 비동기 콜백

`make_donut(formed_D);`

`something_important();`

첫 번째 함수가 호출되는데 시간이 오래 걸려서 두 번째 함수가 실행되지 못하는 문제가 발생할 때

```python
void real_make_donut(func f) {
	...
	f();
	...
}

void make_donut() {
	thread t(real_make_donut, f)
}
```

`make_donut` 함수 내부에서 스레드를 생성하여 도넛을 형성하면, `make_donut` 함수를 호출할 때 새로운 스레드 `t`가 생성된 후 즉시 반환된다.

즉, `make_donut` 함수를 호출하면 새로운 스레드 `t`가 생성되고 즉시 반환되며, 이후 `something_important();` 줄이 실행될 수 있다.

도넛 생성 작업은 스레드가 시작된 후 실행되므로, `something_important();` 코드가 실행될 때 도넛 생성 작업이 아직 시작되지 않았을 수도 있다. 이를 **비동기(Asynchronous)** 라고 한다.

### 비동기 콜백과 새로운 프로그래밍 사고방식

동기 호출은 함수를 호출한 후 결과를 획득하고, 그 결과를 처리하는 순차적인 방식으로 진행된다. 반면, 비동기 호출은 함수의 첫 번째 부분이 호출하는 스레드에서 처리되지만, 두 번째 부분은 다른 스레드, 프로세스 또는 시스템에서 실행된다. 따라서 호출자는 요청을 보낸 후 즉시 다음 작업을 수행할 수 있으며, 결과 처리는 별도로 진행된다. 이러한 비동기 방식에서는 호출자만 이후의 작업을 어떻게 처리할지 알고 있기 때문에, 콜백 함수가 반드시 필요하다.

### 두 가지 콜백 유형

동기 콜백은 **블로킹 콜백**이라고도 하며, 함수 A를 호출할 때 콜백 함수를 매개변수로 전달하면 함수가 반환되기 전에 콜백 함수가 실행된다.

반면, 비동기 콜백은 **지연 콜백**이라고도 하며, 함수 A의 호출이 즉시 완료된 후 일정 시간이 지나야 콜백 함수가 실행된다. 이때 주 프로그램과 콜백 함수가 동시에 실행될 수도 있어, 일반적으로 서로 다른 스레드 또는 프로세스에서 동작한다.

비동기 콜백은 동기 콜백에 비해 다중 코어 리소스를 더 효율적으로 활용할 수 있다. 동기 콜백이 실행되는 동안 주 프로그램은 다른 작업을 수행하지 못하지만, 비동기 콜백은 주 프로그램의 실행을 방해하지 않고 병렬로 실행될 수 있기 때문이다.

### 비동기 콜백의 문제

서버에서 작업을 처리할 때, 사용자에게 전달되는 데이터 서비스는 한 번에 하나씩 호출되는 것이 아니라, 수십 개 또는 수백 개씩 동시에 호출될 수 있다.

이처럼 비즈니스 로직이 복잡해질 경우, 비동기 콜백을 과도하게 사용하면 **콜백 함정(Callback Hell)** 에 빠질 위험이 있다. 이는 콜백 함수가 중첩되면서 코드의 가독성이 낮아지고, 유지보수가 어려워지는 문제를 의미한다.

## 6. 동기와 비동기

### 동기 호출

동기 호출에서는 `funA` 함수가 `funB` 함수를 호출하면, `funB` 함수의 실행이 완료될 때까지 `funA`의 나머지 코드는 실행되지 않고 대기한다. 이러한 동기 호출에서는 두 함수가 동일한 스레드에서 실행된다.

하지만 입출력 작업은 다르게 처리된다. 최하층 계층에서 운영체제에 시스템 호출을 보내면, 운영체제는 파일 읽기 작업을 수행하는 동안 호출 스레드를 일시 중지시킨다. 이후 커널이 디스크에서 데이터를 읽어오면 중지되었던 스레드가 다시 실행된다. 이를 **블로킹 입출력**이라고 한다.

이 과정도 동기 호출이지만, 호출자와 파일을 읽는 코드가 다른 스레드에서 실행될 수도 있다. 따라서 동기 호출은 호출자와 수신자가 같은 스레드에서 실행되는지 여부와는 직접적인 관련이 없다.

### 비동기 호출

동기 방식으로 함수를 호출하면, 호출자는 파일을 모두 읽을 때까지 기다려야 하므로 다른 작업을 진행할 수 없다. 반면, 비동기 호출 방식에서는 작업이 완료되지 않은 상태에서도 함수가 즉시 반환되므로, 호출자는 블로킹되지 않고 다음 작업을 바로 실행할 수 있다. 이러한 특성 덕분에 비동기 호출 방식은 높은 효율성을 가진다.

비동기 호출에서 작업이 완료되는 시점을 파악하는 방법은 두 가지로 나뉜다.

1. **호출자가 실행 결과를 신경 쓰지 않는 경우**: 이때는 콜백 함수를 활용할 수 있다. 즉, 비동기 함수를 호출할 때 콜백 함수를 함께 매개변수로 전달하여, 작업이 완료되면 해당 콜백이 실행되도록 한다.
2. **호출자가 실행 결과를 반드시 알아야 하는 경우**: 이때는 알림 방식이 사용된다. 작업이 완료되면 호출자에게 신호나 메시지를 보내어 이를 알린다.

일반적으로 비동기 호출에서는 두 개의 스레드가 사용된다. 하나는 호출자가 사용하는 스레드이고, 실제 작업은 별도의 스레드에서 실행된다. 이를 통해 호출자는 작업이 진행되는 동안 다른 작업을 수행할 수 있다.

### 웹 서버에서 동기와 비동기 작업

웹 서버에서 주 스레드와 데이터베이스 처리 스레드가 있을 때, 동기 방식에서는 데이터베이스 요청을 보낸 후 주 스레드가 블로킹되어 일시 중지된다. 이때 데이터베이스 처리가 완료된 후에야 다음 단계가 진행되며, 그동안 주 스레드에는 유휴 시간이 발생한다.

반면, 비동기 방식에서는 주 스레드가 데이터베이스 처리가 완료될 때까지 기다리지 않고, 요청을 전송하자마자 다음 작업을 처리한다. 이 경우, 이전 요청의 처리는 두 가지 방식으로 진행될 수 있다.

1. **주 스레드가 데이터베이스 처리 결과를 신경 쓰지 않는 경우**
    - 데이터베이스 처리 완료 여부에 상관없이 주 스레드는 다른 요청을 처리하며, 이를 위해 **콜백 함수**를 사용한다.
    - 주 스레드는 데이터베이스 요청을 보낼 때 콜백 함수를 함께 전달하고, 데이터베이스 스레드는 작업 완료 후 해당 콜백을 호출한다.
    - 이렇게 하면 주 스레드는 사용자 요청을 처리하는 동안, 데이터베이스 스레드는 데이터베이스 작업을 처리할 수 있어 시스템 리소스를 효율적으로 활용할 수 있다.
2. **주 스레드가 데이터베이스 작업 결과를 확인해야 하는 경우**
    - 데이터베이스 스레드는 작업이 완료되면 **알림 방식**을 이용해 결과를 주 스레드로 전송한다.
    - 주 스레드는 이 메시지를 수신한 후, 이전 요청의 후반부 처리를 계속 진행한다.
    - 이 방식은 동기 호출보다는 효율적이지만, 콜백을 활용하는 비동기 호출보다는 성능이 다소 떨어질 수 있다.

결과적으로, 비동기 방식은 주 스레드가 유휴 시간을 최소화하면서 요청을 처리할 수 있도록 하여, 전체적인 시스템 성능을 향상시키는 데 유리하다.

## 7. 블로킹과 논블로킹

### 블로킹의 핵심 문제 : 입출력

블로킹 호출의 핵심은 특정 스레드나 프로세스가 **일시 중지되는 것**이다. 일반적으로 블로킹은 **입출력(I/O) 작업**과 관련이 깊으며, 운영체제는 CPU 리소스를 최대한 활용하기 위해 각 스레드 간에 CPU 사용 시간을 효율적으로 할당해야 한다. 이러한 이유로 블로킹 I/O 방식이 사용된다.

그러나 시간이 오래 걸리는 입출력 작업이 포함될 경우, 호출한 스레드가 블로킹되어 **일시 중지되는 상황**이 발생할 수 있다. 이때, 호출 스레드가 멈추지 않고도 입출력 작업을 시작할 수 있도록 하는 방식이 논블로킹 호출(Non-blocking I/O)이다. 논블로킹 호출을 사용하면 호출한 스레드는 즉시 반환되어 다른 작업을 계속 수행할 수 있어, 시스템 리소스를 더욱 효율적으로 활용할 수 있다.

### 논블로킹과 비동기 입출력

요청을 전달한 후 데이터를 언제 수신했는지 알기 위해서는 **세 가지 방법**이 있다.

1. **주기적 확인(Polling)**

   논블로킹 방식의 함수 외에 **결과를 확인하는 함수**를 함께 제공하여, 호출자가 해당 함수를 반복적으로 호출해 데이터가 수신되었는지 확인하는 방법이다.

2. **알림(Notification) 방식**

   데이터가 수신되면 **스레드에 메시지나 신호(Signal) 등을 전송**하여 호출자에게 알리는 방식이다.

3. **콜백(Callback) 방식**

   함수를 호출할 때 **데이터 수신 처리를 담당하는 함수를 콜백 함수로 매개변수에 전달**하는 방법이다. 이 방식에서는 호출된 함수가 내부적으로 **콜백 함수를 지원**해야 한다.


이러한 방식이 바로 논블로킹 호출(Non-blocking I/O)이며, 이러한 유형의 입출력 작업을 **비동기 입출력(Asynchronous I/O, Async I/O)**이라고도 한다.

### 동기와 블로킹

동기와 블로킹은 다소 유사하다. 동기 호출은 반드시 블로킹이 아니지만 블로킹 호출은 모두 확실한 동기 호출이다.

```python
int sum(int a, int b) {
	return a+b;
}

void funcA() {
	sum(1, 1)
}
```

여기서 sum함수에 대한 호출은 동기이지만 funcA함수가 sum함수를 호출했다고 해서 블로킹되거나 스레드가 일시 중지되지는 않는다. 반면 어떤 함수가 블로킹 방식으로 호출된 경우 반드시 동기 호출이다.

### 비동기와 논블로킹

```python
void handler(void *buf) {
	//수신된 네트워크 데이터를 처리한다.
	...
} 

while(true) {
	fd = accept();
	recv(fd, buf, NON_BLOCKING_FLAG) //호출 후 바로 반환, 논블로킹
	
	while(!check(fd)) {
		//순환감지
		;
	}
	
	handler(buf);
}
```

`recv` 함수는 논블로킹(non-blocking)으로 호출되지만, while 반복문을 통해 지속적으로 데이터 수신을 확인(polling) 하기 때문에, 데이터가 도착하기 전까지는 `handler` 함수를 실행할 수 없다.

즉, `recv` 함수 자체는 논블로킹이지만, 전체적인 코드의 흐름을 보면 동기적인(synchronous) 방식이다.

**따라서, 이 코드는 논블로킹이면서도 동기적인 방식에 해당한다.**

## 8. 블로킹과 논블로킹

### 다중 프로세스

서비스를 동시에 처리하기 위한 가장 간단한 병행 처리 방식 중 하나로 다중 프로세스(Multi-Process) 방식이 등장했다. 이 방식에서는 부모 프로세스가 사용자 요청을 수신한 후, 자식 프로세스를 생성하여 해당 요청을 처리한다. 즉, 각각의 요청마다 대응하는 별도의 프로세스가 생성된다.

다중 프로세스 방식의 장점은 다음과 같다.

1. 구현이 간단하고 이해하기 쉬움 – 프로그래밍이 직관적이며 복잡한 동기화 문제가 적다.
2. 프로세스 격리로 인해 안정성 증가 – 하나의 프로세스가 강제 종료되더라도 다른 프로세스에는 영향을 주지 않는다.
3. 다중 코어 활용 가능 – 여러 개의 프로세스가 개별적으로 실행되므로 CPU 코어를 최대한 활용할 수 있다.

반대로 다중 프로세스 방식의 단점은 다음과 같다.

1. 프로세스 간 통신이 어렵다 – 주소 공간이 격리되어 있어 프로세스 간 데이터를 주고받으려면 IPC(Inter-Process Communication) 방식(예: 파이프, 메시지 큐, 공유 메모리 등)이 필요하다.
2. 프로세스 생성 비용이 크다 – 프로세스 생성과 종료가 반복되면 시스템 리소스 부담이 증가하여 성능 저하가 발생할 수 있다.

### 다중 스레드

스레드(Thread)는 프로세스의 주소 공간을 공유하기 때문에, 스레드 간 통신을 위해 별도의 IPC(프로세스 간 통신) 방식을 사용할 필요가 없다.

스레드 방식의 장점은 다음과 같다.

1. 프로세스보다 가볍고 생성·종료 부담이 적다 – 스레드는 개별 주소 공간을 가지지 않기 때문에, 생성 및 종료 비용이 낮고 실행 속도가 빠르다.
2. 직접 메모리를 공유하여 통신이 빠름 – 프로세스 내에서 공유 메모리를 통해 직접 데이터 접근이 가능하여 성능이 향상된다.
3. 블로킹된 스레드가 다른 스레드에 영향을 주지 않음 – 특정 스레드가 입출력 작업으로 블로킹되더라도 다른 스레드는 계속 실행될 수 있다.

스레드 방식의 단점은 다음과 같다.

1. 하나의 스레드가 강제 종료되면 전체 프로세스가 종료됨 – 같은 프로세스를 공유하는 모든 스레드가 한꺼번에 종료될 위험이 있다.
2. 공유 자원에 대한 동기화 필요 – 여러 스레드가 동일한 데이터를 동시에 읽고 쓸 경우, 데이터 충돌이나 오염(Race Condition)이 발생할 수 있다.
    - 이를 해결하기 위해 뮤텍스(Mutex), 세마포어(Semaphore), 락(Lock)과 같은 동기화 기법을 사용해야 한다.
3. 디버깅이 어렵다 – 동시성 문제(예: 데드락, 교착 상태)가 발생할 가능성이 높아 문제 분석과 디버깅이 복잡해진다.

**즉 스레드는 프로세스보다 가볍고 빠르지만, 동기화 문제를 해결해야 하며, 하나의 스레드 오류가 전체 프로세스 종료로 이어질 위험이 있다.**

### 이벤트 순환과 이벤트 구동

이벤트 기반 프로그래밍에는 두 가지 핵심 요소가 필요하다.

1. **이벤트**
    - 네트워크 데이터의 수신 여부, 파일의 읽기 및 쓰기 가능 여부 등과 같이 특정 동작을 감지하는 대상이 된다.
2. **이벤트를 처리하는 함수(이벤트 핸들러)**
    - 이벤트가 발생했을 때 실행되는 함수이며, 이벤트 유형에 따라 적절한 처리를 수행한다.

이벤트 기반 프로그래밍에서는 이벤트가 발생할 때까지 대기하고, 이벤트가 발생하면 해당 유형에 맞는 이벤트 핸들러를 찾아 실행한다.

이벤트는 계속해서 발생할 수 있기 때문에 이를 처리하는 반복적인 흐름이 필요하다. 서버에서는 사용자 요청이 이벤트에 해당하며, 이를 지속적으로 수신하고 처리해야 한다.

이를 위해 `while` 또는 `for` 반복문을 사용하여 이벤트를 감지하고 처리하는데, 이를 **이벤트 순환(Event Loop)**이라고 한다. 이벤트 순환은 이벤트가 도착할 때까지 대기한 후, 해당 이벤트에 대응하는 이벤트 핸들러를 호출하여 처리하는 방식으로 동작한다.

### 이벤트 소스와 입출력 다중화

여러 개의 파일 서술자를 동시에 처리하려면 단순히 순차적으로 처리하는 것이 아니라 운영체제에 처리를 위임하는 것이 효율적이다. 이를 **입출력 다중화(I/O Multiplexing)**라고 하며, 가장 대표적인 기술이 리눅스의 **epoll**이다.

epoll의 동작 방식은 다음과 같더.

1. **epoll 생성**
    - `epoll_create()`를 호출하여 epoll 객체를 생성한다.
2. **파일 서술자(파일 디스크립터, fd) 등록**
    - `epoll_ctl()`을 사용하여 epoll이 감시할 파일 서술자(fd)를 등록한다.
3. **이벤트 감지 및 처리**
    - `epoll_wait()`을 호출하여 등록된 파일 서술자 중 이벤트가 발생한 항목을 감지한다.
    - 감지된 이벤트에 대해 적절한 처리를 수행한다.

### 의사 코드

```c
/  ㅛ   ㅛ/ epoll 생성
int epoll_fd = epoll_create();

// 서술자를 epoll에 등록
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd1, ...);
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd2, ...);

while (1) {
    int n = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
    for (int i = 0; i < n; i++) {
        // 특정 이벤트 처리
    }
}

```

### epoll의 특징

- **이벤트 기반 처리**: 블로킹 없이 다수의 파일 서술자에서 이벤트를 감지하고 처리할 수 있다.
- **높은 효율성**: `poll`이나 `select`와 비교해 대규모 동시 연결을 더 효율적으로 처리한다.
- **이벤트 드리븐(Event-Driven) 방식**: epoll이 이벤트 발생을 감지하면 `epoll_wait()`가 이벤트를 반환하고, 해당 이벤트를 처리하는 방식으로 작동한다.

즉, **epoll은 이벤트 순환(Event Loop)의 엔진 역할**을 하며, 지속적으로 다양한 이벤트를 감지하여 효율적인 네트워크 및 파일 I/O 처리를 가능하게 한다.

### 이벤트 순환과 다중 스레드

이벤트 핸들러에는 입출력 작업이 전혀 없고 처리 함수가 간단하여 실행 시간이 매우 짧다는 특징이 있다. 이 경우 이벤트 핸들러와 이벤트 순환을 동일한 단일 스레드에서 실행할 수 있다. 모든 요청은 순차적으로 처리되며 단일 스레드에서 실행되므로 컨텍스트 스위칭 비용이 없다. 하지만 하나의 요청이 CPU 시간을 많이 소모하면 다른 요청이 대기해야 하고 요청 A를 처리하는 동안 요청 B에 대한 응답을 할 수 없어 시스템 응답이 지연될 수 있다.

이 문제를 해결하기 위해 다중 스레드를 활용해야 한다. 이벤트 핸들러는 이제 이벤트 순환과 별개의 스레드에서 실행된다. 이벤트 루프(Event Loop)는 요청을 수신한 후 빠르게 처리하여 각각의 작업자 스레드(Worker Thread)에 분배한다. 다중 스레드를 활용하면 다중 코어 시스템의 성능을 최대한 활용하여 요청을 병렬로 처리할 수 있다. 작업자 스레드는 스레드 풀(Thread Pool)을 이용해 관리할 수 있다.

이러한 구조를 반응자 패턴(Reactor Pattern)이라고 한다. 이벤트 루프는 요청을 감지하고 즉시 작업자 스레드에 전달한다. 작업자 스레드는 이벤트 핸들러를 실행하여 요청을 처리한다. 비동기 이벤트 처리를 통해 효율적으로 동시 요청을 처리할 수 있으며 주로 네트워크 서버, GUI 프로그래밍, 비동기 프로그래밍에서 사용된다. 이 패턴을 적용하면 대량의 요청을 빠르게 처리하면서도 시스템의 다중 코어 성능을 최대로 활용할 수 있다.

### 이벤트 순환과 입출력

요청 처리 과정에 입출력 작업이 포함된다고 가정하면 입출력 작업을 두 가지 상황으로 나눌 수 있다.

첫 번째는 입출력 작업에 대응하는 논블로킹 인터페이스가 있는 경우다. 이때는 논블로킹 인터페이스를 직접 호출해도 스레드가 일시 중지되지 않으며, 인터페이스가 즉시 반환되므로 이벤트 순환에서 직접 호출하는 것이 가능하다. 즉, 이벤트 루프에서 논블로킹 입출력을 수행하면 추가적인 스레드 생성 없이도 빠르게 이벤트를 처리할 수 있다.

두 번째는 입출력 작업에 블로킹 인터페이스만 있는 경우다. 이때는 이벤트 순환 내에서 블로킹 인터페이스를 호출하면 안 된다. 블로킹 인터페이스를 호출하면 이벤트 순환 스레드가 일시 중지될 수 있으며, 전체 시스템이 정체될 위험이 있다. 따라서 블로킹 입출력 호출이 포함된 작업은 반드시 별도의 작업자 스레드에 전달해야 한다. 작업자 스레드가 블로킹 작업을 수행하는 동안 이벤트 루프는 다른 요청을 계속 처리할 수 있도록 유지된다.

이러한 설계 방식은 비동기 이벤트 처리 시스템에서 핵심적인 개념이며, 논블로킹 입출력과 블로킹 입출력의 차이를 이해하고 적절한 방식으로 설계하는 것이 중요하다.