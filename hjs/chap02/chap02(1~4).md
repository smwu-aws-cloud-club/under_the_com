# 컴퓨터 밑바닥의 비밀: 2장

## 1. 운영체제, 프로세스, 스레드의 근본 이해하기

### CPU에서의 시작

CPU는 스레드, 프로세스, 운영체제 같은 개념을 전혀 알지 못 하고 단지 다음 두 가지 사항만 알고 있다.

- 메모리에서 명령어를 하나 가져온다
- 이 명령어를 실행한 후 다시 위로 돌아간다.

즉 CPU의 단계는 다음과 같다.

`명령어 인출` → `명령어 실행` → `다음 명령어 인출`

CPU는 프로그램 카운터(PC) 라고 불리는 레지스터에서 다음에 실행할 명령어를 가져온다.

PC레지스터가 저장하는 주소는 기본적으로 1씩 자동 증가하지만, if else 혹은 함수 호출같은 명령어를 만나면 CPU는 연산결과 또는 명령어에서 지정한 점프할 대상 주소에 따라 PC 레지스터 값을 동적으로 변경한다.

프로그램이 실행되는 전체 과정은 다음과 같다.

- **프로그램 작성**: 개발자가 프로그래밍 언어로 소스 코드를 작성한다.
- **컴파일**: 컴파일러가 소스 코드를 기계어로 변환한다.
- **실행 파일 생성**: 컴파일된 결과물이 실행 가능한 파일로 저장된다.
- **메모리 로드**: 실행 파일이 메모리에 적재되어 명령어와 데이터가 배치된다.
- **PC 레지스터 설정**: CPU는 `main` 함수에 해당하는 첫 번째 명령어의 메모리 주소를 PC 레지스터에 기록한다.
- **CPU 실행**: CPU가 PC 레지스터에 기록된 주소를 따라 명령어를 읽고 실행한다.

`main` 함수가 실행되기 전에, 일부 레지스터 초기화와 같은 별도의 초기화 과정이 선행된다.

### CPU에서 운영체제까지

CPU가 프로그램을 실행하기 위해서는 실행 파일을 메모리에 복사한 후, `main` 함수에 해당하는 첫 번째 기계 명령어의 메모리 주소를 PC 레지스터에 기록해야 한다. 이러한 방식으로 프로그램을 실행할 수 있지만, 이 과정은 매우 복잡하고 번거롭다.

CPU는 한 번에 하나의 작업만 수행할 수 있기 때문에 여러 프로그램이 동시에 실행되는 것처럼 보이려면 CPU가 첫 번째 프로그램을 실행했다가 잠시 중지하고, 두 번째 프로그램을 실행한 뒤 다시 첫 번째 프로그램으로 돌아가는 과정을 반복해야 한다. 이 전환 과정이 충분히 빠르면 프로그램들이 동시에 실행되는 것처럼 보이게 된다.

또한, CPU가 프로그램의 실행 상태를 저장할 수 있다면, 프로그램을 일시 중지했다가도 해당 정보를 이용해 다시 실행을 이어갈 수 있다. 이러한 프로그램 실행 상태를 저장하고 복구할 수 있도록 설계된 구조체를 프로세스라고 한다. 모든 프로그램은 자신만의 프로세스를 가져야 하며, 이를 통해 프로그램은 중지와 재개를 자유롭게 할 수 있다.

이러한 복잡한 과정을 자동화하는 역할을 하는 것이 바로 운영체제이다. 운영체제는 프로그램을 자동으로 메모리에 적재해주고, CPU가 여러 프로그램을 번갈아 실행하도록 관리함으로써 멀티태스킹을 실현한다. 운영체제가 등장하면서 프로그래머는 더 이상 프로그램을 수동으로 적재하거나 상태를 관리할 필요가 없어졌으며, 이로 인해 운영체제는 재사용성이라는 개념에 가장 잘 어울리는 시스템이 되었다. 운영체제는 이러한 모든 과정을 사용자 모르게 백그라운드에서 수행하며, 컴퓨터가 효율적으로 동작하도록 돕는 핵심 요소이다.

### 프로세스의 불편함

![image.png](attachment:a6f7deeb-99e6-426e-9987-ef2d867addc8:image.png)

프로세스 주소 공간은 다음과 같다.

- **코드 영역** : 코드를 컴파일하여 생성된 기계 명령어가 저장된다.
- **데이터 영역** : 전역 변수 등이 저장된다.
- **힙 영역** : malloc 함수가 요청을 반환한 메모리가 여기에 저장된다.
- **스택 영역** : 함수의 실행시간 스택이다.

만약 `funcA`와 `funcB`라는 두 함수를 호출하는 프로그램이 있다고 가정하면, `funcA`의 결과를 얻은 후 `funcB`의 결과를 얻어 두 값을 더하는 방식으로 실행할 수 있다. 이 두 함수는 서로 독립적이므로 각각을 별도의 프로세스로 실행할 수 있다. 하지만 이러한 방식은 한 프로세스의 결과를 다른 프로세스로 전달해야 하며, 이 과정에서 프로세스 간 통신 문제가 발생할 수 있다.

이러한 **다중 프로세스 프로그래밍** 방식은 다음과 같은 두 가지 문제가 있다.

1. 프로세스를 생성할 때 비교적 큰 부담이 든다.
2. 프로세스마다 자체적인 주소공간을 가지고 있기 때문에 프로세스 간 통신은 프로그래밍하기에 더 복잡하다.

### 프로세스에서 스레드로 진화

프로세스의 단점은 한 프로세스에 `main` 함수만 존재하여 해당 프로세스의 명령어가 한 번에 하나의 CPU에서만 실행될 수 있다는 점이다. 그러나 PC 레지스터는 `main` 함수뿐만 아니라 다른 함수의 주소를 가리킬 수도 있다. 이렇게 하면 새로운 실행 흐름을 만들어낼 수 있다. 이 새로운 흐름은 동일한 프로세스 주소 공간을 공유하기 때문에, 더 이상 프로세스 간 통신이 필요하지 않다.

한 프로세스 내에는 진입 함수가 두 개 이상 있을 수 있으며, 이로 인해 하나의 프로세스 내에서 여러 CPU가 동시에 실행할 수 있게 된다. 이러한 실행 흐름을 **스레드**라고 부른다.

스레드는 프로세스의 주소 공간을 공유하므로, 프로세스 간 통신처럼 서로 다른 주소 공간을 넘나드는 복잡한 작업 없이도 데이터를 공유할 수 있다. 이러한 특성 덕분에 스레드는 프로세스보다 가볍고 생성 속도가 빠르다. 그래서 스레드는 종종 **경량 프로세스**라고도 불린다.

### 다중 스레드와 메모리 구조

CPU의 PC 레지스터에 스레드의 진입 함수 주소를 지정하면 스레드를 실행시킬 수 있다. 이것이 바로 스레드를 생성할 때 진입 함수를 반드시 지정해야 하는 이유이다.

함수가 실행될 때 필요한 정보에는 함수의 매개변수, 지역 변수, 반환 주소 등이 있다. 이런 정보들은 대응하는 스택 프레임에 저장되며, 모든 함수는 실행 시 자신만의 실행 시간 스택 프레임을 가진다. 함수가 호출되고 반환될 때마다 이 스택 프레임은 후입선출 순서로 증가하거나 감소하며, 이런 스택 프레임의 증가는 프로세스 주소 공간에서 스택 영역을 형성한다.

모든 스레드는 각자 자신만의 스택 영역을 가지는데, 스레드가 이를 인지하고 있는 것이 매우 중요하다.

### 스레드 풀의 동작방식

**스레드 풀**이란 여러 개의 스레드를 미리 생성해 두고, 스레드가 처리할 작업이 생기면 해당 스레드에 처리를 요청하는 방식이다. 스레드 여러 개가 미리 생성되어 있기 때문에 스레드의 생성과 종료 작업이 빈번하게 발생하지 않으며, 동시에 스레드 풀 내에 있는 스레드 수도 일반적으로 일정하게 관리되기 때문에 불필요하게 많은 메모리를 소비하지 않는다.

스레드 풀에 전달되는 작업은 1. 처리할 데이터와 2. 데이터를 처리하는 함수 두 부분으로 구성되며, 이는 다음과 같이 정의할 수 있다:

```c
struct task {
    void* data;         // 작업이 처리할 데이터
    handler handle;     // 데이터 처리 함수
}
```

먼저 스레드 풀의 스레드는 작업 대기열(jobs queue)에서 블로킹 상태로 대기한다. 생산자가 작업 대기열에 데이터를 기록하면, 스레드 풀의 스레드가 깨어나고, 깨어난 스레드는 작업 대기열에서 앞서 정의한 구조체를 가져온 후, 구조체의 `handle`이 가리키는 처리 함수(handler function)를 실행한다.

```c
while (true) {
    struct task *task = getFromQueue();  // 작업 대기열에서 데이터 꺼내기
    task->handle(task->data);            // 데이터 처리
}
```

### 스레드 풀의 스레드 수

스레드 풀에서 처리할 작업은 **CPU 집약적인 작업**과 **입출력 집약적인 작업**으로 구분할 수 있다.

**CPU 집약적인 작업**이란 과학 연산, 행렬 연산 등 외부 입출력에 의존하지 않고 처리할 수 있는 작업을 의미한다. 이 경우, 스레드 수와 CPU 코어 수가 기본적으로 동일하다면 CPU의 리소스를 충분히 활용할 수 있다.

**입출력 집약적인 작업**이란 연산 부분이 차지하는 시간은 많지 않지만, 대부분의 시간을 디스크 입출력이나 네트워크 입출력 등에 소비하는 작업을 의미한다.

스레드 수를 결정하는 절대 공식은 없으며, 이를 위해서는 구체적인 상황과 그에 대한 분석이 필요하다.

## 2. 스레드 간 공유되는 프로세스 리소스

### 스레드 전용 리소스

CPU는 하나의 진입 함수의 명령어를 실행하여 실행 흐름인 스레드를 형성한다. 이때 각 스레드는 자신만 사용할 수 있는 스택 영역을 가지므로, 스레드 여러 개가 있을 때는 여러 스택 영역이 존재하게 된다. 이 외에도 PC(프로그램 카운터) 레지스터, 스택 포인터 등 내부 레지스터 값도 스레드 전용이다. 스레드에 속한 스택 영역, PC, 스택 포인터, 함수 실행 시 사용되는 레지스터 정보가 모두 해당 스레드 전용이며, 이 모든 정보를 통틀어  **스레드 상황 정보**(Thread context)라고 한다.

앞서 설명한 전용 리소스를 제외한 모든 리소스는 모두 스레드 간에 공유되는 리소스에 해당한다.

### 코드 영역

**코드 영역**은 스레드 간에 공유되므로, 어떤 함수든지 모두 스레드에 의해 실행될 수 있고, 특정 함수를 특정 스레드에서만 실행되도록 하는 것은 불가능하다. 이런 관점에서 코드 영역은 모든 스레드가 공유하는 영역이다.

코드 영역은 **읽기 전용**이기 때문에 프로그램이 실행되는 동안에는 어떤 스레드도 코드 영역 내용을 변경할 수 없다. 따라서 프로세스 내 모든 스레드가 코드 영역을 공유하고 있지만, 코드 영역에 관해서는 스레드 안전 문제가 발생하지 않는다.

### 데이터 영역

**데이터 영역**은 전역 변수가 저장되는 곳이다. 전역 변수는 프로세스의 주소 공간의 데이터 영역에 저장된다. 프로그램이 실행되는 동안 데이터 영역 내에 전역 변수의 인스턴스는 하나만 있기 때문에, 모든 스레드는 이 전역 변수에 접근할 수 있다.

### 힙 영역

**힙 영역**은 `malloc` 함수와 `new` 예약어로 요청하는 메모리가 이 영역에 할당된다. 모든 스레드는 해당 변수의 주소만 알고 있다면, 즉 포인터를 얻을 수 있다면 포인터가 가리키는 데이터에 접근할 수 있다. 따라서 힙 영역은 스레드 간 공유 리소스이기도 하다.

### 스택 영역

서로 다른 프로세스의 주소 공간은 서로 격리되어 있으며, 가상 메모리 시스템은 매유 특별한 경우를 제외하고 다른 프로세스의 주소 공간에 속한 데이터에 직접 접근하지 못하도록 보장한다. 따라서 하나의 스레드가 다른 스레드의 스택 프레임에서 포인터를 가질 수 있다면, 해당 스레드는 다른 스레드의 스택 영역을 직접 읽고 쓸 수 있다.

스레드 여러 개가 하나의 프로세스에 속하는 경우에는 하나의 스레드가 다른 스레드의 스택 영역이라고 하더라도 모두 데이터를 읽고 쓸 수 있다. 스레드 간 느슨한 격리 작동 방식은 프로그래머 입장에서 편리하기도 하지만, 반대로 수맘ㄶ은 문제를 일으킬 가능성이 있다.

### 동적 링크 라이브러리와 파일

데이터와 코드는 스택영역와 힙 영역 중간에 있는 여유공간에 배치하게 된다. 주소공간에서 이 부분은 모든 스레드가 공유하고 있다. 즉 프로세스 내 모든 스레드가 동적 라이브러리 코드의 데이터를 사용할 수 있다는 의미이다. 또한 프로세스가 연 파일 정보는 모든 스레드에서 사용할 수 있으며, 이것 역시 스레드 간 공유 리소스에 속한다.

### 스레드 전영 저장소

스레드 전용저장소에 저장되는 변수는 다음과 같은 의미가 있다.

- 이 영역에 저장된 변수는 모든 스레드에서 저근할 수 있다.
- 모든 스레드가 동일한 변수에 접근하는 거서럼 보일 수 있지만, 사실 변수으 인스턴스는 각각의 스레드에 속한다.

스레드 전용 저장소를 사용하면 각각의 스레드에서 독점적으로 변수를 사용할 수 있다. 즉 이 변수들은 모든 스레드에서 접근할 수 있지만, 해당 변수는 초기화한 후 각각의 스레드가 복사본을 가지게 되며, 하나의 스레드에서 변수 값을 변경하더라도 다른 스레드에는 영향을 미치지 않는다.

## 3. 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

### 스레드 안전

코드가 스레드 몇 개에서 호출되든 이 스레드들이 어떤 순서로 호출되든 간에 상관없이 올바른 결과가 나온다면, 이 코드를 **스레드 안전**이라고 말한다.

### 스레드 전용 리소스와 공유 리소스

함수의 지역 변수, 스레드의 스택 영역, 스레드 전용 저장소는 스레드 전용 리소스이며, 그 외의 영역은 공유 리소스로 다음과 같이 구성된다.

- **힙 영역** : 메모리의 동적 할당에 사용되는 영역으로, malloc함수와 new 예약어가 요청하는 메모리는 이 영역에 할당된다.
- **데이터 영역** : 전역변수가 저장되는 영역이다.
- **코드 영역** : 이 영역은 읽기 전용으로, 프로그램이 실행되는 동안은 코드를 수정할 수 없다.

따라서 스레드 **공유 리소스는 주로 힙 영역과 데이터 영역**으로 구성된다. 이런 공유 리소스를 사용하는 스레드는 반드시 순서를 따라야 하며, 이 순서 핵심은 공유 리소스를 사용하는 작업이 다른 스레드를 방해할 수 없다는 것이다. 그리고 이를 위해 각종 **잠금**(lock)이나 **세마포어**(semaphore) 같은 장치를 사용할 수 있다. 이 규칙의 목적은 공유 리소스 순서를 유지하는 것이다.

### 스레드 전용 리소스만 사용하기

전역 변수나 매개변수에 의존하지 않고 스레드 전용 리소스인 지역 변수만 사용하는 함수는, 이 변수는 실행된 수 스레드의 스택 영역에서 관리된다. 이런 코드를 **무상태 함수**(Stateless function)라고 하며, 이런 코드가 스레드 안전하다는 것은 분명하다.

### 스레드 전용 리소스와 함수 매개변수

스레드 두 개가 `func` 함수를 호출할 때 전달하는 포인터가 힙 영역에 저장된 동일한 변수를 가리키고 있다면, 해당 변수는 이 두 스레드가 공유하는 리소스로 간주된다. 따라서 잠금 등으로 보호되지 않는 한 `func` 함수는 여전히 스레드 안전하지 않다.

이를 개선하려면, 모든 스레드가 `func` 함수를 호출할 때 해당 스레드에 속하는 리소스를 전달하면, 각 스레드는 다른 스레드를 방해하지 않게 된다. 따라서 스레드 안전인 코드를 작성하는 원칙 중 하나는 스레드 간에 공유 리소스를 사용하지 않도록 가능한 한 모든 조치를 취하는 것이다.

### 스레드 전용 리소스와 함수 매개변수

```c
int global_num = 100; //한 번 초기화되면 이후 코드는 값을 변경하지 않음

int func() {
	return global_num;
}
```

`func` 함수가 전역 변수를 사용하고 있지만, 해당 변수는 함수가 실행되기 전에 한 번 초기화되면 이후 실행되는 어떤 코드로도 그 값을 변경할 수 없기 때문에 `func` 함수는 스레드 안전하다. 여기서 `func` 함수를 수정하면, 이 함수는 더 이상 스레드 안전하지 않다. 전역 변수의 변경 과정은 반드시 잠금 등의 보호 또는 덧셈 작업을 원자성(atomic) 작업으로 설정하여 보호해야 한다.

### 스레드 전용 저장소

```c
__thread global_num = 100; //한 번 초기화되면 이후 코드는 값을 변경하지 않음

int func() {
	++gloabal_num;
	
	return global_num;
}
```

`__thread` 수식어가 붙은 변수는 스레드 전용 저장소에 배치된다. 이제 각 스레드에서 전역변수의 값을 수정해도 다른 스레드에 영향을 미치지 않기 때문에 `func` 함수는 스레드 안전이다.

### 스레드 안전이 아닌 코드 호출하기

```c
int funcA() {
	mutex 1;
	
	l.lock();
	func();
	l.unlock();
}
```

함수를 호출하기 전에 잠금으로 보호하면 `funcA` 함수는 스레드 안전이다. 잠금으로 전역변수를 간접적으로 보호하기 때문이다.

```c
int func(int *num) {
	+++(*num);
	
	return *num;
}
```

```c
void funcA()
{
	int a = 100;
	int b = func(&a);
}
```

이 경우에도 전달된 매개변수가 스레드 전용 리스스인 지역변수이기 때문에 funcA 함수를 호출하는 스레드가 몇 개든 서로 간섭하지 않는다.

### 스레드 안전 코드 구현

- **스레드 전용 저장소(thread local storage)**: 각 스레드가 독립적인 데이터를 저장할 수 있는 공간을 제공하여, 다른 스레드와의 충돌 없이 데이터를 안전하게 관리할 수 있다.
- **읽기 전용(read-only)**: 데이터가 변경되지 않도록 보장되어, 여러 스레드가 동시에 읽어도 데이터의 일관성이 유지된다.
- **원자성 연산(atomic operation)**: 연산이 중단되거나 다른 스레드에 의해 간섭받지 않고 완전하게 실행되도록 보장하는 방식으로, 동시성 문제를 예방한다.
- **동기화 시 상호 배제(mutual exclusion in synchronization)**: 동시에 여러 스레드가 공유 자원에 접근하지 못하도록 잠금(lock) 등을 사용하여 한 번에 하나의 스레드만 자원에 접근할 수 있도록 제한한다.

## 4. 프로그래머는 코루틴을 어떻게 이해해야 할까?

### 코루틴과 일반함수

운영체제에 의존하지 않고 직접 스레드를 구현하려면, 더 가벼운 실행 흐름인 **코루틴**을 사용할 수 있다.

코루틴은 일반 함수와 달리 자신이 마지막으로 실행된 위치를 기억할 수 있으며, 일시 중지된 상태를 저장하고 다시 시작하여 계속 실행된다.

컴퓨터 시스템은 주기적으로 타이머 인터럽트를 발생시키고, 인터럽트 처리 시 운영체제는 현재 스레드의 일시 중지 여부를 결정할 기회를 가진다. 이렇게 프로그래머는 명시적으로 스레드를 언제 일시 중지하고 CPU 리소스를 내어줄지 지정할 필요가 없다. 그러나 사용자 상태에서는 타이머 인터럽트가 없기 때문에, 코루틴에서 `yield`와 같은 예약어를 사용하여 명시적으로 일시 중지를 지정해야 한다.

### 코루틴의 구현

코루틴의 스택 영역은 모두 힙 영역에 배치되며, 이를 통해 우리는 코루틴을 수시로 일시 중지하거나 재개할 수 있다.

스택 영역은 여전히 함수 스택 프레임을 보관하는 데 사용되지만, 일반 함수와의 차이는 함수들이 코루틴이라는 점이다.

이론적으로 메모리 공간이 충분하다면 코루틴의 개수에 제한이 없으며, 코루틴 간 전환이나 스케줄링은 전적으로 사용자 상태에서 이루어지므로 운영체제가 개입할 필요가 없다. 또 코루틴 간에 전환할 때 저장 또는 복구되는 정보도 더 가볍기 때문에 효울성도 훨씬 높다.