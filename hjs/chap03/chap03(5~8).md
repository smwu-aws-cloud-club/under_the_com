# 4. 힙 영역 : 메모리의 동적 할당은 어떻게 구현될까?

모든 함수는 고유한 스택 프레임을 가지며, 이 프레임에는 반환 주소, 지역 변수, 매개변수, 사용 중인 레지스터 등의 정보가 저장된다. 스택 프레임은 스택 영역에 위치하며, 함수 호출이 중첩될수록 스택 영역의 메모리 사용량이 증가하게 된다. 반대로 함수 호출이 종료되면 해당 스택 프레임은 더 이상 유효하지 않으며, 이에 따라 스택 영역의 사용 메모리는 감소하게 된다.

프로그래머는 이와 같은 스택 프레임의 특성을 고려하여 다음과 같은 사항에 주의해야 한다.

1. 함수 A가 함수 B를 호출한 경우, 함수 B의 실행이 완료되면 B의 스택 프레임에 저장된 내용은 무효화된다. 따라서 프로그래머는 무효화된 스택 프레임의 정보를 참조해서는 안 된다.

   예를 들어, 함수 B가 자신의 지역 변수에 대한 포인터를 반환할 경우, 해당 포인터는 이미 해제된 메모리를 가리키게 되므로 이는 잘못된 동작을 유발할 수 있다.

2. 지역 변수의 생명 주기는 해당 함수의 실행 주기와 일치한다. 이로 인해 지역 변수는 함수가 실행되는 동안에만 유효하며, 함수가 종료되면 자동으로 해제된다. 이러한 특성은 프로그래머가 지역 변수에 대한 메모리 할당과 반환을 직접 관리할 필요가 없게 만들어주는 장점을 가진다.

   그러나 지역 변수는 함수 외부에서 사용할 수 없다는 단점을 가진다. 함수가 종료된 후 해당 지역 변수가 저장된 메모리는 더 이상 유효하지 않기 때문이다. 이는 곧 지역 변수는 프로그래머가 직접 관리하는 대상이 아니라는 것을 의미한다.

   다만, 함수 A가 함수 B를 호출하고 있는 중이라면, 함수 A의 스택 프레임은 여전히 유효한 상태이므로 함수 B가 함수 A의 지역 변수를 사용하는 것이 가능하다. 즉, 지역 변수를 사용하는 시점에 해당 변수가 위치한 스택 프레임이 유효하다면, 함수 외부에서 해당 지역 변수를 사용하는 데 문제가 발생하지 않는다.


## 3.4.1 힙 영역이 필요한 이유

특정 데이터를 여러 함수에 걸쳐 사용해야 하는 경우, 프로그래머는 해당 데이터를 직접 관리할 수 있는 특정 메모리 영역에 저장해야 하며, 이와 관련된 사항을 스스로 결정해야 한다. 이 메모리는 함수의 호출 횟수와는 무관하게, 프로그래머가 해당 메모리의 사용이 완전히 종료되었다고 판단할 때까지 유효하게 유지된다. 이후 이 메모리는 더 이상 사용되지 않으며, 이러한 과정을 동적 메모리의 할당과 해제라고 한다.

이러한 이유로 메모리의 수명 주기를 유연하게 관리하려면, 프로그래머가 직접 제어할 수 있는 넓은 메모리 공간이 필요하며, 이 영역을 **힙 영역(heap segment)**이라고 한다.

C 또는 C++ 언어에서는 `malloc` 함수나 `new` 연산자를 사용하여 힙 영역에 메모리를 할당하고, `free` 함수나 `delete` 연산자를 사용하여 해당 메모리를 반환한다.

## 3.4.2 malloc 메모리 할당자 직접 구형하기

메모리 할당자 입장에서는 적절한 크기의 메모리 영역을 제공하기만 하면 되고, 할당자는 그 메모리 영역에 무엇을 저장할지는 신경쓰지 않는다. 어떤 구조의 데이터도 모두 저장할 수 있다.

힙 영역 위에서 해결할 두 가지 문제가 있다.

- malloc 함수를 구현한다. 이 함수는 누군가 나에게 메모리 영역을 요청하면 힙 영역에서 가능한 메모리 영역을 찾아 요청자에게 반환하는 과정을 구현하는 것이다.
- free 함수를 구현한다. 이 함수는 메모리 영역의 사용이 완료되었을 때 힙 영역에 이 메모리 영역을 반환하는 방법을 구현하는 것이다.

## 3.4.3. 주차장에서 메모리 관리까지

메모리는 매우 긴 주차장으로 간주할 수 있다.  메모리는 요청하는 것은 입차를 위해 주차 공간을 찾는 것이며, 메모리를 반환하는 것은 주차 공간을 확부하기 위해 출차를 시키는 것이다.

요청하는 메모리 크기가 일정하지 않을때, 다음 두 가지 목표를 달성해야 한다.

- 주차할 위치를 빠르게 찾는다. 여기에는 요청된 크기를 만족하는 여유 메모리를 최대한 빨리 찾는다는 조건이 포함된다.
- 주차장 사용률을 극대화하고자 주차장에 가능한 한 많은 차량을 주차할 수 있어야 한다. 메모리를 요청할 때는 정해진 메모리 한도 내에서 가능한 한 많은 메모리 할당 요청을 만족시켜야 한다.

## 3.4.4 여유 메모리 조각 관리하기

사용 가능한 메모리 조각을 관리하는 작업의 특성상, 어떤 영역이 사용 가능한 메모리인지, 어떤 영역이 이미 할당된 메모리인지 구분할 수 있는 방법이 필요하다.

이러한 문제를 해결하기 위한 대표적인 방법 중 하나는 **연결 리스트(linked list)**를 사용하는 것이다. 연결 리스트를 이용하면 모든 메모리 조각을 순차적으로 관리할 수 있으며, 각 조각이 사용 중인지 아닌지에 대한 정보를 함께 기록하기 용이하다.

그러나 연결 리스트를 사용하기 위해서는 먼저 리스트를 구성할 메모리가 필요하다. 이는 다시 말해, 메모리를 할당해야 리스트를 생성할 수 있다는 뜻이며, 메모리를 할당하려면 결국 메모리 할당자를 사용해야 한다.

따라서 연결 리스트와 메모리 상태 정보를 메모리 조각 자체에 함께 저장해야 한다. 여기서 말하는 ‘**메모리 조각**’이란, 할당되었거나 해제된 하나의 메모리 블록 전체를 의미한다. 이 방식에서는 연결 리스트의 ‘다음 노드 포인터’가 따로 존재하지 않지만, 메모리 조각 내부의 정보를 통해 다음 노드의 위치를 유추할 수 있다.

이를 위해 각 메모리 조각에 다음 두 가지 정보를 함께 저장한다.

- 해당 메모리 조각이 **비어 있는지 여부**를 나타내는 설정값(flag)
- 해당 메모리 조각의 **크기**를 나타내는 숫자

예를 들어, 메모리 조각의 최대 크기를 2GB로 가정할 경우, 32비트 중 31비트를 조각의 크기를 저장하는 데 사용하고, 나머지 1비트를 해당 조각이 할당 상태인지 아닌지를 나타내는 플래그로 사용할 수 있다. 이 32비트 정보는 **헤더(header)**라고 하며, 메모리 조각의 상태 정보를 담는 데 사용된다.

또한 사용자에게 실제로 할당되는 영역, 즉 데이터를 저장할 수 있는 메모리 부분을 **페이로드(payload)**라고 한다. `malloc` 함수를 호출하면 반환되는 포인터는 이 페이로드 영역의 시작 주소를 가리키게 된다.

결과적으로, 메모리 조각의 헤더 크기는 항상 32비트(4바이트)로 고정되며, 각 조각의 전체 크기는 이 헤더 정보로부터 확인할 수 있다. 따라서 만약 현재 조각의 **헤더 주소**를 알고 있다면, 해당 주소에 조각 크기를 더함으로써 다음 조각의 시작 주소를 계산할 수 있다.

## 3.4.5 메모리 할당 상태 추적하기

메모리의 할당과 해제를 효율적으로 처리하기 위해 힙 영역을 구조화할 수 있다. 힙 영역은 4바이트 단위의 작은 조각들로 구성되며, 이 조각들은 할당된 메모리 또는 여유 메모리를 나타낸다.

연결 리스트와 유사하게, 메모리 할당자에도 힙의 끝을 식별할 수 있는 특수한 표시가 필요하며, 이를 위해 힙 영역의 마지막 4바이트를 사용한다.

이러한 구조는 헤더 정보를 도입한 설계 방식으로, 전체 힙 영역의 상태를 효율적으로 추적할 수 있게 한다. 각 메모리 조각의 헤더에는 해당 조각의 크기와 함께 마지막 1비트를 이용해 그 조각이 여유 상태인지, 혹은 이미 할당되었는지를 표시한다. 이를 통해 메모리 할당자는 전체 힙 영역을 쉽게 추적하고, 각 조각의 상태를 쉽게 판단할 수 있다.

## 3.4.6 어떻게 여유 메모리 조각을 선택할 것인가 : 할당 전략

### 최초 적합 방식

최초 적합 방식은 메모리를 할당할 때마다 항상 힙의 처음부터 탐색을 시작하여, 가장 먼저 조건을 만족하는 여유 메모리 조각을 선택하여 할당하는 방식이다. 구현이 단순하다는 장점이 있지만, 항상 처음부터 탐색을 반복하므로 힙의 앞부분에 작은 크기의 여유 메모리 조각이 많이 남을 가능성이 크다. 이로 인해 시간이 지날수록 단편화(fragmentation)가 심해지고, 이후 메모리 할당 시 더 많은 조각을 탐색해야 하는 비효율이 발생할 수 있다.

### 다음 적합 방식

다음 적합 방식은 최초 적합 방식과 유사하지만, 매번 처음부터 탐색하지 않고 이전에 탐색을 마친 위치에서부터 탐색을 재개하는 방식이다. 이론적으로는 최초 적합 방식보다 탐색 시간이 더 짧을 수 있다. 그러나 메모리의 사용 효율성 면에서는 최초 적합 방식보다 떨어지는 것으로 알려져 있다. 이는 여유 메모리 조각이 힙 전체에 고르게 분포되지 않고 특정 구간에 몰릴 수 있기 때문이다.

### 최적 적합 방식

최적 적합 방식은 사용 가능한 모든 여유 메모리 조각을 탐색한 뒤, 그중에서 요청한 크기 이상이면서 가장 작은 크기의 조각을 선택하여 할당하는 방식이다.

이 방식은 메모리 공간을 보다 효율적으로 활용할 수 있다는 장점이 있으나, 모든 여유 메모리 조각을 비교해야 하므로 실행 속도가 느릴 수 있다는 단점이 있다. 특히 조각이 많아질수록 탐색 시간이 크게 증가한다.

## 3.4.7 메모리 할당하기

메모리를 할당하려면, 먼저 해당 메모리 조각을 할당된 상태로 표시하고, 그 조각의 헤더 정보 다음에 이어지는 실제 메모리 영역의 주소를 요청자에게 반환해야 한다. 이때, 헤더 정보를 포함한 메모리 영역 전체를 요청자에게 넘겨서는 안 된다. 헤더 정보가 손상되면 메모리 할당자가 올바르게 작동하지 못하게 되기 때문이다.

하지만 찾은 메모리 조각이 요청한 크기보다 훨씬 클 경우, 전체를 그대로 할당하면 속도는 빠르지만 남는 메모리 공간이 낭비된다. 이러한 현상을 **내부 단편화**라고 하며, 이로 인해 남은 공간을 다른 용도로 사용할 수 없게 된다.

이 문제를 해결하기 위해, 여유 메모리 조각을 두 개로 분할하여 앞부분은 요청자에게 할당하고, 뒷부분은 더 작은 새로운 여유 메모리 조각으로 만들어 힙 내에 남겨둔다. 이렇게 하면 메모리의 효율적인 사용이 가능하고, 내부 단편화를 줄일 수 있다.

## 3.4.8 메모리 해제하기

메모리를 해제하는 작업 자체는 비교적 간단하다. 사용자가 메모리를 요청할 때 받은 주소를 `ADDR`이라고 가정하면, 메모리를 해제할 때는 `free`와 같은 해제 함수에 이 주소만 전달하면 된다. 예를 들어 `free(ADDR)`처럼 호출하면, `free` 함수는 전달받은 주소에서 헤더 정보 크기(4바이트)를 뺀 위치를 계산하여 해당 메모리 조각의 헤더에 접근할 수 있다. 그 후, 헤더에 저장된 할당 상태를 '여유 상태'로 변경함으로써 해제가 완료된다.

하지만 메모리를 해제할 때,  해제되는 메모리 조각과 인접한 조각이 이미 여유 메모리 상태인 경우, 단순히 해제 여부만 기록할 경우 문제가 생길 수 있다. 예를 들어, 인접한 두 조각 각각은 새로운 메모리 요청을 만족하지 못하지만, 이 둘을 합치면 요청을 만족할 수 있는 크기가 된다면, 이를 미리 병합하지 않았을 경우 새로운 요청을 처리할 수 없게 된다.

따라서 인접한 여유 메모리 조각이 있을 때는, 해제되는 조각과 병합하여 더 큰 여유 메모리 조각을 만드는 것이 바람직하다. 이를 **메모리 병합(coalescing**)이라고 한다.

병합을 메모리가 해제되는 즉시 수행하는 전략은 구현이 간단하지만 단점도 존재한다. 메모리 사용 패턴에 따라 병합이 불필요한 경우가 많기 때문에, 즉시 병합 방식은 성능 저하를 초래할 수 있다. 이 때문에 많은 메모리 할당자들은 여유 메모리 조각의 병합을 ****즉시 수행하지 않고, 필요할 때까지 연기하는 전략을 사용한다.

## 3.4.9 여유 메모리 조각을 효율적으로 병합하기

앞에 위치한 메모리 조각이 비어 있는지 여부를 효율적으로 확인하는 방법이 있다. 각 메모리 조각은 이미 헤더 정보를 포함하고 있는데, 이와 유사하게 **푸터 정보(footer)**를 추가하면 앞 조각의 상태도 쉽게 파악할 수 있다.

푸터 정보는 메모리 조각의 마지막 부분에 위치하며, 헤더와 동일하게 해당 조각의 크기와 상태를 저장한다. 이 구조의 장점은, 현재 조각의 헤더 주소에서 4바이트를 빼면 바로 앞에 위치한 조각의 푸터에 접근할 수 있다는 점이다. 이를 통해 메모리를 해제할 때, 인접한 이전 조각이 여유 상태인지 빠르게 확인하고 병합할 수 있다.

이처럼 메모리 조각에 헤더와 푸터를 모두 두는 방식은 각 조각이 양방향 정보를 가지게 되어, 마치 **양방향 연결 리스트(doubly linked list)**처럼 작동한다. 이러한 구조를 통해 메모리 할당자 입장에서 더 효율적인 조각 추적 및 병합이 가능해진다.

# 3.5 메모리를 할당할 떄 저수준 계층에서 일어나는 일

## 3.5.1 천지인과 CPU 실행 상태

x86 CPU는 네 가지 특권 단계를 제공한다. 0, 1, 2, 3이라는 숫자는 CPU의 여러 가지 동작 상태를 나타내며, 숫자가 작을수록 CPU의 특권은 커진다. 여기에서 특권은 특정 명령어를 실행할 수 있는 권한을 의미하며, 일부 기계 명령어는 CPU가 가장 높은 특권 상태일 때만 실행 가능하다.

- **특권 0**: 특권이 가장 크며, 모든 기계 명령어를 실행할 수 있다. 주로 **커널 모드(Kernel Mode)**에서 사용된다.
- **특권 3**: 특권이 가장 낮으며, 사용자 프로그램이 실행되는 **사용자 모드(User Mode)**에서 사용된다.

일반적으로 시스템은 특권 0과 특권 3만 사용하며, 특권 3은 사용자 상태, 특권 0은 커널 상태를 나타낸다.

## 3.5.2 커널 상태와 사용자 상태

CPU는 운영체제의 코드를 실행할 때 커널 상태(Kernel Mode)에 놓인다. 이 상태에서는 CPU가 모든 기계 명령어를 실행할 수 있으며, 전체 주소 공간에 접근 가능하고, 제한 없이 하드웨어 자원에도 접근할 수 있다.

반면, 프로그래머가 작성한 일반적인 코드를 실행할 때는 사용자 상태(User Mode)에 해당한다. 사용자 상태의 코드는 여러 제약을 받으며, 특히 특정 주소 공간에 접근할 수 없다. 이러한 제한이 없으면 세그멘테이션 오류(segmentation fault)가 발생한다. 또한 CPU가 사용자 상태일 때는 특권 명령어를 실행할 수 없다는 제한도 있다.

일반적인 응용 프로그램은 모두 사용자 상태에서 실행된다.

## 3.5.3 포털 : 시스템 호출

응용 프로그램이 파일 읽기, 쓰기, 네트워크 통신 등 운영체제의 기능을 사용할 때는 직접 처리하지 않고 운영체제에 요청한다. 이때 사용하는 메커니즘을 **시스템 호출(system call)**이라고 한다.

프로그래머는 시스템 호출을 통해 운영체제에 서비스를 요청하고, 운영체제는 해당 요청을 처리하여 결과를 응용 프로그램에 반환한다. 예를 들어, 파일 읽기나 쓰기, 네트워크 데이터 송수신 같은 작업을 운영체제가 대신 수행한다.

시스템 호출은 특정한 기계 명령어를 통해 이루어진다. 이 명령어가 실행되면 CPU는 사용자 상태에서 커널 상태로 전환되어 운영체제의 코드를 실행하게 된다.

이러한 구조에서 보면, 응용 프로그램(프로세스)은 요청을 보내는 **클라이언트**, 운영체제는 이를 처리하는 **서버**, 시스템 호출은 **네트워크 요청**에 해당한다고 볼 수 있다.

## 3.5.4 표준 라이브러리: 시스템의 차이를 감춘다

사용자에게 저수준 계층 간의 차이를 감추기 위한 표준이 필요하다. 이 표준 덕분에 프로그래머가 작성한 프로그램을 별도의 수정 없이 다양한 운영체제에서 실행할 수 있다. C 언어에서는 이 역할을 **표준 라이브러리(standard library)**가 수행한다.

표준 라이브러리는 사용자 상태에서 실행되는 코드로 구성되어 있다. 일반적으로 프로그래머는 표준 라이브러리를 호출해 파일 입출력이나 네트워크 통신을 수행하며, 표준 라이브러리는 실행 중인 운영체제에 맞는 시스템 호출을 내부적으로 선택하여 사용한다.

고수준 계층에는 응용 프로그램이 있고, 응용 프로그램은 표준 라이브러리만을 의사소통 대상으로 간주한다. 표준 라이브러리는 시스템 호출을 통해 운영체제와 소통하며, 운영체제는 저수준 하드웨어를 관리한다.

예를 들어, malloc 같은 메모리 할당자는 운영체제의 일부가 아니라 표준 라이브러리의 일부로 구성된다.

## 3.5.5 힙 영역의 메모리가 부족할 때

힙 영역과 스택 영역 사이에는 여유 공간이 존재한다. 스택 영역은 함수 호출이 깊어질수록 아래쪽으로 메모리 공간을 점유하며, 힙 영역은 메모리 할당이 증가하면 위쪽으로 확장된다.

힙 영역이 확장되면 사용할 수 있는 메모리 조각이 늘어나 메모리 부족 문제를 완화할 수 있다. `malloc` 함수는 할당할 메모리가 부족할 경우 운영체제에 메모리를 요청하게 된다.

리눅스에서는 모든 프로세스에 `brk`라는 변수가 존재하며, 이 변수는 힙 영역의 최상단을 가리킨다. 힙을 확장하기 위해서는 `brk` 값을 위로 이동시켜야 하고, 이 작업은 시스템 호출을 통해 수행된다.

## 3.5.6 운영체제에 메모리 요청하기: brk

이제 메모리 할당이 더 이상 사용자 상태의 힙 영역에만 국한되지 않기에 메모리 할당 단계가 다음과 같이 달라진다.

1. 프로그램은 `malloc`을 호추하여 메모리 할당을 욫어한다.
2. `malloc`은 여유 메모리 조각을 검색하기 시작하고, 적절한 크기의 조각을 찾으면 이를 할당한다. 이 단계까지는 사용자 상태에서 처리된다.
3. `malloc`이 여유 메모리 조각을 찾지 못하면 `brk` 시스템 호출을 통해 운영체제에 힙 영역을 늘려주라고 요청한다. 힙 영역이 늘어나면 `malloc`이 다시 한 번 적절한 여유 메모리 조각을 찾앙서 할당할 수 있다.

## 3.5.7 빙산의 일각: 가상 메모리가 최종보스다

프로세스 입장에서 사용하는 메모리는 모두 가상이며 운영체제가 프로세스에 보여주는 환상, 가상메모리이다. 이 단계는 사실 논리적인 것에 불과하며 실제 물리 메모리 안에는 애초에 이런 구조가 존재하지 않는디.

실제 물리 메모리는, 실제로 할당한 메모리가 사용되는 순간에 물리 메모리를 할당하게 된다. 이때 가상 메모리가 아직 실제 물리 메모리와 연결되어 있지 않으면 내부적으로 **페이지 누락 오류(Page fault)**가 발생한다. 운영체제가 이 오류를 감지하면 페이지 테이블을 수정하여 가상메모리와 실제 물리 메모리의 사상관계를 설정하며, 이것으로 실제 물리 메모리가 할당한다.

이 과정이 완료되면 프로그램에서 할당받은 메모리를 사용할 수 있으며 프로그래머 입장에는 마치 메모리가 할당되어 있는 것 처럼 보인다.

## 3.5.8 메모리 할당의 전체 이야기

`malloc` 함수가 호출되면 다음과 같은 일련의 과정이 발생한다:

1. `malloc`은 먼저 현재 힙 영역 내에서 사용 가능한 여유 메모리 조각을 검색하고, 요청된 크기에 적합한 조각이 있으면 그것을 할당한다.
2. 만약 적절한 여유 메모리 조각이 없다면, `brk` 같은 시스템 호출을 통해 힙 영역을 확장해 추가 메모리를 확보한다.
3. `brk`가 호출되면 CPU는 사용자 상태에서 커널 상태로 전환되며, 운영체제의 가상 메모리 시스템이 힙 영역을 확장한다. 이때 확장된 메모리는 가상 메모리일 뿐이며, 아직 실제 물리 메모리는 할당되지 않았을 수도 있다.
4. `brk` 실행이 완료되면 `malloc`으로 제어가 돌아가고, CPU는 다시 사용자 상태로 전환된다. `malloc`은 새로 확보된 공간 중 적절한 조각을 찾아 반환한다.
5. 프로그램은 성공적으로 메모리를 할당받아 이후 단계를 실행한다.
6. 코드가 새로 할당된 메모리에 접근(읽기 또는 쓰기)하면, 운영체제는 페이지 누락(page fault) 인터럽트를 감지하고 CPU는 다시 커널 상태로 전환된다. 운영체제는 이 시점에서 실제 물리 메모리를 할당하고, 가상 메모리와 물리 메모리 간의 매핑을 페이지 테이블에 설정한다. 이후 CPU는 사용자 상태로 돌아가 프로그램의 다음 명령을 실행한다.

# 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까

`malloc`을 통해 메모리를 한 번 요청하는 과정은 복잡하며, 운영체제와의 상호작용이 필요해 성능에 영향을 줄 수 있다.

그래서 범용적인 `malloc` 대신, 특정 상황에서는 직접 메모리 할당 전략을 구현하기도 하는데, 이를 **메모리 풀(Memory Pool)** 기술이라고 한다.

메모리 풀은 미리 일정 크기의 메모리를 할당해두고, 필요할 때 빠르게 꺼내 쓰고 다시 반납하는 방식으로, 성능 향상과 메모리 관리 효율성을 높일 수 있다.

## 3.6.1 메모리 풀 대 범용 메모리 할당자

- `malloc`은 표준 라이브러리 계층에 포함되어 있으며, 메모리 풀은 응용 프로그램 내부에서 특정 목적에 맞게 직접 구현한 메모리 관리 방식이다.
- 범용 메모리 할당자인 `malloc`은 다양한 상황에 대응할 수 있도록 복잡하게 설계되어 있다. 반면, 메모리 풀은 특정 상황에 최적화되어 있기 때문에 설계는 비교적 단순하지만 범용성은 떨어진다.
- 메모리 풀은 설계된 조건에서만 높은 성능을 발휘하며, 그 외의 상황에서는 성능이 좋지 않거나 사용할 수 없다.

## 3.6.2 메모리 풀 기술의 원리

메모리 풀 기술은 한 번에 큰 메모리 조각을 요청하고 그 위에서 자체적으로 메모리 할당과 해제를 관리하는 방식으로 표준 라이브러리와 운영체제를 우회한다.

또 특정 사용 패턴에 따라 추가 최적화도 가능하다. 비즈니스 설계에 따라 메모리 풀에서 이미 생성한 객체를 요청하고 사용이 끝나면 메모리 풀에 반환할 수 있다.

특정 상황에 맞추어서 구현된 메모리 풀은 해당 상황에 사요오디는 메모리의 사용패턴을 이해하고 있으므로 범용메모리 할당자에 비해 이점이 있다.

## 3.6.3 초간단 메모리 풀 구현하기

서버 프로그램이 단순하여 사용자 요청을 처리할 때 단 하나의 데이터 구조만 사용한다고 가정하면, 미리 고정된 수량만큼 메모리 영역을 할당해 둘 수 있다.

이렇게 확보한 메모리 풀에서 실제 사용 시마다 하나씩 꺼내어 사용하며, 상황에 따라 메모리 수량은 직접 조절할 수 있다.

## 3.6.4 더 복잡한 메모리 풀 구현하기

여러 개의 메모리를 할당하려면 여유 메모리 조각을 관리해야 하며, 이를 위해 연결 리스트를 사용하여 각 여유 메모리 조각의 위치를 기록하는 포인터를 관리한다.

메모리가 부족하면 `malloc`에 새로운 메모리 조각을 요청하는데, 이때 요청하는 메모리의 크기는 이전 메모리 조각의 두 배여야 한다. 이 전략은 C++의 `vector` 컨테이너 확장 방식과 유사하며, 메모리 요청이 빈번하게 일어나지 않도록 하기 위함이다. 여기서 메모리 풀은 실제 `malloc`이 반환한 메모리 위에 재할당되는 방식이다.

메모리 풀에는 여유 메모리 조각의 시작 위치를 기록하는 `gtrr+ptr` 포인터가 있어, 빠르게 여유 메모리 조각을 찾을 수 있다. 이 메모리 풀에서는 `free`와 같은 메모리 해제 기능을 제공하지 않으며, 요청 처리와 완료 후 한 번에 전체 메모리 풀을 해제한다. 이러한 방식은 범용 메모리 할당자와 달리 메모리 해제 부담을 최소화하는 특징을 가지고 있다.

## 3.6.5 메모리 풀의 스레드 안전 문제

메모리 풀은 단일 스레드 환경에서 잘 동작하지만, 다중 스레드 환경에서 스레드 안전성을 보장하기 위해 메모리 풀에 잠금 보호를 추가해야 한다. 이 잠금 보호는 스레드 풀이 올바르게 작동되도록 보장하지만, 대량의 스레드가 메모리 할당과 해제를 요청하면 잠금 경쟁이 심화될 수 있다. 추가적인 잠금이 성능 저하를 일으킬 수 있으므로, 각 스레드마다 별도의 메모리 풀을 유지하여 스레드 간 경쟁 문제를 근본적으로 해결하는 것이 이상적이다.

각 스레드에 대한 메모리 풀을 유지하려면 스레드 전용 저장소(Thread Local Storage, TLS)가 유용하다. 스레드 전용 저장소에 스레드 풀을 할당하면, 각 스레드는 자신에게 할당된 메모리 풀만 사용하게 되어 스레드 간 경쟁을 해결할 수 있다.

# 3.7 대표적인 메모리 관련 버그

## 3.7.1 지역 변수의 포인터 반환하기

```c
int* func() 
{
	int a = 2;
	return &a;
}

void main() 
{
	int* p = func();
	*p = 20;
}
```

이 코드에서는 지역 변수 `a`가 `func` 함수의 스택 프레임에 위치하며, `func` 함수의 실행이 끝나면 해당 스택 프레임이 제거된다. 그 후, `main` 함수가 `func` 함수를 호출한 후 얻은 포인터는 이미 존재하지 않는 변수를 가리키게 된다.

이후 다른 함수(예: `foo`)가 호출되면 포인터 `p`가 가리키는 메모리 영역이 `foo` 함수의 스택 프레임에 덮어써지며, 포인터 `p`가 가리키는 값이 수정되어 `foo` 함수의 스택 프레임이 영향을 받게 된다.

## 3.7.2 포인터 연산의 잘못된 이해

```c
int sum(int* arr, int len) 
{
	int sum = 0;
	
	for(int i=0; i<len; i++) 
	{
		sum += *arr;
		arr += sizeof(int);    // -> arr++
	}
	
	return sum;
}
```

이 코드는 포인터 연산을 잘못 이해하고 있다. 포인터 연산에서 1을 더하는 것은 1바이트만큼 이동하는 것이 아니라, 포인터가 가리키는 데이터 형식의 크기만큼 이동하는 것이다. 예를 들어, 포인터가 `int`형을 가리킬 때, 포인터에 1을 더하면 4바이트만큼 이동하는 것을 의미한다. 마찬가지로, 포인터가 1024바이트 크기의 구조체를 가리킬 때, 포인터에 1을 더하는 것은 1024바이트만큼 이동하는 것이다.

## 3.7.3 문제 있는 포인터 역참조하기

```c
int a;

scanf("%d, a);
```

`scanf` 함수는 인자로 받은 값을 변수의 주소로 취급하여 입력값을 해당 메모리에 저장한다. 이때 지역 변수 `a`의 초기화가 되지 않으면 `scanf("%d", a);`에서 `a`가 가리키는 주소가 불확실하게 되어, 다음과 같은 문제가 발생할 수 있다:

1. `a`값이 코드 영역이나 기타 읽기 전용 메모리를 가리키면, 운영체제는 보호 오류를 감지하고 해당 프로세스를 즉시 종료한다.
2. `a`값이 스택 영역을 가리키면, 다른 함수의 스택 프레임이 덮여서 예측 불가능한 동작을 일으킬 수 있다.
3. `a`값이 힙 영역이나 데이터 영역을 가리키면, 프로그램이 동적으로 할당한 메모리가 손상되어 역시 예측할 수 없는 동작을 일으킬 수 있다.

## 3.7.4 초기화하지 않은 메모리 읽기

```c
void add() {
	int* a = (int*)malloc(sizeof(int));
	*a += 10;
}
```

앞의 코드는 `malloc`으로 할당된 메모리가 항상 0으로 초기화된다고 잘못 가정하고 있다. 실제로는 다음 두 가지 가능성이 존재한다:

1. `malloc`이 내부적으로 유지하고 있는 여유 메모리에서 메모리 조각을 반환하는 경우, 해당 메모리는 이전에 사용된 적이 있어 그 내용이 0이 아닐 수 있다.
2. `malloc`이 여유 메모리가 부족해 운영체제에 새로운 메모리를 요청(brk 등 시스템 호출)하는 경우, 새롭게 매핑된 물리 메모리는 실제 사용 시 페이지 누락 인터럽트에 의해 할당되며, 이때 운영체제가 메모리를 0으로 초기화하기도 한다.

따라서 `malloc`이 반환하는 메모리가 항상 0으로 초기화된다고 보장할 수 없으며, 수동으로 초기화해야한다.

## 3.7.5 이미 해제된 메모리 참조하기

```c
void add() 
{
	int* a = (int*)malloc(sizeof(int));
	...
	free(a);
	
	int b = *a;
}
```

이 코드는 힙 영역에서 메모리를 할당하고 해제한 후, 해제된 메모리를 다시 참조하는 잘못된 동작을 포함하고 있다. 이때 포인터 `a`가 가리키는 메모리의 상태는 다음 두 가지로 나뉜다:

1. `a`가 가리키는 메모리 조각이 해제된 후 아직 `malloc`으로 다시 할당되지 않았다면, `a`는 여전히 이전 데이터를 가리킬 수 있다.
2. `a`가 가리키는 메모리 조각이 이미 다른 `malloc` 요청으로 재할당되었다면, `a`가 참조하는 메모리는 다른 데이터로 덮어쓰기 되었을 수 있다.

즉, 해제된 메모리를 참조하는 것은 정의되지 않은 동작이며, 프로그램의 예측 불가능한 동작을 초래한다.

## 3.7.6 배열 첨자는 0부터 시작한다.

```c
void init(int n)
{
	int8 arr = (int*)malloc(n * sizeof(int));
	
	for(int i=0; i<=n; i++)
	{
		arr[i] = i;
	}
}
```

앞의 코드는 배열 첨자가 0부터 시작한다는 점을 잊고 할당 범위를 초과하여 `n+1`번 접근함으로써, `arr` 배열 뒤의 메모리를 `i` 값으로 덮어쓴다.

이 코드의 실행 결과는 `malloc`의 내부 상태에 따라 달라진다:

1. `malloc`이 `arr`에 반환한 메모리 블록이 우연히 `n * sizeof(int)`보다 크다면, 초과된 접근이 실제 오류를 일으키지 않을 수도 있다.
2. 하지만 초과해서 덮은 메모리 영역에 `malloc`이 사용하는 내부 메모리 할당 상태 정보가 저장되어 있었다면, 이 정보가 손상되어 이후의 `malloc`/`free` 동작이 비정상적으로 작동할 수 있다.

즉, 이와 같은 초과 접근은 정의되지 않은 동작을 유발하며, 메모리 오류나 프로그램 충돌로 이어질 수 있다.

## 3.7.7 스택 넘침

```c
void buffer_overflow()
{
	char buf[32];
	gets(buf);
	
	return
}
```

이 코드는 사용자 입력이 32바이트를 초과하지 않는다고 가정하지만, 만약 초과 입력이 발생하면 함수의 스택 프레임 내 데이터를 파괴하게 된다. 이로 인해 스택 프레임이 손상되며, 가장 이상적인 결과는 프로그램이 즉시 충돌하여 강제 종료되는 것이다. 그렇지 않으면 실행 시간 예외가 발생하지 않은 채 잘못된 동작이 계속 이어질 수 있다.

스택 프레임에는 함수의 반환 주소 같은 중요한 정보가 저장되어 있어, **스택 버퍼 오버플로우(stack buffer overflow)** 는 심각한 문제를 일으킬 가능성이 크다. 모든 함수는 실행 시 스택 영역에 고유의 스택 프레임을 갖고, 함수의 반환 주소는 이 프레임에 저장된다. 일반적인 상황에서는 함수 실행이 끝나면 이 반환 주소를 기준으로 호출한 함수로 되돌아간다. 하지만 스택 버퍼 오버플로우가 발생하면, 넘친 데이터가 반환 주소를 덮어쓰게 되고, 이로 인해 프로그램의 흐름이 공격자가 의도한 방식으로 변경될 수 있어 심각한 보안 취약점이 된다.

## 3.7.8 메모리 누수

```c
void memory_leck()
{
	int *p = (int *)malloc(sizeof(int));
	
	return;
}
```

앞의 코드는 메모리를 요청한 뒤 즉시 반환하지 않아, 프로세스가 종료되기 전까지 해당 메모리를 다시 해제할 방법이 없다. 이로 인해 **메모리 누수(memory leak)** 가 발생한다.

메모리 누수는 자동 쓰레기 수집(automatic garbage collection)을 지원하지 않는 언어에서 흔히 발생한다. 프로그램이 메모리만 계속 할당하고 적절히 해제하지 않으면, 프로세스의 힙 영역이 점점 커지게 되고, 결국 운영체제가 메모리 부족으로 인해 해당 프로세스를 강제 종료할 수 있다. 리눅스에서는 이를 **OOM Killer (Out Of Memory Killer)** 라고 부르며, 시스템 전체의 안정을 위해 메모리를 과도하게 사용하는 프로세스를 종료한다.

# 3.8 왜 SSD 메모리로 사용할 수 없을까?

최신 SSD의 읽기 속도는 맹 빠른데 왜 이를 메모리로 사용할 수 없을까?

## 3.8.1 메모리 읽기/쓰기와 디스크 읽기/쓰기의 차이

메모리는 바이트 단위로 주소가 지정되어, 각 바이트마다 고유한 주소가 있고 CPU는 이 주소를 통해 직접 접근할 수 있다.

반면 SSD는 바이트 단위가 아닌 조각(블록) 단위로 데이터를 관리하며, 블록 크기는 고정되어 있지 않고 다양하다. 따라서 SSD는 바이트 단위 주소 지정이 불가능하고, CPU가 특정 바이트를 직접 접근할 수 없다. 이로 인해 CPU는 SSD나 디스크에 저장된 데이터를 직접 실행할 수 없으며, 데이터를 메모리로 불러온 뒤 실행해야 한다.

## 3.8.2 가상 메모리의 제한

최신 운영체제는 가상 메모리 기반으로 메모리를 관리하지만, 32비트 시스템에서는 주소 지정 한계 때문에 문제가 발생한다. 32비트 시스템은 최대 4GB까지만 주소 지정이 가능하므로, SSD가 1TB의 용량을 가지고 있더라도 개별 프로세스는 4GB 이상의 메모리를 사용할 수 없다.

## 3.8.3 SSD 사용 수명 문제

SSD는 기록 가능한 최대 바이트를 TB 단위로 표시하는 TBW(Total Bytes Written)로 수명을 나타낸다. 일반적인 SSD의 TBW는 수백 TB 수준으로, 누적된 기록량이 이 수치를 넘으면 문제가 발생할 가능성이 높다. CPU는 프로그램 실행 시 많은 메모리 읽기와 쓰기 작업을 수행하므로, SSD를 메모리처럼 사용하면 빠르게 수명이 닳고 시스템 병목 현상이 발생할 수 있다. 반면 메모리는 이러한 수명 문제나 병목 현상이 없다.

