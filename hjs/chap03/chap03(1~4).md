# 3.1 메모리의 본질, 포인터와 참조

## 3.1.1. 메모리의 본질은 무엇일까? 사물함, 비트, 바이트, 객체

비어있는 사물함을 찾아서 짐을 넣어둘 수 있고, 짐이 많다면 사물함 여러 개에 나누어 보관할 수 있는 것 처럼, **메모리**의 원리도 사물함에 비유할 수 있다.

메모리의 가장 작은 단위를 **메모리 셀**이라고 표현한다. 메모리 셀에는 0과 1만 보관할 수 있고, 이것을 **1비트**(bit)라고 한다. 또한 더 많은 정보를 표현하기 위해 비트 여덟 개를 묶어 정보를 나타내는 하나의 단위인 **1바이트**(byte)를 사용한다.

각 사물함에 번호가 있는 것처럼, 각 바이트에도 번호를 붙이므로 이 고유의 주소를 **메모리 주소**(memory address)라고 한다. 메모리 주소 한 개를 사용하여 특정한 메모리 셀 여러 개를 찾을 수 있으며, 이를 **주소 지정**(addressing)이라고 한다.

1바이트(=8비트)는 2의 8승(=256)이므로 더 많은 조합을 표현하기 위해, 일반적으로 4바이트를 묶어 하나의 정수를 표현하는 단위로 사용한다. 4바이트(=32비트)는 2의 32승(=4,294,976,296)이므로 충분한 조합을 가진다. C언어와 같은 프로그래밍 언어에서 int형 변수의 크기가 4바이트인 이유이다.

그러나 정수를 표현하는 것 외에도 여러 정보 조합을 표현하기 위해, 12바이트를 사용해서 정보를 조합하여 표시할 수 있으며 이를 프로그래밍 언어에서는 **구조체**(structure) 또는 **객체**(object)라고 표현한다.

## 3.2.2. 메모리에서 변수로 : 변수의 의미

숫자 1과 숫자 2를 표현하기 위해 각각 1바이트를 사용한다고 가정하면, 먼저 이 두 숫자를 메모리 셀 두 개에 넣어야 한다. 그 중 숫자 1을 6번 메모리 셀에 넣는다면 다음과 같이 표현할 수 있다.

`store 1 6`

모두 숫자 형식으로 되어 있지만 하나는 저장할 숫자값을 의미하고, 다른 하나는 메모리 주소를 의미한다.

쓰기에 대응하는 읽기를 위해 load 명령어를 사용한다고 가정하면, 그 형태는 다음과 같다.

`load r1 6`

하지만 이 명령어 뜻이 숫자 6을 r1 레지스터에 읽어오는 것인지, 아니면 메모리 셀에 저장된 숫자를 r1 레지스터에 읽어노는 것인지 알 수 없다. 숫자가 값과 메모리 주소를 모두 나타낼 수 있기 때문에, 이 두 가지를 구분하기 위해 숫자 앞에 특별한 기호를 붙일 수 있다.

`store $1 6`,  `load r1 6`

앞에 `$`기호가 붙어있다면 값이고 `$`기호가 없다면 메모리 주소를 의미하는 것이다.

이제 주소 6은 숫자 1을 나타낸다.

`주소 6 → 숫자 1`

그러나 좀 더 쉽게 부르기위해 ‘주소 6’에 ‘a’라는 다른 이름을 붙일 수 있다.

`a = 1`

이렇게 변수라는 단어가 탄생한 것이다. a변수가 나타내는 숫자 1이 메모리 주소 6에 저장되어 있다. 다시 말해 a변수에는 다음과 같은 두 의미가 있다.

1. 값 1을 나타낸다
2. 이 값은 메모리 주소 6에 저장된다.

`b = a`

a값을 b에 준다는 할당이 이루어진 것이다.

또한 2번 메모리 셀에 b 변수를 저장했다면 a변수에 저장된 숫자 1이 그대로 2번에 복제된다.

이제 a변수가 1바이트의 데이터 뿐만 아니라 구조체나 객체처럼 여러 바이트를 차지하는 데이터도 나타낼 수 있다고 가정해보자.

3번 주소에 a변수를 저장하면, 이제 a변수는 5바이트를 차지하게되고 ㅇ니는 전체 메모리의 절반 이상에 해당한다.  하지만 데이터를 복사하는 방법은 메모리 공간이 부족하게 된다. 복사 방법을 사용하면 두 변수가 나타내는 데이터 만으로도 이미 10바이트를 차지하기 때문이다.

## 3.1.3. 변수에서 포인터로 : 포인터 의미하기

a변수에는 다음과 같은 두 의미가 있다고 했다.

1. 값 1을 나타낸다
2. 이 값은 메모리 주소 6에 저장된다.

여기서 두번째 뜻에는 변수가 얼마나 많은 메모리 공간을 차지하고 있는지 관계없이 메모리 주소만 알고 있으면 해당 데이터를 찾을 수 있다는 것을 알려준다. 또한 메모리 주소 역시 하나의 숫자로 이 역시 해당 데이터가 차지하고 있는 메모리 공간 크기와는 무관하다는 것도 알려 준다.

즉, 만약 b변수가 a변수를 가리키고 있다면 굳이 불필요한 데이터의 복사본을 만들 필요가 없을 것이다. 그저 그 주소를 다시 저장하면 되는 것이다.

a변수는 메모리 주소 3에 위치하고 있으므로 b변수에는 숫자 3을 저장할 수 있다. 변수가 값뿐만 아니라 메모리 주소까지 저장할 수 있게 되면서 포인터가 탄생했다. **포인터는 메모리주소를 더 높은 수준으로 추상화 한 것이다.**

어셈블리어에서 1번주소에 저장된 b의 변수가 가리키는 값을 적재하려면 다음과 같이 작성할 수 있다.

`load r1 1`

하지만 이렇게 코드를 작성하면 이 명령어는 메모리 주소 1에 있는 숫자 3을 r1 레지스터에 적재한다. 하지만 메모리 주소 1에 있는 값을 또 다른 메모리 주소로 해석하기 위해 식별자를 다시 한 번 추가해야한다.

`load r1 @1`

이렇게 하면 이 명령어는 먼저 메모리 주소 1에 저장된 값인 3을 읽어 이 3이라는 값을 메모리주소로 간주하여 해석한 후 메모리 주소 3이 가리키는 값을 진짜 데이터로 간주한다. 이 값이 바로 a변수를 나타내는 값이 되고, 이 과정을 간단히 표시하면 다음과 같다.

`주소1 → 주소3 → 데이터`

이를 간접주소지정(indirect addressing)이라고 하며, 어셈블리어에는 변수라는 개념이 없기 때문에 어셈블리어를 사요한다면 이 간접주소지정계층을 알고 있어야 한다.

반면 고급언어는 이와 다르게 변수개념이 있는데, 이 때 메모리 주소 1이 가리키는 것은 b변수일 뿐이다. 변수를 사용할 수 있을 때 가지는 장점 중 하나는 대부분의 경우 첫 번째 뜻에만 관심을 가지고, b 변수가 실제로 저장되는 위치가 어디인지는 관심을 가지지 않아도 괜찮다는 것이다.

`b → 데이터`

즉 비교하면 다음과 같다

`주소1 → 주소3 → 데이터`    //어셈블리어 수준

`b → 데이터`                         //고급언어 수준

이것이 포인터를 더 높은 수준의 추상화라고 말하는 이유이고, 이 추상화 목적은 간접주소지정을 감싸기 위해서이다. 이렇게 변수가 값과 메모리 주소를 모두 담을 수 있게 되면서, 겉으로 경계가 느슨해보이는 메모리 내부를 포인터를 이용하여 조직화할 수 있으며, 프로그래머가 복잡한 데이터 구조를 직접 처리할 수 있게 되었다.

## 3.1.4. 포인터의 힘과 파괴력 : 능력과 책임

포인터 개념이 있으면 프로그래머는 메모리 같은 하드웨어를 직접 조작할 수 있지만, 포인터 개념이 없는 프로그래밍 언어에서는 이런 작업이 불가능하다.

포인터 개념이 있는 언어에서는 변수주소를 통해 해당 변수가 메모리 어느 위치에 저장되어 있는지 직접 확인할 수 있다.

하지만 직접 메모리를 읽고 쓸 수 있는 이 기능이 모든 상황에 다 필요한 것은 아니다. 자바나 파이썬 같은 언어에는 포인터가 없지만 포인터 대신 사용할 수 있도록 포인터를 한 번 더 추상화한 참조가 있기 때문이다.

## 3.1.5. 포인터에서 참조로 : 메모리 주소 감추기

포인터를 지원하는 대신 참조라는 개념을 제공하는 프로그래밍 언어에서 참조를 사용할 때는 변수의 구체적인 메모리 주소를 얻을 수 없으며, 참조는 포인터와 유사한 구조의 산술 연산을 할 수 없다. 메모리 위치에 값을 더하거나 빼면 각각의 메모리 주소에 저장되어 있는 데이터를 볼 수 있지만, 참조에는 이런 기능이 없는 것이다.

참조를 사용하면 데이터를 복사할 필요가 없기 때문에 포인터를 사용할 때와 동일한 효과를 얻을 수 있다. 즉 **포인터는 메모리 주소를 추상화 한 것이고, 참조는 포인터를 한 번 더 추상화한 것이다.**

그러나 메모리 자체는 더 추상화될 수 있다. 이것이 바로 가상 메모리이다. 가상 메모리를 지원하는 시스템에서 프로세스가 사용하는 메모리 주소는 사실 실제 물리 메모리 주소가 아니다.

<br>
<hr>

# 3.2. 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?

## 3.2.1. 가상메모리 : 눈에 보이는 것이 항상 실제와 같지는 않다.

두 프로세스가 모두 같은 주소에 데이터를 쓸 수 있다면, 이것이 문제가 되지는 않는다. 이 메모리 주소는 가짜주소이며, 이 주소는 메모리에 조작이 일어나기 전에 실제 물리 메모리 주소로 변경된다.

프로세스들이 실제 물리 메모리에서 보여주는 모습에서 두 가지 사항에 주목할 수 있다.

1. 프로세스는 동일한 크기의 ‘조각(chunk)’으로 나뉘어 물리 메모리에 저장된다.
2. 모든 조각은 물리 메모리 전체에 무작위로 흩어져있다.

보기에는 중구난방일 수 있지만, 운영체게가 (비록 가상이자만) 프로세스에 균일한 가상으 주소 공간을 제공하는 것ㅇ르 방해하지는 않는다. 가상 메모리와 물리 메모리 사이의 **사상**(mapping) 관계만 유지하면 된다. 이것이 바로 **페이지 테이블**(page table)이 존재하는 이유이다.

## 3.2.2. 페이지와 페이지 테이블 : 가상에서 현실로

가상 메모리 주소 공간은 물리 메모리에 사상되어 있다. 가상 메모리 주소와 물리 메모리 주소의 사상 관계가 유지되는 한 프로세스 주소 공간으 ㅣ데이터가 실제 물리 메모리의 어디에 저장되는지는 전혀 신경 쓸 필요가 없다.

이런 사상 관계를 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 페이지테이블만 있어야 한다.

여기서, 모든 가상 주소를 물리주소에 사상하는대신 프로세스의 주소 공간을 동일한 크기의 조각으로 나누고, 이 조각을 **페이지**라고 부른다. 이처럼 사상은 페이지 단위로 이루어지므로 페이지 테이블이 가져야하는 항목 수가 대폭 줄어든다.

결국 두 프로세스가 동일한 메모리 주소에 기록하더라도, 메모리 주소가 가리키는 페이지가 서로 다른 물리 메모리 주소에 저장되기 때문에 문제가 발생하지 않는다. 이 표준적이고 정리된 가상 주소 공간은 현실에는 존재하지 않으며, 단지 논리적인 표현에 불과한다.

<br>
<hr>

# 3.3 스택 영역 : 함수 호출은 어떻게 구현될까?

## 3.3.1. 프로그래머를 위한 도우미 : 함수

반복적으로 작성하는 코든느 다음에 호출하기 위해 함수에 담아둘 수 있으며, 이렇게 하면 동일한 기능을 하는 코드를 매번 반복해서 작성할 필요가 없다. 함수는 가장 기초적이고 간단한 코드 재사용 방식이다. 이외에도 함수는 프로그래머가 구현의 세버 사항을 감출 수 있게 하므로, 함수를 호출할 때는 함수 이름, 매개변수, 반환값만 알면 된다.

함수가 어떻게 구현되어 있는지는 신경 쓸 필요가 없으며, 이 역시 일종의 추상화에 해당한다.

## 3.3.2-3. 함수 호출 활동 추적하기 : 스택

스택은 후입선출 순서로 이루어진다. 스택 상단의 작업궤적은 이진트리의 탐색이라는 것도 알 수 있다. 이것은 이런 트리 구조의 순회가 재귀 구현뿐만 아니라 스택 구현에도 사용될 수 있다.

스텍 프레임(stack frame) 또는 호출 스택(call stack)에는 해당 함수가 실행될 때 사용되는 여러 가지 정보가 저장되어 있으며, 이것들은 스택 구조를 통해 구성된다. 이 구조는 우리가 일반적으로 말하는 프로세스의 스택 영역에 생성된다.

함수가 실행될 때, 프로세스 스택 영역의 높은 주소가 맴 위에 있고 스택영역은 낮은 주소 방향으로 커진다. 다시 말해 스택영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가하고 함수 호출이 완료될 수록 감소한다.

## 3.3.4. 함수 점프와 반환은 어떻게 구현될까?

함수 A가 함수 B를 호출하면, 제어권이 함수A에서 B로 옮겨진다. 여기에서 제어권은 실제로 CPU에서 어떤 함수에 속하는 기계 명령어를 실행하는지 의미한다. CPU가 함수A의 명령어를 실행하다가 함수 B의 명령어로 점프하는 것을 제어권이 함수 A에서 B로 이전되었다고 이야기한다.

제어권이 이전될 때는 다음 두 가지 정보가 필요하다.

- **반환**(return) : 어디에서 왔는지에 대한 정보
- **점프**(jump) : 어디로 가는지에 대한 정보

함수 호출 원리도 마찬가지다.

- 함수 A의 기계 명령어가 어디까지 실행되었는지(어디에서 왔는지)
- 함수 B의 첫 번째 기계 명령어가 위치한 주소(어디로 가는지)

이 두 가지 정보만 있으면 CPU에서 함수 A에서 함수 B로 점프하여 명령어를 실행하게 한 후 함수 B의 실행이 완료되면 다시 함수 A로 점프하게 할 수 있다. 그렇다면 이런 정보는 어떻게 획득하고 유지할까? 이때 스텍프레임의 도움이 필요하다.

CPU는 현재 함수 A의 명령어를 실행하고 있는 중이다. 함수 A에서 함수 B를 호출하면 `CALL` 명령어가 실행되고, CPU는 함수 B의 첫 번째 명령어로 점프하게 된다. 이때 단순히 점프만 하는 것이 아니라, 함수 A로 다시 돌아올 수 있도록 함수 A의 다음 명령어 주소(복귀 주소)를 스택에 저장하게 된다.

함수가 호출되면 그 함수만을 위한 스택 프레임이라는 공간이 스택에 만들어진다. 이 공간에는 복귀 주소, 지역 변수, 매개변수 등이 저장된다. 함수 B가 호출되면 함수 B의 스택 프레임이 생성되고, 이로 인해 스택은 아래 방향으로 확장된다. 이후 함수 B에서 또 다른 함수를 호출하면 마찬가지로 새로운 스택 프레임이 생성되고, 스택은 계속해서 쌓이게 된다.

함수 B의 실행이 끝나면 `RET` 명령어가 실행되고, 스택에서 꺼낸 복귀 주소로 점프하여 CPU는 다시 함수 A의 다음 명령어를 실행하게 된다. 이 과정을 통해 함수 호출과 반환이 자연스럽게 이루어지는 구조이다.

## 3.3.5-6. 매개변수 전달과 반환값, 지역변수 어떻게 구현될까?

CPU는 기계 명령어를 실행할 떄 점프와 반환이 가능하기 때문에 이를 이용하여 함수를 호출할 수 있었다. 하지만 함수를 호출할 때는 함수 이름 외에도 매개변수를 전달하고 반환값을 가져와야 한다. 이를 어떻게 구현할 수 있을까?

대부분의 경우 **매개변수의 전달과 반환값**을 가져오는 작업을 레지스터로 한다. 함수 그런데 CPU 내부의 레지스터 수는 제한되어 있다. 전달된 매개변수 수가 사용가능한 레지스터 수보다 많다면, 나머지 매개변수는 스텍 프레임에 직접 넣을 수 있으므로, 새로 호출된 함수가 이전 함수의 스택 프레임에서 매개변수를 가져오면 된다.

함수 외부에 정의된 변수를 **전역변수**라고 하며, 이 변수들은 실행파일의 데이터 영역에 저장되어있다. 프로그램이 실행되면 프로세스 주소 공간의 데이터 영역에 적재된다. 반면 함수 내부에서 정의된 변수는 **지역변수**라고 하는데, 이 변수들은 해당 함수에서만 사용 가능하고 외부에서는 접근이 불가능하다. 이 지역변수는 앞서 살펴본 매개변수와 마찬가지로 레지스터에 저장할 수 있지만, 로컬 변수 수보다 레지스터 수가 많으면 이 변수들도 스택 프레임에 저장될 수 있다.

## 3.3.7. 레지스터의 저장과 복원

타 함수가 기존 함수의 레지스터에 기록한 지역변수 정보를 덮어쓴다면 문제가 될 수 있기 때문에, 레지스터에 지역변수를 저장하기 전에 반드시 먼저 레지스터에 원래 저장되었던 **초깃값**을 꺼냈다 레지스터를 사용하고 나면 다시 그 초깃값을 저장해야한다.

이 레지스터에 원래 저장되었던 값 역시 함수의 스택 프레임에 저장된다. 함수 실행이 완료된 후에는 스택 프레임에 저장되어 있는 초깃값을 상응하는 레지스터에 내용을 복원하기만 하면 된다.

## 3.3.8. 스택오버플로우 오류

앞서 설명했던 스택 프레임은 우리가 흔히 스택 영역이라고 하는 곳에 위치해있다. 스택 영역은 프로세스 주소 공간의 일부이며, 스택 영역을 확대하면 레지스터 초깃값, 지역변수, 매개변수, 반환주소 등을 가지게 되는 것이다.

이 때 함수가 매버 ㄴ호출될 때마다 상응하는 스택 프레임은 함수 실행 시 정보를 저장하기 위해 생성되며, 함수 호출 단계가 증가함에 따라 스택 영역이 점점 더 많은 메모리를 차지하게 된다. 하지만 스택 영역의 크기에는 제한이 있으며, 이 제한을 초과하면 바로 스택 넘침(Stack overflow) 오류가 발생한다.

따라서 프로그래머는 다음 사항들을 주의해야한다.

1. 너무 큰 지역 변수를 만들면 안 된다.
2. 함수 호출 단계가 너무 많으면 안 된다.