# 컴퓨터 밑바닥의 비밀 : 1장

### 1.1 여러분이 프로그래밍 언어를 발명한다면

**1. 초기 CPU**

CPU는 데이터를 옮기고 연산하는 작업만 수행했지만, 굉장히 빠른 속도를 자랑했기 때문에 간단한 연산에서는 절대로 따라잡을 수 없는 성능을 보였다.

최초의 프로그래머가 CPU와 의사소통할 때는 CPU의 관점에서 직접 0과 1로 구성된 명령어를 작성해야 했다. 이것이 바로 코드(code)이며, 소스(source)이다.

이 시기에는 천공카드(punched card)를 통해 명령어를 입력하면 컴퓨터가 작업을 시작했기 때문에 프로그램은 눈에 보이기도 하고 만질 수도 있었다.

**2. 어셈블리어**

어셈블리어는 기계어와 특정 작업을 간단하게 대응시켜, 기계어를 인간이 읽고 이해할 수 있는 단어로 표현한 언어다.

기계 명령어를 0과 1로 구성된 바이너리 형태로 변환하는 프로그램을 사용하여 어셈블리어가 탄생했다.

**3. 저수준과 고수준 언어**

어셈블리어가 등장했지만 CPU는 여전히 추상적인 언어를 이해하지 못했고, 반대로 인간은 추상적 표현에 익숙했기 때문에 인간과 기계 사이의 간극을 좁힐 방법이 필요했다.

이로 인해 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 명령어로 변환하는 방법이 필요하게 되었다.

**4. 규칙 발견**

명령어는 대부분 직관적이며, 이러한 명령어에 '문(statement)' 또는 '문장'이라는 이름을 붙일 수 있다.

또한 다음과 같은 규칙이 존재함을 발견할 수 있다.

- 조건에 따른 분기
- 반복 구조
- 함수 호출

이러한 규칙을 이용해 인간이 사용하는 언어처럼 표현할 수 있게 되었다.

```python
# 조건에 따른 이동
if 조건:
    실행문
else:
    실행문

# 순환
while 조건:
    실행문

# 함수
def abc():
    실행문
```

**5. 재귀**

수열이 자식 수열에 의존하는 것처럼, 단계 안에 또 다른 단계가 중첩되는 구조를 재귀로 표현할 수 있다.

재귀를 통해 복잡한 구조를 몇 개의 간결한 문장으로 표현할 수 있게 되었다.

세상의 모든 코드는 아무리 복잡하더라도 결국 구문(syntax)으로 귀결된다. 이는 모든 코드가 구문에 기초하여 작성되었기 때문이다.

**6. 컴파일러**

컴퓨터는 프로그래밍 언어를 처리할 때 구문 정의에 따라 트리(Tree) 형태로 코드를 구성한다.

이때 번역 결과를 차례대로 부모 노드에 적용하는 방식으로 상위 단계로 올라가며, 최종적으로 전체 트리를 구체적인 기계 명령어로 변환할 수 있다.

이 작업을 수행하는 프로그램이 바로 컴파일러(Compiler)**이다.

컴파일러는 프로그래머가 인간이 이해할 수 있는 언어로 작성한 코드를 CPU가 이해할 수 있는 기계어로 변환하는 역할을 한다.

**7. 해석형 언어**

CPU에는 다양한 유형이 존재하는데, 각 CPU에 맞게 표준 명령어 집합을 정의하고, CPU의 기계 명령어 실행 과정을 모방하는 프로그램을 작성할 수 있다.

이렇게 각 CPU에 상응하는 시뮬레이션 프로그램을 준비하면 코드를 서로 다른 플랫폼에서 실행할 수 있게 된다.

이러한 CPU 시뮬레이션 프로그램을 가상 머신(Virtual Machine)이라고 하며, 이를 인터프리터(Interpreter)라고 부르기도 한다.

---

### 1.2 컴파일러는 어떻게 작동하는 것일까?

**1. 컴파일러 실행 과정**

프로그래머가 단어를 통해 작성한 코드는 소스파일(Source File)이라고 한다.

이 소스파일을 컴파일러에 전달하면 컴파일러는 이를 CPU가 이해할 수 있는 기계 명령어로 번역하게 된다.

컴파일러는 먼저 각 요소를 세부적으로 쪼개고, 이때 각 요소가 가진 추가 정보를 함께 묶어 관리한다.

이 결합 형태를 토큰(Token)이라고 하며, 컴파일러는 소스코드를 탐색하며 모든 토큰을 찾아낸다.

이렇게 소스 코드에서 토큰을 추출하는 과정을 어휘 분석(Lexical Analysis)이라고 한다.

**2. 토큰**

컴파일러는 토큰을 찾은 후, 다음 토큰에 따라 문법 오류를 보고하거나 다음 토큰을 만날 때까지 대기하며 처리하는 과정을 반복한다.

이 과정을 해석(Parsing)이라고 한다.

컴파일러가 구문에 따라 해석한 결과는 구문 트리(Syntax Tree)로 표현되며, 이 트리를 생성하는 전체 과정을 구문 분석(Syntax Analysis)이라고 한다.

**3. 구문 트리**

구문 트리가 생성된 후, 컴파일러는 논리적 오류나 모순이 없는지 확인하는 의미 분석(Semantic Analysis) 단계를 수행한다.

의미 분석이 끝나면 컴파일러는 구문 트리를 탐색하여 이를 기반으로 좀 더 다듬어진 형태의 중간 코드(IR Code, Intermediate Representation)를 생성한다.

**4. 코드 생성**

중간 코드가 생성되면 컴파일러는 이를 어셈블리어(Assembly Code)로 변환하며, 최종적으로 어셈블리어 코드는 기계 명령어(Machine Code)로 변환된다.

이 과정을 통해 컴파일러는 인간이 작성한 소스코드를 CPU가 실행할 수 있는 명령어로 번역하게 된다.

**5. 링크(Link)**

각 소스파일은 각각의 대상 파일(Object File)을 생성하지만, 프로그래머가 원하는 것은 최종적으로 하나의 실행 파일(Executable File)이다.

따라서 여러 대상 파일을 하나의 실행 파일로 합치는 과정이 필요하며, 이 작업을 링크(Link)라고 한다.

이 링크 작업을 수행하는 프로그램을 링커(Linker)라고 부른다.

---

### 1.3 링커의 말할 수 없는 비밀

**1. 링커(Linker)**

링커는 컴파일러가 생성한 여러 개의 대상 파일(Object File)을 하나로 묶어 최종 실행 파일(Executable File)을 생성한다.

링크 과정은 마치 여러 저자가 특정 부분을 맡아 챕터별로 집필한 뒤, 개별 장을 묶어 한 권의 책으로 출판하는 것과 비슷하다.

코드에서도 유사한 재배치 과정이 일어난다.

예를 들어, 한 소스 파일에서 다른 모듈에 정의된 함수를 참조할 경우, 컴파일러는 해당 함수의 메모리 주소를 알 수 없기 때문에 이를 표시만 해둔 채 넘어간다. 이후 링크 과정에서 링커는 이러한 표시를 확인하고 함수의 정확한 주소를 파악하여 대체한다.

**2. 심벌 해석(Symbol Resolution)**

심벌(Symbol)은 전역 변수(Global Variable)와 함수(Function)의 이름을 포함하는 모든 변수 이름을 의미한다. 컴파일러는 외부에서 정의된 전역 변수나 함수를 발견하면 해당 변수가 실제로 정의되었는지는 확인하지 않고 넘어간다. 이 참조된 변수의 정의를 찾는 일은 링커의 역할이다. 컴파일러는 다음 두 가지를 심벌 테이블(Symbol Table)에 기록하여 대상 파일에 저장한다.

- 공급 (Exported Symbols)

  내가 정의한 심벌로, 다른 모듈에서 사용할 수 있는 심벌

- 수요 (Imported Symbols)

  내가 사용하는 외부 심벌


링커는 각 대상 파일을 탐색하며, 수요가 공급으로 충족되는지 확인하는 과정을 수행한다. 이 과정을 심벌 해석(Symbol Resolution)이라고 한다.

**3. 정적 라이브러리(Static Library)와 동적 라이브러리(Dynamic Library)**

코드가 복잡해질 경우, 여러 팀이 각자 코드를 관리하는 것은 어려운 일이므로, 각 팀의 코드를 별도로 컴파일한 후 패키지로 묶고 구현된 모든 함수의 선언을 포함하는 헤더 파일(Header File)을 제공하는 방식을 사용한다. 이렇게 생성된 라이브러리를 정적 라이브러리(Static Library)라고 한다.

- 정적 링크(Static Linking)

정적 링크는 컴파일 단계에서 정적 라이브러리를 실행 파일에 복사하는 방식이다.

이 방식은 실행 시 독립적이지만, 디스크와 메모리를 낭비하게 된다.

- 동적 링크(Dynamic Linking)

이를 해결하기 위해 동적 라이브러리(Dynamic Library)라는 개념이 등장했다.

동적 라이브러리는 실행 파일에 라이브러리 전체가 복사되지 않고, 필수 정보만 포함된다.

동적 링크는 실제 프로그램이 실행될 시점에 라이브러리를 로드하게 된다.

**4. 동적 링크의 실행 방식**

동적 링크는 다음 두 가지 방식으로 이루어진다.

1. 프로그램이 메모리에 적재될 때 동적 링크 진행
2. 프로그램이 먼저 실행된 후, 실행 시간(runtime) 동안 코드가 직접 동적 링크를 수행

**5. 동적 라이브러리의 장단점**

- 장점
    - 동적 라이브러리의 복사본은 디스크에 하나만 존재하기 때문에 리소스를 절약할 수 있다.
    - 동적 라이브러리의 코드가 수정될 경우 해당 라이브러리만 다시 컴파일하면 된다.
    - 플러그인 시스템에서 유용하게 사용할 수 있다.
- 단점
    - 프로그램이 실행 시점에 링크되므로 성능이 약간 떨어질 수 있다.
    - 종속된 동적 라이브러리를 찾지 못하거나 버전이 호환되지 않을 경우, 프로그램이 실행되지 않을 수 있다.


**6. 재배치(Relocation)**

컴파일러가 미리 알 수 없는 변수의 메모리 주소는 대상 파일(Object File)에 기록된다.

링커는 프로그램 실행 시 해당 변수가 실제로 위치하게 될 메모리 주소로 해당 명령어를 수정해야 한다.

이 과정을 재배치(Relocation)라고 한다.

**7. 가상 메모리(Virtual Memory)**

가상 메모리는 각 프로그램이 자신만의 독립적인 메모리 공간을 사용하는 것처럼 착각하게 만든다.

이 때문에 모든 프로그램은 동일한 표준적인 메모리 구조를 가질 수 있으며, 프로그래머는 이러한 구조를 기반으로 코드를 작성할 수 있다.

가상 메모리를 통해 링커는 실행 시점에 심벌의 메모리 주소를 결정할 수 있으며, 프로그램 실행과 관계없이 메모리 구조를 예측할 수 있다.

가상 메모리는 물리 메모리와 1:1로 매핑되지 않으며, 이러한 사상(mapping) 관계를 기록한 표를 페이지 테이블(Page Table)이라고 한다.

각 프로세스는 자신만의 페이지 테이블을 가지며, 하드웨어는 이를 참조하여 물리 메모리 주소로 변환한다.

---

### 1.4 컴퓨터 과학에서 추상화가 중요한 이유

소프트웨어는 매우 복잡하지만, 추상화(Abstraction)는 프로그래머가 이 복잡성을 효과적으로 제어할 수 있도록 돕는다.

모든 프로그래밍 언어는 추상화를 지원하기 위해 각자 고유한 작동 방식을 제공한다.

**1. 다양한 추상화의 예**

추상화는 다양한 컴퓨터 시스템 요소에 적용된다.

- 입출력 장치 → 파일(File)로 추상화
- 실행 중인 프로그램 → 프로세스(Process)로 추상화
- 물리 메모리와 파일 → 가상 메모리(Virtual Memory)로 추상화
- 네트워크 프로그래밍 → 소켓(Socket)으로 추상화
- 프로세스와 실행 환경 → 컨테이너(Container)로 추상화
- CPU, 운영체제, 응용 프로그램 → 가상 머신(Virtual Machine)으로 추상화

**2. 추상화의 역할**

추상화는 프로그래머를 저수준의 복잡한 계층에서 점점 더 멀어지게 만들고, 세부 사항에 신경 쓸 필요가 없도록 한다.

이 덕분에 개발자는 더 높은 수준의 논리와 기능에 집중할 수 있으며, 소프트웨어 개발의 효율성과 생산성을 높일 수 있다.