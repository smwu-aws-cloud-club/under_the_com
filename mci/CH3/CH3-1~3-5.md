## 3.1. 메모리의 본질, 포인터와 참조

<aside>

- ⭐‘값 복사’의 구현 방식 차이로 포인터 개념이 생겼다고 볼 수 있음.

- ⭐포인터의 위력은 주소를 조작(주소 연산;Pointer Arithmetic)하여 다른 주소의 데이터로까지 접근이 가능한 것에서 나온다.

</aside>

- 가장 작은 단위: 메모리 셀 - 0과 1만을 보관함.
  - 더 큰 숫자 등을 표현하기 위해 이를 8개씩 묶어 1byte로 지정.
- 포인터 = 메모리주소의 추상화
  - b=a와 같이 값이 동일한 것을 가리킨다면 직접 메모리 할당하는 대신 주소를 저장하는 것으로 대체함.

  ⇒ `변수 = 값 | 메모리 주소` 할당 가능함.

- 포인터와 참조
  - 공통점: 데이터 복사와 동일한 효과.
  - 차이점: 포인터는 값을 조작해서 다른 주소의 데이터로까지 접근을 허용하지만, 참조는 아니다.

  → 파이썬과 자바와 같은 언어는 포인터 대신 참조를 사용해 변수가 값만을 저장하는 것처럼 보임.


## 3.2. 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?

<aside>

- ⭐가상메모리란 프로세스가 사용하는 메모리에 대한 논리적 표현이며, 실제 메모리상으로는 조각나 중구난방으로 존재한다. 인터페이스 개념과 비슷한 것 같다.

- ⭐가상메모리를 사용하는 이유
  - 메모리 보호: 가상메모리 체제에서 각자 독립된 가상주소 공간을 받아 서로 침범할 수 없음.
  - 메모리 파편화 해결: RAM 이곳저곳 파편들을 모아 프로세스에게는 연속된 하나의 공간인 것처럼 보여준다. 프로그래머는 여유 메모리 공간을 고민하지 않고 편하게 코딩이 가능함.
</aside>

- 가상메모리

  ![image.png](attachment:7bd37b1d-e720-48df-a329-e37b5ea06e35:image.png)

  - 논리적 구분으로 스택/힙/데이터/코드 영역으로 나누어둔 것.
  - 실제 물리 메모리 내에서는 여러 chunk로 나뉘어 중구난방으로 존재. → 페이지 테이블로 가상메모리와 물리메모리를 사상시킨다.

    따라서 가상메모리는 페이지 테이블로 구현이 가능하다고 할 수 있다.


## 3.3. 스택 영역: 함수 호출은 어떻게 구현될까?

<aside>

- ⭐프로세스가 실행 중 함수를 호출하면, 함수의 실행 정보를 담은 고유한 스택 프레임이 스택 영역에 적재된다.

- 현재 CPU 아키텍처(x86-64, ARM)는 성능을 고려해 최대한 레지스터를 활용하고, 스택은 그다음에 사용함.

</aside>

- 함수 호출 단계는 stack의 선입후출 꼴이다.
- 프로세스의 스택 영역에는 함수의 stack frame이 쌓이는데, 이는 일반적인 stack과 달리 아래로 쌓인다. 함수 호출 깊이에 따라 메모리가 증가하는 방식이다.
- 함수 전환의 구현

  실행중이던 함수 = A; 다음에 실행할 함수=B

  1. 어디로 갈지 - [함수 점프] : 그다음 함수 B의 첫번째 명령어 주소
  2. 어디로 돌아올지 - [함수 반환] : 지금까지 실행한 함수 A의 그다음 명령어 주소
- stack frame에 담기는 것들
  - `매개변수`는 실행 중이던 함수 A의 stack frame에 저장되고, B가 사용함.
    - 다만 CPU 내부 레지스터 수 < 전달 매개변수 수인 경우에 stack frame에 저장된다. 보통은 레지스터에 저장됨.
  - `지역변수`

  → 매개변수와 지역변수 모두 레지스터에 적재될 수 있지만 공간이 부족하면 스택 프레임에 저장하는 것 같음.

  - `함수 반환주소` : 종료 후 돌아갈 명령어 주소
  - `레지스터 초기값 (Callee-saved Register)`; 함수를 실행하는 동안 CPU 레지스터에 적재된 정보 (다른 함수가 레지스터를 사용하면서 덮어씌우는 문제 해결)
  - 이전 스택 프레임 포인터 : 이전 함수의 스택 시작점이라는데. 진짜 들어가는지 확인
- 전역변수 저장 위치: 실행파일의 데이터영역 → (프로그램 실행 시) 프로세스 주소공간의 데이터 영역.
  - 실행파일은 설계도고 프로세스는 실제 건물. (정적인 상태일 때) `.exe` 실행파일 내부에 전역변수가 기록되었다가 프로그램을 실행시켰을 때 OS가 하드디스크의 실행파일을 읽어서 RAM(메모리)에 올린다. 이때 RAM 위에 프로그램을 위해 할당된 전용 공간을 ‘프로세스 주소공간’이라고 하고, 기존 파일의 데이터영역에 있던 전역변수 정보가 메모리의 실제 주소에 자리잡는 것.

    보통은 하나의 프로그램 = 하나의 프로세스 생성. 일부 프로그램은 보안이나 안정성을 위해 작업을 여러 프로세스로 쪼개기도 함(멀티 프로세싱)

- Stack Overflow: 함수 호출이 너무 많아지면 스택 프레임 증가 → 스택 영역이 제한을 초과하면서 생기는 오류. 지역변수 크기와 함수 호출 횟수를 신경써야 한다.
- 함수 실행이 완료되면 해당 스택 프레임은 무효화되기 때문에, 무효화된 스택 프레임 영역에 있는 값은 사용해서는 안된다.

  그렇지만 A 호출 → B 실행 중인 상태에서 A의 스택 프레임은 살아있기 때문에 A 스택 프레임에 있는 지역변수를 사용하는 것은 가능하다.

  스택 프레임이 유효한 상태냐 아니냐(함수가 실행이 완료됐냐 아니냐)가 관건.


## 3.4. 힙 영역: 메모리의 동적할당은 어떻게 구현될까?

- 힙 영역: 프로그래머가 완전히 직접 제어할 수 있는 메모리 영역.
- 동적 메모리 할당의 목적: 전 모듈에 노출되는 전역 변수 말고 여러 함수에 걸쳐 특정 데이터를 쓰고 싶은 경우
  - 할당: `malloc` / `new` (예약어; C, C++ 순서로)

    → 힙영역 메모리 할당자를 `malloc` 이라 하자. 메모리 영역을 요청할 때 사용가능한 영역을 준다.

  - 해제: `free` / `delete`

    메모리 사용을 완료할 때 힙 영역에 해당 메모리를 반환한다.

- 메모리 할당자의 구현
  1. 여유 메모리 구분은 어떻게?
    - 순회 방법: Linked List 방식으로, 시작 헤더에서 메모리크기를 더해가면서 다음 주소로 이동할 수 있다.
    - head를 사용하여 `[메모리 크기 | 메모리사용여부(flag)]` 를 표시한다.
    - footer를 사용하게 된다면, 이전 메모리에 접근할 수 있다.
      - 목적: 인접 여유 메모리 조각 병합을 더 쉽게 하기 위해서.
      - 기능: 이 경우 doubly Linked List처럼 자유롭게 앞뒤로 오가기 가능
      - 단점: 아니 근데 그러면 `[12/0| 사용가능 메모리 |12/0]`인 경우에는 사용가능 메모리가 12-4*2라서 4바이트밖에 안되잖아? 너무 심한 낭비다.. 두배로 더 낭비되는 것 같다.
  2. 어떤 기준으로 다양하게 조직화된 메모리를 할당할 수 있는가?
    - 대표적으로 3가지 할당전략 사용 - 최초/다음/최적 적합
      - 최적 적합은 모든 가능한 여유 메모리를 순회하고 가장 차가 적은 걸 선택하는 거라 시간이 걸리는 게 단점. 아마 성능 순은 최적>최초>다음이 아닐까 싶네요
  3. 요청한 것보다 더 큰 메모리를 주면 남은 메모리를 어떻게 활용할 수 있는가?
    - 새로운 여유 메모리로 header를 달아준다.
  4. 사용자가 반환한 메모리는 어떻게 할까?
    - 메모리 요청할 때 주소를 주듯 반환할 때도 주소를 리턴한다.
      그리고 flag를 바꾸어 놓는다.
    - 반환한 메모리 및 인접한 여유 메모리들이 있을 때 이를 어떻게 활용할까?
      - 즉시 병합: 구현이 쉽다
      - 병합 연기: 구현 방법을 잘 모르겠다. 어떻게 구현할까?

  → 1,3,4는 구분자만 정해진다면 비슷한 질문으로 묶일 수 있다.


## 3.5. 메모리를 할당할 때 저수준 계층에서 일어나는 일

<aside>

- ⭐전체 흐름

1. 프로그램이 malloc에 메모리 요청
2. malloc이 여유 메모리 검색. (user mode)
3. malloc이 여유메모리 검색에 실패하면 brk system call한다.
4. (kernel mode) 가상 메모리 시스템이 힙영역을 확장함. → 아직은 실제 물리 메모리를 할당하지 않았을 수 있음.
5. brk 실행 종료 → malloc이 여유 메모리를 찾아 반환 (user mode)
6. 프로그램 실행 중 새로 요청한 메모리를 읽거나 쓸 때 page fault interrupt → (kernel mode) OS가 실제 물리 메모리를 할당함 → 가상메모리와 실제메모리 사이 페이지 사상 관계 설정
7. (user mode) 요청 처리
</aside>

- CPU의 4가지 특권 단계: 작은 숫자일수록 전능하다.

  특권의 정의는 명령어 실행할 수 있는 권한을 의미한다.

  - 0단계: 커널 모드. 모든 명령어 실행이 가능하다.
    - 응용프로그램이 실행 불가능하다는데 모순 아닌가.
  - 4단계: 유저 모드. 응용프로그램을 실행한다.
- system call: 응용프로그램이 파일 IO, 네트워크 통신을 하는 방법. 프로세스가 시스템 호출 요청 → OS에서 처리 → 프로세스 마저 실행하는 방식.
- 표준 라이브러리: 응용프로그램을 모든 OS에서 사용할 수 있도록 고안
  - [응용프로그램 ↔ 표준 라이브러리 ↔ OS ↔ 하드웨어] 로, 표준 라이브러리에 속한 malloc과 같은 다양한 메모리 할당자가 각 OS에 따른 system call을 사용해서 실행함.
- OS에게 malloc이 메모리 요청하는 상황
  - 힙 영역 메모리가 부족한 경우 유휴 영역을 사용하기 위해서는 malloc이 OS에게 메모리를 요청해야 함.
    - 구현: 힙 영역의 최상단인 `brk` 변수값을 위로 이동시킴.

      `brk`, `mmap` 등. mmap이 좀더 유연함.