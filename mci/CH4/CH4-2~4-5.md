## 4.2. CPU 유휴 상태

- CPU 유휴 상태 정의: 준비 완료 대기열이 비어있는 상태
    - 구현: 모순적이게도 준비 완료 대기열에 항상 있는 최하순위 프로세스
        - if로 구현하는 방법 (X) 코드 번잡함
        - 연결리스트 방식으로 구현. 유휴 작업인 System Idle Process
            - 코드: CPU의 `halt` 명령어로 절전. 그러나 그동안에도 time interrupt는 계속 돌아간다. 때문에 무한루프문으로 구현되어 있어도 reschedule이 가능하다.
- CPU 사용률 체크: Windows의 경우 작업관리자에서 가능
- 프로세스 스케줄링
    - 우선순위를 매겨서 동작. 프로세스들을 대기열에 넣고 CPU가 순차적으로 처리한다.
    - [준비완료 대기열] → CPU → [블로킹 대기열] → IO
    - CPU는 항상 time interrupt를 받고, 이때 프로세스들의 준비상태를 확인 받아서 스케줄링을 한다.

## 4.3. CPU-숫자 관계

- 0이 중요한 이유: 우리가 위치기수법을 쓰니까
    - 위치기수법 쓰는 체계: 아라비안(0~9), 이진법
- 양의정수 → 음의정수 계산 구현
    
    ㅁㅁㅁㅁ : $2^4$개 표현 가능
    
    0 ㅁㅁㅁ : $2^3$개
    
    1 ㅁㅁㅁ : $2^3$개
    
    - 우리가 원하는 것
        - A+(-A)=0
        - 0 표현 1가지
    1. [부호][크기] 표현
        - 단점: -0과 0 2개가 발생
    2. 1의 보수(그냥 뒤집기) 사용
        - 단점: -0과 0 2개가 발생
    3. 2의 보수(뒤집고+1) 사용 → 채택!

## 4.4. CPU-코드 관계 (if문의 경우)

결론: 특정 상황에서 프로그래밍할 때 CPU 신경써야 한다.

- CPU의 퍼포먼스는 프로그램 코드의 영향을 받을 수 있다.
    
    프로그램 코드에서 배열의 정렬 여부에 따라 분기예측 실패(`branch-miss`) 값이 달라진다.
    
- Pipeline 기술 (Wedgwood → Ford;산업 조립라인의 시초)
    
    ![Uploading image.png…]()

    
    - 명령어 인출
    - 해독
    - 실행
    - 다시쓰기
    
    명령어들을 순차적으로 실행
    
- 여기서 `if`문을 고려해야 하는 이유: 다음 명령어가 무엇이 될지 알 수 없음
    - 컴파일러: `if` → 조건부 점프 명령어로 변환 (어디까지 점프할지 알 수 없음)
    
    → 따라서 CPU는 필연적으로 분기 가능성을 추측해야 함. 잘못 예측할 경우 바로 손실(무효화 작업)
    
- 분기가능성 추측
    - 고려 요소 (혹은 도움되는 툴):
        - 프로그램 실행 이력 기반 .. (이외 뭐가 있을까)
        - `likely/unlikey macro`로 컴파일러에 가능성 높은 분기 알려줄 수 있음 (정확히 어떻게 작동하는지?)

## 4.5. CPU-스레드의 관계 (코어 수-스레드 수)

- 단일 코어는 한 순간에 하나의 명령만 처리할 수 있으므로, 병렬처리를 할 수 없음
    - 병렬성: 실제로 여러 작업이 동시에 물리적으로 실행되는 것 (멀티코어 필요)
    - 동시성: 여러 작업이 아주 빠르게 번갈아 실행되면서 동시에 하는 것처럼 보이는 것 (단일 코어에서도 가능)
- 비유
    - CPU = 요리사
    - 스레드 = 요리
    
    요리사 수와 요리 개수는 필연적인 관계 없다. 코어 수와 스레드 수 역시 마찬가지.
    
    단일 코어도 얼마든지 다중 스레드 생성 가능. (CPU는 단지 PC 레지스터가 가리키는 주소에서 명령어 가져와서 실행할 뿐!)
    
- 다중 스레드의 장점
    - 작업에서 다른 코드에 영향 줄 수 있는 [블로킹 일으키는 입출력 / 대량 계산]을 별도 스레드로 분리하면 나머지 코드에 영향을 주지 않는다.
