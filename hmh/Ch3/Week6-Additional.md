# Additional Research

## 3.6 스레드가 완료된 후에도 다른 스레드에서 해당 메모리를 사용한다면?

## 문제 상황
> 스레드 전용 저장소(TLS)에 있는 메모리 풀을 사용하면, 각 스레드는 자신만의 메모리 풀을 갖게 된다. 그런데 어떤 스레드가 그 풀에서 메모리를 할당한 후, 그 메모리를 다른 스레드가 계속 사용하게 되면 어떻게 될까?

> 즉, 메모리의 수명 주기가 그 메모리를 할당한 스레드(예: A)를 넘어서 다른 스레드(예: B)까지 지속되며, A는 이미 종료된 상태라면, B가 해당 메모리를 해제해야 할 텐데 이 경우 어떻게 안전하게 처리해야 하는가?

질문의 전제 조건
- 각 스레드는 자신만의 메모리 풀(TLS 기반)을 가짐.
- 메모리는 스레드 A의 풀에서 할당되었지만, 수명은 A보다 길고, 다른 스레드 B가 사용 및 해제해야 할 수도 있음.
- 그러나 메모리가 여전히 스레드 A의 메모리 풀 소속이라면, A가 종료되면 해당 풀도 사라지고, 해제할 수단이 없어질 수 있음.

## 해결 방법

### 1. **Thread-Local Memory에서 글로벌 풀로 승격(Escalation)**

- 특정 자원이 스레드 외부로 공유될 수 있음을 감지하거나 판단하면,
    
    → 해당 자원을 **글로벌 메모리 풀(Global Pool)**로 옮기고,
    
    → 더 이상 TLS에서 해제하지 않게 만드는 방식.
    

```cpp
if (should_escape_tls_scope(ptr)) {
    global_pool.adopt(ptr);  // 글로벌 풀로 승격
}
```

> **자원 해제 책임이 특정 스레드에 묶이지 않음**.
> 

### 2. **풀 단위에서 자원 해제 위임**

- 자원을 직접 해제하지 않고, 반드시 메모리 풀의 `release()` 또는 `free()` 함수를 통해서만 해제하게 만듦.
- 이 함수 내부에서 자원이 어느 풀에서 할당되었는지 추적하고, 적절한 풀에 반환함.
- 예시:

```cpp
void universal_free(void* ptr) {
    MemoryPool* pool = find_pool_for(ptr); // 할당 정보를 통해 풀을 추적
    pool->release(ptr);
}
```

> 즉, 스레드가 다르더라도 자원은 반드시 원래의 풀로 돌아가게 하는 방식.
> 

### 3. **풀 공유 구조 사용 (Thread-Aware Global Pool)**

- 아예 처음부터 **스레드 전용이 아닌 공유 메모리 풀**을 사용하고,
- 내부적으로 lock-free 큐나 슬랩 할당자를 사용하여 다중 스레드 환경에서 동기화 없이 사용할 수 있도록 설계함.
- 대표적인 라이브러리: `jemalloc`, `tcmalloc`, `mimalloc` 등.

> TLS보다 약간 성능 손해가 있지만, 메모리 수명 문제는 발생하지 않음.
> 

### 4. **참조 카운팅 (shared_ptr 등)과 조합**

- 스레드 A에서 메모리를 할당하더라도, 스마트 포인터(shared_ptr 등)를 통해 수명 주기를 자동 관리.
- 마지막 참조가 없어질 때, 해당 메모리를 **글로벌 풀 또는 커스텀 deleter를 통해 반환**.

```cpp
std::shared_ptr<T> ptr(new T, [](T* p) { global_pool.release(p); });
```