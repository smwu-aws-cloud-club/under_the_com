# Additional Research

## 3.3 질문에 대해서 찾아보기

> 매개변수가 너무 많으면 일부 매개변수가 스택에 저장되고, 레지스터 내용 중 일부는 스택 프레임에 저장된다. <br>
>
> 1. 매개변수가 너무 많아 레지스터에 저장되지 못한다는 정보는 어떻게 알 수 있을까? <br>
> 2. 스택 영역의 증가와 감소는 구체적으로 어떻게 구현될까? <br>
> 3. 이를 구현하는 책임은 누구에게 있을까? <br>

<br>

### 1. 매개변수가 너무 많아 레지스터에 저장되지 못한다는 정보는 어떻게 알 수 있을까?

> 호출 규약(Calling Convention)에 따라 결정된다.

**호출 규약**

- 함수를 호출할 때 인자를 어떻게 전달할지, 어떤 순서로 스택에 쌓을지, 스택 정리는 누가 할지 등에 대한 규칙

**레지스터 사용**

- x64 아키텍처에서는 처음 몇 개의 인자를 특정 레지스터(예: rcx, rdx, r8, r9)를 통해 전달한다.
- 하지만 인자의 개수가 레지스터의 수를 초과하면, 나머지 인자들은 스택을 통해 전달된다.

**확인 방법**
- 어떤 레지스터가 인자 전달에 사용되는지, 몇 개까지 레지스터로 전달 가능한지 호출 규약을 통해 알 수 있다.
- x64에서 7번째 이상의 인자는 스택 영역에 저장된다.
- 해당 플랫폼의 ABI 문서를 보면 명시되어 있다.

### 2. 스택 영역의 증가와 감소는 구체적으로 어떻게 구현될까?

> 스택은 LIFO(Last-In, First-Out) 원칙에 따라 작동되는 메모리 영역이다. <br>
> 스택 포인터(Stack Pointer, SP)는 스택 최상단을 가리키며 데이터가 스택에 추가되거나 제거될 때 값이 변경된다.

**스택 증가 (PUSH)**

- 스택에 데이터를 추가하려면 SP 값을 먼저 감소시킨 후, 해당 주소에 데이터를 저장한다.
- 이는 스택이 높은 주소에서 낮은 주소 방향으로 자라기 때문이다.

**스택 감소 (POP)**

- 스택에서 데이터를 제거하려면 SP가 가리키는 주소의 데이터를 읽어온 후, SP 값을 증가시킨다.
- 실제로 메모리에서 데이터가 삭제되는 것은 아니지만, SP 값이 변경되어 해당 영역이 더 이상 유효한 스택 영역으로 간주되지 않는다.

```nasm
; example
PUSH src:  ESP = ESP - 4;  Memory[ESP] = src; (32비트 환경)
POP dest:   dest = Memory[ESP];  ESP = ESP + 4; (32비트 환경)
```

### 3. 이를 구현하는 책임은 누구에게 있을까?

**운영체제(OS)**

- 프로세스 생성 시 스택 영역을 할당하고, 스택의 크기를 제한한다.
- 스택 오버플로우와 같은 예외 상황을 처리합니다.

**컴파일러**

- 함수 호출 시 스택 프레임을 설정하고 해제하는 코드를 생성한다.
- 매개변수 전달, 반환 주소 저장, 지역 변수 공간 할당 등이 포함된다.
- 함수 프롤로그(prologue)와 에필로그(epilogue) 코드가 이러한 역할을 수행한다.
  - 함수가 호출되고 종료될 때 스택 프레임을 설정하고 해제하는 데 사용되는 코드 조각
  - 스택과 레지스터를 함수가 호출되기 전의 상태로 복원한다.

**프로그래머**

- 스택에 너무 많은 데이터를 저장하지 않도록 주의해야 한다.
- 재귀 호출의 깊이를 제한하는 등 스택 오버플로우를 방지하기 위한 코드를 작성해야 한다.
- 필요한 경우 힙(heap) 영역을 사용하여 더 큰 메모리 공간을 확보할 수 있다.
