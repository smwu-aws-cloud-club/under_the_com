## 3.7 대표적인 메모리 관련 버그

### 3.7.1 지역 변수의 포인터 반환하기

- 이미 없는 변수를 가리키게 된다.
- 정상 작동할 수도 있지만 이를 통해 스택 프레임이 덮히거나 스택 프레임이 파괴되는 결과가 발생하기도 한다.

### 3.7.2 포인터 연산의 잘못된 이해

- 포인터 연산에서 덧셈은 바이트가 아닌 단위 만큼 이동한다.
- 따라서 포인터가 가리키는 데이터 형식의 크기는 전혀 신경 쓸 필요가 없다.

### 3.7.3 문제 있는 포인터 역참조하기

```c
int a;
scanf("%d", a);
```

- 런타임 오류를 발생시키지 않기 때문에 문제가 있는지 알지 못한다.
- 프로그램 결과는 a 값에 따라 달라진다.
- 코드 영역이나 기타 읽기 전용 영역을 가리키는 포인터 값으로 해석 → 프로세스 즉시 강제 종료
- 스택영역을 가리키는 포인터 값으로 해석 → 다른 함수의 스택 프레임이 파괴되었기 때문에 버그의 원인을 찾기가 매우 어렵다
- 힙 영역 또는 데이터 영역을 가리키는 포인터로 해석 → 동적으로 할당된 메모리가 파괴되었기 때문에 과거의 원인을 찾는 것이 매우 어렵다

### 3.7.4 초기화되지 않은 메모리 읽기

- 동적으로 할당된 메모리가 항상 0으로 초기화 된다고 잘못 가정한다.
- malloc을 호출할 때 실제로 두 가지 가능성이 존재한다는 것을 알아야 한다.
- malloc이 자체적으로 충분한 메모리를 유지하고 있다면, 메모리 조각에서 반환할 주소를 찾는다.
  - 이전에 사용한 정보가 남아 있을 수 있으므로 0이 아닐 수 있다.
- 유지하고 있는 메모리가 충분하지 않다면, 그 brk 같은 시스템 호출로 운영체제가 메모리를 요청한다 실제로 사용될 때 누락 인터 럽트가 발생하고 운영체제가 실제 물리 메모리를 할당하기 때문에 이 경우 0으로 초기화될 수 있다.
- 민감한 정보를 포함할 수 있어 보안을 위해서 운영체제가 메모리를 반환하기 전에 초기화한다.
- 아니면 수동으로 메모리를 초기화 해야 한다.

### 3.7.5 이미 해제된 메모리 참조하기

- 해제된 메모리 조각을 참조하는데 어떤 값이 들어 있을지는 malloc 내부의 작업 상태에 따라 다르다.
- 해제된 후 malloc으로 다시 할당하지 않았다면 값은 이전과 동일하다.
- 이미 malloc으로 할당되었다면 덮어쓰기가 되었을 수 있다.

### 3.7.6 배열 첨자는 0부터 시작한다

- 배열 접근이 범위를 벗어나면 malloc 작업이 손상될 수 있다.
- 덮어 쓴 메모리에 malloc이 사용하는 메모리 할당 상태 정보가 있다면 사용하는 malloc 동작을 파괴한다

### 3.7.7 스택 넘침

- 사용자 입력이 초과하는 순간 스텝 프레임 내에서 인접해 인터넷 어떤 데이터를 파괴한다
- 스택 프레임에는 함수에 반한 주소 처럼 중요한 정보가 들어 있어 버퍼 오버 플로우 문제를 일으킬 가능성이 높다
- 고정적인 해킹 기법

### 3.7.8 메모리 누수

- 메모리를 요청한 후 바로 반환되는데 아니다 프로세스가 종료되기 전까지 다시 해제 하지 않아 메모리 누수가 일어난다
- 특히 자동 쓰레기 수집을 지원하지 않는 언어에서 해제를 하지 않는다면 운영체제가 강제로 프로세스를 종료 하는 상황이라고 발생한다.
- 이를 메모리 부족 강제 종료(out of memory killer)
