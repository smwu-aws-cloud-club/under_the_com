# 3.1 메모리의 본질, 포인터와 참조

> 연산, 저장 => CPU, 메모리 <br>
> 모든 프로그램은 메모리에서 실행되어야 한다.<br>
> 바이트, 구조체, 객체, 변수, 포인터, 참조 <br>

## 3.1.1 메모리의 본질은 무엇일까? 사물함, 비트, 바이트, 객체

**메모리 셀(memory cell)**

- bit = 0과 1로 표현되는 하나의 단위. 대비되는 2가지 정보만 표현 가능한 한계.
- byte = 비트 8개를 묶어 정보를 나타내는 하나의 단위

**메모리 주소 (memory address)**

- 바이트마다 번호를 붙인 것
- 모든 바이트는 메모리 내 자신의 주소를 가지고 있음

**주소 지정 (addressing)**

- 메모리 주소 하나를 사용하여 특정한 메모리 셀 여러 개를 찾을 수 있음

## 3.1.2 메모리에서 변수로: 변수의 의미

**메모리 읽고 쓰기**

```nasm
; 숫자 1을 6번 사물함에 넣기
store 1 6     ; 저장할 값과 데이터 주소 -> 모호함
load r1 6

store $1 6    ; $기호가 있다면 값 / 없다면 데이터 주소
load r1 6
```

**변수**

- 별칭을 사용해 값을 저장
- 별칭의 의미1) 예시에서, 값1을 나타낸다.
- 별칭의 의미2) 이 값은 메모리 주소 6에 저장된다.

> 메모리 주소만 알고 있다면 해당 데이터를 찾을 수 있다.

> 메모리 주소는 해당 데이터가 차지하고 있는 메모리 공간 크기와는 무관하다.

⇒ 주소 저장. 불필요한 데이터 복사본을 만들 필요 X

**포인터**

- 메모리 주소를 더 높은 수준으로 추상화 → 간접 주소 지정을 감싸기 위한 것
- 간접 주소 지정 (indirect addressing)
  ```nasm
  ; 주소 1 -> 주소 3 -> 데이터
  load r1 @1     ; 메모리 주소 1에 저장된 값을 읽어 그 주소가 가리키는 값을 데이터로 간주
  ```
  - 변수가 실제로 저장되는 위치에 대해서 몰라도 괜찮다.
- 연결 테이블 처리 능력을 높이기 위해 개념이 도입되었다.

## 3.1.3 변수에서 포인터로: 포인터 이해하기

**포인터**

- 메모리 주소를 더 높은 수준으로 추상화 → 간접 주소 지정을 감싸기 위한 것
- 간접 주소 지정 (indirect addressing)
  ```nasm
  ; 주소 1 -> 주소 3 -> 데이터
  load r1 @1     ; 메모리 주소 1에 저장된 값을 읽어 그 주소가 가리키는 값을 데이터로 간주
  ```
  - 변수가 실제로 저장되는 위치에 대해서 몰라도 괜찮다.
- 연결 테이블 처리 능력을 높이기 위해 개념이 도입되었다.

## 3.1.4 포인터의 힘과 파괴력: 능력과 책임

**포인터 지원하지 않는 PL**

- 포인터를 지원하지 않는 프로그래밍 언어에서는 주소라는 개념이 변수로 추상화되어 있기 때문에 어디에 저장 되는지 신경 쓸 필요가 없다.
- 변수가 존재한다는 것만 알고 있으면 된다.
- 메모리 주소를 직접 노출하지 않아 메모리 주소를 확인 불가 → 특정 메모리 위치에 있는 데이터를 직접 조작하는 것이 불가능하다.

**포인터 지원 PL**

- 메모리 주소를 추상하지 않으면 훨씬 더 유연하다.
- 값과 메모리 주소를 모두 저장할 수 있다.
- 메모리 같은 하드웨어를 직접 조작할 수 있다.
  - 메모리 어느 위치에 저장되어 있는지 직접 확인할 수 있기 때문
- 추상화를 우회하여 직접 메모리를 읽고 쓸 수 있다.
- 반면 포인터 연산에 오류가 있을 때 실행 상태를 파괴할 수 있어 실수하지 않아야 한다.

## 3.1.5 포인터에서 참조로: 메모리 주소 감추기

**참조**

- 변수의 구체적인 메모리 주소를 얻을 수 없다.
- 포인터와 유사한 구조의 산수 연산을 할 수 없다.
- 메모리 위치에 값을 더하거나 빼서 각각의 메모리 주소에 저장되어 있는 메모리를 볼 수 없다.
- 데이터를 복사할 필요가 없기 때문에 포인터를 사용할 때와 동일한 효과를 얻을 수 있다.

> 즉, 포인터는 메모리 주소를 추상화한 것 <br>
> 참조는 포인터를 한 번 더 추상화한 것
