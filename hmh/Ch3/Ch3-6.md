## 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

- malloc 범용 제품
- 메모리 풀: 특정 상황을 위해 자체적으로 메모리 할당 전력을 구현

### 3.6.1 메모리 풀 대 범용 메모리 할당자

**차이점**

- 구성의 차이: malloc은 표준 라이브러리 계층에 속하고 메모리 풀은 응용 프로그램의 일부다.
- 사용 대상에 차이: 메모리 폴 기술은 특정 상황에서만 적용 가능하고 특정 상황에서만 메모리 할당 성능을 최적화하여 범용성이 매우 떨어진다.

### 3.6.2 메모리 풀 기술의 원리

**메모리 풀의 원리**

- 한 번에 큰 메모리 조각을 요청하고 그 위에서 자체적으로 메모리 할당과 해제를 관리하는 방식
- 사용 패턴에 따라 추가 최적화도 가능하다.
  - 여러 종류의 객체를 생성해야 한다면 자체 메모리 풀에 미리 이런 객체를 생성해 두는 것이 가능하다. 이미 생성한 개최를 요청하고 사용이 끝나면 메모리 풀에 반환할 수 있다.

### 3.6.3 초간단 메모리 풀 구현하기

**가정**

- 데이터 구조만 사용한다.

**구현**

예시 1)

- 미리 커다란 영역을 할당한다.
- 실제 사용할 때마다 하나씩 꺼내며 사용이 끝나면 반환한다.
- 수량은 실제 상황에 따라 직접 결정할 수 있다.

예시 2)

- 좀더 복잡한 메모리 풀을 구현한다.
- 크기가 서로 다른 메모리 요청을 지원하는 서버 프로그래밍 상황을 가 정한다
- 사용자 요청을 처리하는 동안 메모리 풀에서 메모리를 요청하는 것만 가능하고 해제는 처리하지 않는다.
- 요청 처리가 모두 완료되는 시점에서 요청된 메모리를 한꺼번에 해제 한다.<br>
  ⇒ 메모리의 할당과 해제에 따른 부담을 최소화 한다.

### 3.6.4 약간 더 복잡한 메모리 풀 구현하기

**구현**

- 여러 크기 메모리 할당을 위해, 여유 메모리 조각을 관리할 필요가 있다.
- 모든 메모리 조각을 연결 리스트로 연결하고 포인터를 사용하여 현재 여유 메모리 조각의 위치를 기록할 수 있다.
- 메모리가 부족하면 새로운 메모리 조각을 요청해야 하는데 새로운 메모리 조각의 크기는 이전 메모리 조각의 두 배여야 한다. → 메모리를 너무 빈번하게 요청하지 않기 위함이다.
- 메모리 풀의 여유 메모리 조각의 시작 위치를 가리키는 포인터가 있어 빠르게 여유 메모리 조각을 찾을 수 있다.
- 메모리 풀의 여유 메모리 조각의 크기가 충분하다면 이 포인터가 가리키는 주소를 직접 반환하고 포인터를 요청 메모리 만큼 뒤로 이동시키기만 하면 된다.
- 요청 처리가 완료되면 한 번에 전체 메모리 풀을 해제한다.
- 메모리 해제로 부담을 최대한 줄이는 것이 범용 메모리 할당자와 다른 점이다.
- 단일 스레드 환경에서는 잘 동작한다.

### 3.6.5 메모리 풀의 스레드 안전 문제

**잠금보호**

- 스레드 풀이 올바르게 작동하는 것을 보장한다.
- 대량의 스레드가 메모리 할당과 해제를 요청하면 잠금 경쟁이 매우 격렬하게 일어날 수 있다.
- 시스템 성능이 저하될 수 있다

**해결책**

- 스레드 전용 저장소를 사용한다.
- 스레드가 자신에게 속한 스레드 풀만 사용할 수 있다.
- 각 스레드마다 메모리 풀을 유지하여 스레드 간 경쟁 문제를 근본적으로 해결한다.
- 스레드 A의 실행이 완료된 후에도 다른 스레드에서 해당 메모리를 계속 사용한다면 해당 메모리는 스레드 B에서 이를 해제해야 한다.
