# 2.1 운영 체제, 프로세스, 스레드의 근본 이해하기

## 2.1.1 모든 것은 CPU에서 시작된다

**CPU**

1. 메모리에서 명령어를 하나 가져옴(dispatch)
2. 명령어를 실행(execute)한 후 다시 1.로 돌아감

**순서**

- 소스 파일을 컴파일러가 기계 명령어로 생성
- 디스크에 저장된 실행 파일에서 명령어가 메모리에 적재됨
- PC 레지스터 값이 다음 명령어를 향함
- 적재된 명령어를 실행함

<br>

## 2.1.2 CPU에서 운영체제까지

**멀티 태스킹**

- 프로그램을 일시 중지했다가 다시 시작
- 상태를 저장 (= 상황 정보(context))
- 모든 프로그램은 필요한 정보를 기록할 수 있는 구조체(= 프로세스)를 가짐
  ```
  struct *** {
    context ctx; // CPU의 상황 정보 저장
    ...
  }
  ```

**운영체제**

- 여러 가지 기반 기능의 프로그램을 모아 둔 도구
- 모든 것을 백그라운드에서 처리

<br>

## 2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다

**프로세스 주소 공간 process address space**

- 코드 영역 code segment: 코드를 컴파일하여 생성된 기계 명령어 저장
- 데이터 영역 data ~: 전역 변수 등이 저장
- 힙 영역 heap ~: malloc 함수가 요청을 반환한 메모리가 여기에 할당
- 스택 영역 stack ~: 함수의 실행 시간 스택

**다중 프로세스 프로그래밍**

- 프로세스를 생성할 때 비교적 큰 부담(overhead)이 걸림
- 프로세스마다 자체적인 주소 공간을 가지고 있어 프로세스 간 통신은 프로그래밍하기 더 복잡함

## 2.1.4 프로세스에서 스레드로 진화

**스레드 (= 경량 프로세스)**

- CPU 여러 개가 동일한 프로세스의 기계 명령어를 실행
- 하나의 프로세스 안에 여러 실행 흐름 존재
- 동일한 프로세스 주소 공간 공유 = 프로세스 간 통신 불필요
  - 스레드 사이에는 근본적으로 통신이라는 개념이 존재하지 X
  - 동일한 프로세스 주소 공간에 속해 있기 때문 → 스레드가 프로세스보다 가볍고 생성 속도가 빠른 이유

**발생하는 문제**

- 다중 스레드가 공유 리소스에 접근할 때 오류 발생 <br>
  → CPU가 명령어를 실행할 때 스레드를 고려하지 않기 때문 <br>
  → 상호 배제(mutual exclusion)와 동기화(synchronization) 이용해서 해결해야 함

## 2.1.5 다중 스레드와 메모리 구조

**함수와 메모리의 관계**

- CPU의 PC 레지스터에 스레드의 진입 함수 주소 지정 → 스레드 실행
- 함수가 실행될 때 필요한 정보는 대응하는 스택 프레임에 저장
- 모든 함수는 실행 시에 자신만의 실행 시간 스택 프레임을 가짐
- 스택 프레임은 후입선출(LIFO) 순서로 증가/감소 → 스택 영역 형성

**스레드와 메모리의 관계**

- 실행 흐름이 여러 개 → 스택 영역이 여러 개 필요
- 모든 스레드는 각자 자신만의 스택 영역을 가짐
- 스레드를 생성하면 프로세스 메모리 공간이 소모됨

## 2.1.6 스레드 활용 예

**긴 작업**

- 작업 처리에 필요한 시간이 긺
- 전용 스레드를 생성하는 것이 가장 적합

**짧은 작업**

- 작업 처리에 필요한 시간이 짧음
- 작업 수가 굉장히 많음

**요청당 스레드 thread-per-request**

- 요청이 들어올 때마다 매번 스레드를 생성
- 스레드 생성과 종료에 많은 시간을 허비
- 메모리 기타 시스템 리소스를 너무 많이 소비
- 스레드 간 전환에 따른 부담 증가 <br>

→ 스레드 풀thread pool 탄생

## 2.1.7 스레드 풀의 동작 방식

**스레드 풀**

> 스레드 재사용

- 스레드 여러 개를 미리 생성해두고 처리할 작업이 생기면 해당 스레드에 처리를 요청
- 생성과 종료 작업이 빈번하게 발생하지 않음
- 풀 내에 있는 스레드 수도 일반적으로 일정하게 관리
- 작업을 스레드 풀 내에 있는 스레드에 전달할 때는 대기열(queue) 사용
  - 작업은 2부분으로 구성됨 처리할 데이터 / 데이터를 처리하는 함수

**작업 전달 과정**

- 스레드 풀의 스레드가 작업 대기열에서 블로킹 상태로 대기
- 작업 대기열에 데이터를 기록하면 스레드 풀의 스레드가 깨어남
- 스레드가 구조체를 가져온 후 구조체의 handle이 가리키는 처리 함수 실행

## 2.1.8 스레드 풀의 스레드 수

> 몇 개가 적당할까?

**CPU 집약적인 작업**

- 스레드 수 = CPU 코어 수

**입출력 집약적인 작업**

- 입출력 대기 시간(Wait TIme, WT), CPU 연산에 필요한 시간(Computing Time, CT) 고려
- N × (1 + WT / CT)
- 테스트를 실시해 필요한 수를 결정하는 걸 추천
