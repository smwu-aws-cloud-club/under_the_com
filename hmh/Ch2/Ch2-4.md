# 2.4 프로그래머는 코루틴을 어떻게 이해해야 할까?

## 2.4.1 일반 함수
- return 명령어를 만나거나 마지막 줄까지 실행되어야 반환됨
- 재호출되면 처음부터 다시 시작 ~ 반환될 떄까지 실행

## 2.4.2 일반 함수에서 코루틴으로

**코루틴**
- yield 사용
- 일시 중지와 재개 기능
  - 코루틴은 자신의 실행 상태를 저장할 수 있음
  - 반환된 후에도 계속 호출이 가능
  - 일시 중지된 지점에서 다시 이어서 실행
  - 코루틴이 반환될 때 함수의 실행 시 정보를 저장
  ```
  def func:
    print("a")
    yield
    print("b")
  
  def A():
    co = func()             // 코루틴 획득
    next(co)                // 코루틴 호출
    print("in function A")  // 작업 실행
    next(co)                // 코루틴 재호출
  
  // a
  // in function A
  // b
  ```

## 2.4.3 직관적인 코루틴 설명
- 코루틴은 앞의 연결 시작 지점부터 실행
- 메인 함수 종료 시, 남아 있는 코루틴도 강제 종료

## 2.4.4 함수는 그저 코루틴의 특별한 예에 불과하다

- 스레드
  - 타이머 인터럽트 사용
  - 인터럽트가 처리될 때마다 운영 체제가 현재 스레드의 일시 정지 여부를 결정
- 코루틴
  - 사용자 상태
  - 타이머 인터럽트를 위한 작동 방식이 없어 yield와 같은 예약어를 사용해 명시적으로 지정.
  - 운영체제는 이를 알지 못함 <br>
    = 코루틴의 스케줄링 제어권은 온전히 사용자 몫


## 2.4.5 코루틴의 역사

- 스레드가 없을 시기에, 동시성을 갖는 프로그램 작성을 위해 사용
- 스레드 등장 후 운영 체제가 기본적으로 동시 실행 지원 → 잊혀짐
- 사용자 요청이 기하급수적으로 늘어남 → 높은 성능과 동시성 요구하는 분야에서 다시 사용됨

## 2.4.6 코루틴은 어떻게 구현될까?
> 코루틴은 일시 중지되거나 다시 시작할 수 있으며, 중지될 때의 상태 정보를 기록해야 한다

- 상태 정보 기록
  - CPU의 레지스터 정보
  - 함수 시행 시 상태 정보
- 힙 영역에 코루틴의 실행 시간 스택 프레임 정보를 저장
- 코루틴 개수에는 제한 없음
- 운영 체제가 개입할 필요 없음
- 저장/복구되는 정보도 더 가볍기 때문에 효율성이 높음
- 동기 방식으로 비동기 프로그래밍을 가능하게 함