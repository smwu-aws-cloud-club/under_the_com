# 6.4 높은 동시성의 비결: 입출력 다중화

> 모든 입출력 장치는 파일이라는 개념으로 추상화된다.

> 모든 입출력 작업은 파일 읽기와 쓰기로 구현할 수 있고, 추상화를 이용하여 일련의 인터페이스로 모든 외부 장치를 사용할 수 있다.

## 6.4.1 파일 서술자

> 파일 서술자라는 숫자 하나만 알면 입출력을 할 수 있다.

파일을 열 때 커널은 **파일 서술자(file descriptor)** 를 반환하며, 파일 작업을 실행할 때 해당 파일 서술자를 커널에 전달해 주어야 한다. 커널은 이 숫자를 얻은 후 해당 숫자에 대응하는 파일에 관련된 모든 정보를 찾아 파일 작업을 완료할 수 있다. (파일이 디스크에 저장되어 있는지, 디스크의 어느 위치에 저장되어 있는지, 지금 읽고 있는 위치는 어디인지 등의 정보가 필요 없다.)

```c
char buffer[LEN];
int fd = open(file_name); // 파일 서술자 얻기

read(fd, buffer);
```

## 6.4.2 다중 입출력을 어떻게 효율적으로 처리하는 것일까?

높은 동시성이란 서버가 동시에 많은 사용자 요청을 처리할 수 있음을 의미한다. 보통 수천수만 개의 처리를 말한다.

웹 서버에서 3방향 주고받기(3 way handshake)에 성공하면 accept 함수를 호출하여 연결을 얻을 수 있고, 추가로 파일 서술자도 얻을 수 있다. 일반적으로 먼저 사용자 요청 데이터를 읽고, 이에 따라 서버는 특정한 처리를 실행한다.

```c
if(read(socket_fd1, buff) > 0)
{
    // 첫 번째 처리
    do_something();
}

if(read(socket_fd2, buff) > 0)
{
    // 두 번째 처리
    do_something();
}
```

read는 일반적으로 블로킹 입출력이기 때문에. 첫 번째 사용자가 어떤 데이터도 보내지 않으면 해당 코드를 사용하는 스레드 전체가 일시 중지됩니다. 두 번째 사용자 요청을 처리할 수 없다.

**다중 스레드** 를 사용하는 것도 하나의 방법이겠지만, 스레드 수가 너무 많아질 수 있고 스레드의 스케줄링과 전환에 너무 많은 부담이 가해지므로 높은 동시성을 발휘해야 하는 상황에 최적의 방법이 아니다.

**문제** 는 파일 서술자 하나에 대응하는 입출력 장치가 읽을 수 있는 상태인지 쓸 수 있는 상태인지 미리 알 수 없다는 것이다.

## 6.4.3 상대방이 아닌 내가 전화하게 만들기

> 커널에 계속 전화를 거는 대신에 필요할 때 커널이 응용 프로그램에 통지하도록 한다.

이전: 대응하는 파일을 읽을 수 있는지 여부를 커널에 매번 질문

현재: 관심 대상인 파일 서술자를 커널에 알려 주고, 커널에 감시하다가 읽고 쓸 수 있는 파일 서술자가 있을 때 알려 주면 처리

응용 프로그램은 주동적이고 바쁜 상태에서 수동적이고 여유 있는 상태로 변한다. 이것이 프로그래머가 동시에 많은 수의 파일 서술자를 다룰 수 있는 방법인 **입출력 다중화(input/output multiplexing)** 기술이다.

## 6.4.4 입출력 다중화

통신 선로를 최대한 활용하려면 하나의 채널에서 여러 신호를 전송할 수 있어야 하므로 여러 신호를 하나로 합쳐야 하는데, 여러 신호를 하나로 합치는 장치를 다중화기(multiplexer)라고 한다.

이 신호를 수신하는 쪽에서는 신호를 수신한 후 원래의 여러 신호로 복원해야 하는데, 이 장치를 역다중화기(demultiplexer)라고 한다.

**입출력 다중화 과정**

1. 파일 서술자를 획득한다. 서술자 종류는 상관 없다.

2. 특정 함수를 호출하여 커널에 이 함수를 먼저 반환하는 대신, 이 파일 서술자를 감시하다 읽거나 쓸 수 있는 파일 서술자가 나타날 때 반환하라고 알린다.

3. 해당 함수가 반환되면 읽고 쓸 수 있는 조건이 준비된 파일 서술자를 획득할 수 있으며, 이를 통해 상응하는 처리를 할 수 있다.

> 입출력 다중화 기술을 사용하는 방법에는 select, poll, epoll 세 가지가 있다.

## 6.4.5 삼총사: select, poll, epoll

> 본질적으로 select, poll, epoll은 모두 동기 입출력 다중화 기술이다.

**select**

감시할 수 있는 파일 서술자 묶음에는 제한이 있으며, 일반적으로 1024개를 넘을 수 없다. 이 기술 구현 면에서 select가 호출될 때 대응하는 프로세스 또는 스레드는 감시 대상인 파일의 대기열에 배치되므로 select 호출로 블로킹되며 일시 중지된다.

읽기/쓰기 가능 이벤트가 발생하면 프로세스 또는 스레드가 깨어나는데, 어떤 파일 서술자가 이미 준비 완료 상태인지 알려면 처음부터 끝까지 다시 확인해야 하기 때문에 효율이 매우 떨어진다.

**poll**
select와 매우 유사하며, 감시 가능한 파일 서술자 수가 1024개라는 제한을 넘지 못한다는 문제를 해결했다. 

파일 서술자 수가 늘어날수록 성능이 저하되는 문제가 있으므로, 높은 동시성을 요구하는 상황에 제대로 대응이 불가능했는데 이를 해결하려고 epoll이 등장했다.

**epoll**

커널에 필요한 데이터 구조를 생성함으로써 문제를 해결했다. 감시되고 있는 파일 서술자에서 관심 이벤트가 발생하면 해당 프로세스를 깨우면서 **준비 완료된 파일 서술자** 가 준비 완료 목록에 추가됨으로써 처음~끝까지 확인할 필요가 없어진다.