# 6.3 파일을 읽을 때 프로그램에는 어떤 일이 발생할까?

## 6.3.1 메모리 관점에서 입출력

> 메모리 관점에서 입출력은 단순한 메모리의 복사(copy)다.

데이터가 외부 장치에서 메모리로 복사되는 게 입력(input), 반대로 데이터가 메모리에서 외부 장치로 복사되는 게 출력(output)이다. 즉, 메모리와 외부 장치 사이에 복사 데이터가 왔다갔다 하는 것을 입출력(in/output, I/O)이라고 한다.

## 6.3.2 read 함수는 어떻게 파일을 읽는 것일까?

```c
char buffer[LEN];

read(buffer);
```

> 순서

저수준 계층에서 시스템 호출을 이용하여 운영 체제에 파일 읽기 요청을 보낸다. 이 요청은 커널에서 디스크가 이해할 수 있는 명령어로 변환되어 디스크로 전송된다. 속도의 차이가 크기 때문에 불필요한 대기 시간을 막기 위해 **블로킹** 작업이 일어나며, 현재(A) 프로세스의 실행을 일시 중지하고 **입출력 블로킹** 대기열에 넣는다.

DMA 작동 방식을 사용하여 데이터를 특정 메모리 영역으로 복사하는 작업을 시작한다. 이 메모리 영역이 바로 read 함수를 buffer이다.

운영 체제에는 블로킹 대기열 외에도 준비 완료 대기열이 존재하는데, 이 준비 완료 대기열은 대기열 안의 프로세스가 다시 실행되는 조건이 준비되었음을 의미한다. 실행될 준비는 완료되었지만 바로 CPU에 할당되지 못하는 스레드가 있을 수 있으며, 이런 프로세스는 준비 완료 대기열에 들어간다.

A 프로세스가 블로킹 입출력 요청을 시작해서 일시 중지되더라도 CPU는 준비 완료 대기열의 다른 프로세스(B)가 대기있다면, 이를 실행하기 때문에 쉬지 않는다.

디스크가 데이터를 모두 A 프로세스의 메모리에 복사하는 작업이 완료되면, 디스크는 CPU에 인터럽트 신호를 보낸다. CPU는 인터럽트 신호를 받은 후 처리가 중단되었던 함수로 점프한다. 디스크의 입출력 처리가 완료되어 A 프로세스를 계속 실행될 수 있는 자격을 얻었음을 알게 되고, 이를 준비 완료 대기열에 넣는다.

B 프로세스를 계속 실행하다 시스템이 타이머 인터럽트 신호를 보내고 B에 할당된 시간을 모두 사용했다면, B를 준비 완료 대기열에 넣음과 동시에 A를 꺼내 CPU를 할당한다.

> 일반적으로는 입출력 데이터는 먼저 운영 체제 내부로 복사되며 이후 운영 체제가 프로세스의 주소 공간으로 복사한다.-> 계층이 하나 더 존재한다.

> 직접 데이터를 프로세스 주소 공간에 복사하는 방법을 무복사(zero-copy) 기법이라고 한다.