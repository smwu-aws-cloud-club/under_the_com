# 4.7 CPU 진화론(중): 축소 명령어 집합의 탄생

> 복잡 명령어 집합은 아직 초기 단계였던 컴파일러와 저장 장치의 용량 제한 같은 객관적인 조건으로 제한을 받음

**흐름의 변화**

1. 1980년대, 최대’ 용량이 64KB인 메모리 출현 -> 메모리 용량 대비 가격이 급격히 떨어지기 시작
2. 컴파일러에 의존하여 어셈블리어 명령어를 자동으로 생성 -> 어셈블리어로 코드를 작성하는 방식은 더 이상 의미가 없어짐

## 4.7.1 복잡함을 단순함으로

**80-20 법칙(80-20 rule)**

- 파레토 법칙(Pareto principle)
- 전체 결과의 80%가 전체 원인의 20%에서 일어난다는 법칙

**마이크로코드 설계**

- 복잡한 기계 명령어를 CPU 내부에서 비교적 간단한 기계 명령어로 변환하는 것
- 복잡 명령어 집합에서 성능을 향상시키는 것으로 여겨지는 명령어가 이에 의해 가로막힘
  - 제거 시, 프로그램이 더 빠르게 실행
  - 트랜지스터를 절약
- 컴파일러가 CPU 내부에서 실행되는 마이크로코드에 영향을 미칠 방법이 없음 => 버그가 발생해도

**추가적인 발견**

- 잡한 기계 명령어가 같은 일을 하는 간단한 명령어 여러 개보다 느리게 실행됨

## 4.7.2 축소 명령어 집합의 철학

**축소 명령어 집합(reduced instruction set)**

1. 명령어 자체의 복잡성

- 복잡한 명령어를 제거하고 대신 간단한 명령어 여러 개로 대체
- CPU 내부 마이크로코드 설계가 필요하지 않음 => 마이크로코드가 없어 CPU 제어 능력이 크게 향상
- 하나의 명령어당 들여야 하는 연산이 더 간단하다는 의미 (not 명령어 개수 ↓)

2. 컴파일러

- 컴파일러가 CPU에 대해 더 강력한 제어권을 가짐
- 축소 명령어 집합을 사용하는 CPU는 더 많은 세부 사항을 컴파일러에 제공

3. LOAD/STORE 구조

- 축소 명령어 집합의 명령어는 레지스터 내 데이터만 처리할 수 있음 (메모리 직접 접근 X)
- 복잡: 읽고 쓰기 -> 하나의 기계 명령어로 수행됨
- 축소: LOAD와 STORE라는 전용 기계 명령어가 메모리의 읽고 쓰기를 책임

## 4.7.3 복잡 명령어 집합과 축소 명령어 집합의 차이

> 가정: 두 숫자가 각각 메모리 주소 A와 주소 B에 저장됩니다. 이제 이 두 숫자를 곱한 값을 먼저 계산한 후 계산 결과를 다시 메모리 주소 A에 기록한다.

**단계**

1. 메모리 주소 A의 데이터를 읽어 레지스터에 저장합니다.
2. 메모리 주소 B의 데이터를 읽어 레지스터에 저장합니다.
3. ALU가 레지스터 값을 이용하여 곱셈 연산을 수행합니다.
4. 곱셈 결과를 다시 메모리에 씁니다.

**복잡 명령어 집합의 경우**

```
MULT A B
a = a * b
```

- 하나의 명령어 (MULT)
- 고급 언어와 기계 명령어 사이의 차이를 줄임
- 최소한의 코드로 작업을 완료하고 프로그램 자체가 차지하는 저장 공간을 절약하려는 목적

**축소 명령어 집합의 경우**

```
LOAD RA, A
LOAD RB, B
PROD RA, RB
STORE A, RA
```

- 간단한 명령어를 여러 개 사용하여 작업을 완료
- LOAD 명령어는 메모리에서 레지스터로 데이터를 적재
- PROD 명령어는 두 레지스터에 저장된 숫자의 곱셈 연산을 수행
- STORE 명령어는 레지스터의 데이터를 다시 메모리에 씀
- 복잡 명령어 집합보다 더 많은 저장 공간이 필요

## 4.7.4 명령어 파이프라인

```
LOAD RA, A
LOAD RB, B
PROD RA, RB
STORE A, RA
```

- 해석하는 데 복잡한 하드웨어 구조가 필요하지 않음 => 트랜지스터를 절약 가능
- _명령어가 매우 간단하여 실행 시간이 모두 거의 동일_

**파이프라인 기술**

- 시간은 동일
- 처리량을 늘림 => 가능한 한 파이프라인이 더 높은 효율로 기계 명령어들을 처리할 수 있도록
- 복잡 명령어 집합에서는 명령어 사이에 비교적 차이가 크기에 실행 시간이 고르지 않음 => 파이프라인 방식 효율적 활용 불가

**비교**

- 5단계 파이프라인을 기준으로 명령어 하나가 1~2클럭 주기
- 복잡 명령어 집합 프로세서는 명령어 하나를 실행하는 데 5~10클럭 주기
- 축소
  - 컴파일된 프로그램에는 더 많은 명령어가 필요,
  - 마이크로코드가 없기 때문에 더 적은 트랜지스터가 필요 => 더 작은 CPU
  - 더 높은 클럭 주파수

## 4.7.5 천하에 명성을 떨치다

- 1980년대 중반, 축소 명령어 집합을 사용하는 상용 CPU가 등장
- 다른 모든 CPU 제조업체는 축소 명령어 집합을 따름
