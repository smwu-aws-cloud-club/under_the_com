# 4.8 CPU 진화론(하): 절체절명의 위기에서 반격

> 그들을 이길 수 없다면 그들과 함께하라(If you can’t beat them, join them)

**인터페이스**

- 함수의 인터페이스가 변경되지 않는 한 함수를 사용하는 코드는 변경될 필요가 없다.
- 인터페이스에 해당하는 명령어 집합은 변경 불가
- CPU 내부 구현, 즉 명령어 실행 방식은 변경 가능

=> 마이크로 명령어 개념 제시

## 4.8.1 이길 수 없다면 함께하라: RISC와 동일한 CISC

**마이크로 명령어(micro-operation)**

- 복잡 명령어 집합의 명령어를 CPU 내부에서 축소 명령어 집합의 간단한 명령어로 변환
- 축소 명령어 집합의 간단한 명령어와 유사한 명령어들
- 매우 간단하며 실행 시간도 거의 같음 => 파이프라인 기술 활용 가능

=> 복잡 명령어 집합의 호환성을 유지하면서 동시에 축소 명령어 집합의 장점

## 4.8.2 하이퍼스레딩이라는 필살기

**하이퍼스레딩(hyper-threading)**

- = 하드웨어 스레드(hardware thread)
- CPU가 한 번에 하나의 스레드에 속한 기계 명령어만 실행 가능
- 하이퍼스레딩 기능이 탑재된 하나의 물리 CPU 코어는 운영 체제가 논리적으로 CPU 코어가 여러 개 있는 것으로 인식
- 스레드 두 개에 속하는 명령어 흐름 처리 가능
- CPU 하드웨어의 기능으로 운영 체제와는 상관 X
  - 운영체제는 소프트웨어 스레드를 생성, 스케줄링, 관리

**파이프라인 활용**

- 항상 완벽하게 채워진 상태에서 실행될 수 X -> 빈 공간 생김
- 추가 명령어 흐름을 도입하여 빈 공간을 채우면 전체 파이프라인을 채워서 실행

=> CPU 리소스 최대한 활용. 효율적!

## 4.8.3 장점은 취하고 약점은 보완하다: CISC와 RISC의 통합

> 차이가 점점 줄어든다.

**장점은 취하고 약점은 보완**
- 복잡 명령어 집합의 내부는 점점 더 축소 명령어 집합에 가까워짐
- 일부 고성능 축소 명령어 집합 구조의 CPU에 마이크로 명령어가 채용

**분명한 차이**
- 축소 명령어 집합
  - 컴파일러는 여전히 중요한 역할
  - 명령어 길이가 일정 -> 명령어 길이가 가변적인 복잡 명령어 집합에 비해 컴파일러 최적화에서 더 좋음


## 4.8.4 기술이 전부는 아니다: CISC와 RISC 간 상업적 전쟁

1. 1980~1990년대 축소 명령어 집합 사상의 출현 -> 프로세스 영역 크게 발전
2. 축소 명령어 집합 기반의 소프트웨어를 개발하여 선보일 때쯤 이미 더 빠른 x86이 나옴
3. 많은 소프트웨어가 x86 플랫폼에서 동작

=> 윈텔(WinTel) 연합이 컴퓨터 시장 점령. ARM으로 대표되는 축소 명령어 집합 진영은 임베디드와 저전력 영역으로 후퇴

1. 2007년, 아이폰(iPhone)이 출시 -> 모바일 인터넷 시대 진입
2. ARM이 모바일 시장 장악

=> 스마트폰은 거의 모두 축소 명령어 집합을 채택한 ARM의 프로세서를 탑재.