# 4.3 CPU는 숫자를 어떻게 인식할까?

## 4.3.1 숫자 0과 양의 정수

**위치 기수법(positional notation)**

- 값과 숫자의 위치가 직접적인 관계가 있다.

**2진법**

- 비트 k개를 사용하면 정수 2^k를 나타낼 수 있다.
- 범위는 0~2^k-1 (양의 정수)

## 4.3.2 부호 있는 정수

**최상위 비트(most significant bit)**

- 값이 0이면 양수, 그렇지 않으면 음수라고 정의

```
0******* 양수
1******* 음수
```

## 4.3.3 양수에 음수 기호를 붙이면 바로 대응하는 음수: 부호-크기 표현

**부호-크기 표현(sign-magnitude)**

- 인간 사고방식과 매우 유사
- 1000은 -0을 표시

## 4.3.4 부호-크기 표현의 반전: 1의 보수

**1의 보수(one’s complement)**

- 완전히 반전시킨다.
- -0은 여전히 있다.

=> 이런 표시 방식에는 두 숫자를 더할 때 공통된 문제가 발생한다.

## 4.3.5 간단하지 않은 두 수 더하기

부호-크기 표현 방식 => 모순된 결과

```
0010(2) + 1010(-2) = 1100(-4)
```

1의 보수 => 값은 우아하지는 않지만, 최소한 1의 보수 방식과 모순된 결과는 아님

```
0010(2) + 1101(-2) = 1111(-0)
```

## 4.3.6 컴퓨터 친화적 표현 방식: 2의 보수

> A + (-A) = 0 가능하고 0을 표현할 때 2진법에서 0000이라는 표현 한 가지만 존재하는 표현 방법 필요

**2의 보수**

- 계산을 수행할 때 숫자 부호에 전혀 신경 쓸 필요가 없다.
- 현대 컴퓨터 시스템에서 사용된다.
- 1의 보수로 표현한 양수에 1을 더하면 2의 보수에서 대응하는 음수가 된다.

## 4.3.7 CPU는 정말 숫자를 알고 있을까?

- 양수와 음수에 대해 전혀 신경 쓰지 않는다.
- 연속된 숫자가 가지고 있는 의미조차 이해하지 못한다.
- 두 비트의 배타적 논리합 연산이 덧셈의 결과라는 것과 두 비트의 논리곱 연산이 자리 올림수라는 것만 알고 있다.
