# 4.6 CPU 진화론(상): 복잡 명령어 집합의 탄생

## 4.6.1 프로그래머의 눈에 보이는 CPU

> 명령어는 실행 파일에 저장되며, 프로그램이 실행되면 메모리에 적재된다.

> CPU는 단순하게 메모리에서 명령어를 읽어 실행하기만 하면 됩니다.

## 4.6.2 CPU의 능력 범위: 명령어 집합

**명령어 집합(instruction set architecture)**

- 우리에게 CPU가 할 수 있는 일을 알려줌
- 프로그래밍에 사용
- 서로 다른 형태의 CPU는 다른 유형의 명령어 집합을 가지고 있다.
- CPU의 하드웨어 설계에도 영향을 미친다.

## 4.6.3 추상화: 적을수록 좋다

> **복잡 명령어 집합 컴퓨터(Complex Instruction Set Computer, CISC)**

- 직접 어셈블리어로 작성 -> 일반적으로 명령어 집합이 더욱더 풍부해야 하며 명령어 자체 기능도 더 강력해야 한다고 여겼다.
- 작업마다 대응하는 특정 명령어가 있는 것이 가장 합리적

**간격(semantic gap)**

- 고급 언어의 개념과 이에 직접 대응하는 기계 명령어가 있어야 한다고 생각했
- 기계 명령어와 고급 언어 개념 간 차이를 줄여야만 더 적은 코드로 더 많은 작업을 할 수 있었기 때문

## 4.6.4 코드도 저장 공간을 차지한다

**폰 노이만 구조(Von Neumann architecture)**

- 저장 개념에서 프로그램과 프로그램이 사용하는 데이터에 어떤 차이도 없어야 하며, 모두 컴퓨터의 저장 장치 안에 저장될 수 있어야 한다.
- 실행 파일은 기계 명령어와 데이터를 모두 포함하고 있다
- 코드는 디스크 저장 공간을 차지하며 실행 시에는 메모리에 적재되므로 메모리 저장 공간을 차지한다.

**프로그램이 차지하는 저장 공간을 줄이기**

1. 하나의 기계 명령어로 더 많은 작업을 완료할 수 있다.
2. 기계 명령어 길이가 고정되어 있지 않다. 가변적이다.
3. 기계 명령어는 밀도를 높여 공간을 절약하려고 고도로 인코딩(encoding)된다.

## 4.6.5 필연적인 복잡 명령어 집합의 탄생

> 사용한 편리한 프로그램을 작성하고 코드의 저장 공간을 절약해야 했기에 복잡 명령어 집합을 설계해야 하는 필요성이 대두되었다.

**직접 연결(hardwired) 방식**

- 명령어를 실행하는 데는 매우 효율적
- 유연성이 몹시 떨어지기 때문에 명령어 집합의 변경에 대응하기가 어렵다.

=> 하드웨어를 변경하는 것은 매우 번거롭지만, 소프트웨어는 변경이 쉽다.

## 4.6.6 마이크로코드 설계의 문제점

**마이크로코드(microcode)**

- 복잡 명령어 집합으로 발생하는 프로세서 설계의 복잡한 문제를 단순화
- 소프트웨어가 하드웨어를 대체
- 단, 마이크로코드 설계가 트랜지스터를 매우 많이 소모
- 마이크로코드가 야기한 복잡한 문제는 해결하기가 매우 어려우며, 마이크로코드 자체가 해결해야 하는 대상
