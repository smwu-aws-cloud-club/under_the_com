# 4.4 CPU가 if 문을 만났을 때

> 분기 예측 실패율을 나타내는 branch-misses 항목

## 4.4.1 파이프라인 기술의 탄생

1. 발명: 조사이아 웨지우드 - 공정 단계를 수십 개로 나누고 각 단계마다 전문가를 배치
2. 발전: 헨리 포드 - 조립 라인 기술을 자동차 대량 생산에 적용

=> 단계를 전담하는 팀에 넘기며 조립

**파이프 라인**
X: 전체 조립 시간을 줄이는 것
O: 처리 능력을 늘리는 것

## 4.4.2 CPU: 메가팩토리와 파이프라인

**CPU, 메가팩토리(megafactory)**

- 기계 명령어를 실행
  - 명령어 인출(instruction fetch)
  - 명령어 해독(instruction decode)
  - 실행(execute)
  - 다시 쓰기(writeback)
- 각 단계는 별도의 하드웨어로 처리

## 4.4.3 if가 파이프라인을 만나면

**if 문**

- 일반적으로 컴파일러가 조건부 점프 명령어로 변환
- 분기 역할을 한다.
- 조건이 참이면 점프해야 하고, 그렇지 않으면 순차적으로 실행

**예측**

- 분기 점프 명령어가 실행을 완료하기 전에 다음 명령어는 이미 파이프라인에 들어가 있어야 함
- 빈 공간이 생기면 프로세서의 리소스를 완전하게 사용할 수 없기 때문
- 실행 결과에 따라 점프 여부를 결정 -> 명령어 실행이 완료되지 않은 시점에 CPU는 어떤 분기의 명령어를 파이프라인에 넣어야 할지 결정 => 예측

## 4.4.4 분기 예측: 가능한 한 CPU가 올바르게 추측하도록

**분기 예측**
- 분기할 가능성이 있는지 추측
- 추측이 맞았다면 파이프라인은 계속 진행
- 추측이 틀렸다면 파이프라인에서 이미 실행 중이던 잘못된 분기 명령어 전부를 무효화
- CPU 추측이 틀리면 바로 성능 손실이 발생
- 프로그램 실행 이력을 기반으로 예측을 실행하는 등 여러 가지 데이터를 기반으로 진행

- 무작위 이벤트에 대응하기 어려움
 - 따라서, 정렬되지 않는 배열을 사용하면 분기 예측 실패율이 매우 높아지고 프로그램 성능이 떨어짐

 **likely/unlikely 매크로(macro)**
- 컴파일러에 가능성이 더 높은 분기를 알려 줄 수 있다.
- 이렇게 하면 컴파일러는 더 목적성을 가지고 최적화 가능

**분석 도구 (e.g. perf)**
- 분기 예측이 성능 병목 현상의 원인은 아닌지 확인
