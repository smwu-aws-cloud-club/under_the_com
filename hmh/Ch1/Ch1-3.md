# 1.3 링커의 말할 수 없는 비밀

<br/>

## 1.3.1 링커는 이렇게 일한다

**링커**

- 컴파일러가 생성한 대상 파일 여러 개를 하나로 묶어 하나의 최종 실행 파일을 생성

**링커의 동작 원리**

- 인터페이스 구현이 종속된 모듈에서 사용 가능한지 확인 → 연결 = 심벌 해석`symbol resoultion`
- 어느 메모리 주소에 위차할지 정확히 알 수 없음 → 임의로 써놓고 실행 파일을 생성하는 과정에서 정확한 주소 확인 후 대체

<br/>

## 1.3.2 심벌 해석: 수요와 공급

<img src="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FThKDq%2FbtsJNhWT83w%2FsIbZbQAd37W1c5pt8Fd0g0%2Fimg.png"><br/>

**심벌**

- 전역 변수와 함수의 이름을 포함하는 모든 변수 이름(지역변수 X)
- 링커는 대상 정의의 (1)존재 여부와 (2)단 하나만 존재하는지 확인
  - 컴파일러가 선언의 존재 여부 알려줌. 검사는 링커 몫
  - 명령어 부분
    - 소스 파일에 정의된 함수에서 변환된 기계 명령어가 저장되는 부분
    - 코드 영역 `code section`
  - 데이터 부분
    - 소스 파일의 전역 변수가 저장되는 부분
    - 데이터 영역 `data section`
  - 심벌 테이블
    - 컴파일러가 외부 심벌 정보를 기록하는 표
    - 공급/수요 2가지 내용만 표현
    - 내가 정의한 심벌(다른 모듈에서 사용 가능) / 내가 사용하는 외부 심벌 ⇒ 링커가 공급이 수요를 충족하는지 확인<br/>
      > 공급이 수요를 초과할 수 있지만, 수요가 공급을 초과할 수 없음

<br/>

## 1.3.3 정적 라이브러리, 동적 라이브러리, 실행 파일

**정적 라이브러리**<br/>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKzmP4%2FbtsIlBcGRV8%2FlZtszqVftO2r7FnFQGPQtk%2Fimg.png" width="500">

- 코드를 별도로 컴파일 한 후 링크하여 하나의 정적 라이브러리 생성
- 소스 파일마다 단독으로 컴파일을 해야 함
- 확장자: 보통 .a (리눅스/유닉스 계열) 또는 .lib (윈도우즈 계열).
- 다시 컴파일할 필요 없이 링크 과정에서 그대로 실행 파일에 복제됨 → 컴파일 속도 ↑

<br/>

**정적 링크**
- 컴파일 과정에서 프로그램의 실행 파일에 필요한 라이브러리의 코드가 정적으로 포함되는 과정
- 정적 라이브러리가 사용됨
- 대상 파일을 한데 모아 각각의 대상 파일에서 데이터 영역과 코드 영역을 각각 결합
- 실행 파일은 특수 심벌 `_start`가 존재
- 직접 복사 → 중복된 데이터, 종속성 문제 발생
<br/><br/>

**동적 라이브러리**

- 공유 라이브러리`shared library` 또는 동적 링크 라이브러리`dynamic linked library`
- 리눅스에서 .so 확장자, 접두사로 lib 사용 (ex. libMath.so)
  ```
  // 동적 라이브러리 생성
  $ gcc -shared -fPIC -o libfoo.so a.c b.c
  ```
- 필수 정보만 실행 파일에 포함 → 정적 라이브러리에 비해 실행 파일의 크기를 줄임
- 참조된 동적 라이브러리 필수 정보는 실행 파일 내 저장됨

  |                     |
  | ------------------- |
  | 코드 영역           |
  | 데이터 영역         |
  | 동적 링크 관련 정보 |

<br/>

**필수 정보 사용 시점**
- 동적 링크가 일어날 때 → 실제 프로그램의 실행까지 미룸
- 프로그램이 메모리에 적재loading 될 때 동적 링크 진행
  - 적재 = 실행 파일을 실행하기 위해 디스크에서 읽어 메모리의 특정 영역으로 이동시키는 과정
  - 적재 도구loader 라는 전용 프로세스 실행
  - 의존 여부 확인 후 동적 링커 프로세스가 라이브러리존재 여부, 위치, 심벌 메모리 위치 등을 확인해 마무리
  - 적재 중 동적 링크를 사용하려면 컴파일러에 명시적으로 알려주어야 함 (gcc 명령어 참조)
- 프로그램의 실행 시간runtime 동안 코드가 직접 동적 링크를 실행
  - 링크 과정을 프로그램이 실행된 이후로 미룸
  - 실행 파일을 생성하는 과정에서 실행 파일 내부에 동적 라이브러리 정보가 저장되지 않음
  - 프로그래머가 특정 API를 사용해 필요할 때마다 직접 적재할 수 있음 (ex. dleopen, dlsym, dlclose)

<br/>

## 1.3.4 동적 라이브러리의 장단점
**장점**
- 디스크 저장에 필요한 리소스 절약 
- 동적 라이브러리만 다시 컴파일하면 됨
- 플러그인을 활용한 기능 확장이 쉬움 
- 하나의 프로젝트에서 여러 언어를 혼합하여 개발할 수 있음
- 재사용 효율 높음

**단점**
- 정적 링크를 사용할 때보다 성능이 약간 떨어짐
  - 주소 독립적이기 때문에 간접적인 접근 필요 → 성능 손실보다 더 큰 가치
- 동적 링크를 수행하는 프로그램은 실행 파일만으로는 실행이 불가능
  - 종속된 동적 라이브러리를 제공하지 않거나 호환되지 않으면 프로그램 실행 X

<br/>

## 1.3.5 재배치: 심벌의 실행 시 주소 결정하기
- 컴파일러는 대상 파일을 생성할 때 함수가 어느 메모리 주소에 적재될지 모름
  - 호출한다는 사실만 기록 → `call 0x00`
  - 해당 정보는 .relo.text(명령어), .relo.data(명령어와 관련된 데이터)에 기록됨
  <br/>
  <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fdey8ZA%2FbtsJLgMlVcm%2FGToZgEDNOrf3fw6R6Yntrk%2Fimg.png" width="200">
- 심벌 해석 단계. 이를 거치면 링크 과정에 오류가 없다고 확신할 수 있음
  - 동일한 유형의 영역끼리 병합하는 과정
- 각 유형의 영역이 모두 결합되면 모든 기계 명령어와 전역 변수가 프로그램 실행 시간에 위치할 메모리 주소를 결정할 수 있음<br/>

**재배치 relocation**
- 심벌의 메모리 주소를 수정하는 과정

<br/>

## 1.3.6 가상 메모리와 프로그램 메모리 구조
<img src="https://blog.kakaocdn.net/dn/my6pd/btrkuF297rS/FTYj1LeCuUDOkTX5pArhc1/img.png" width="500"> <br>
- 프로그램 실행 → 프로그램 프로세스에 메모리 적재되는 모습을 보여줌
- malloc 함수가 힙 영역에서 메모리 할당 받음
- 데이터 영역과 코드 영역은 실행 파일의 내용이 적재됨
<br/><br/>

**가상 메모리**
- 물리적으로 존재하지 않는 가짜 메모리
- 모든 메모리를 독점적으로 사용하는 것처럼 행동
  - 따라서 CPU가 A를 실행할 때 메모리 주소 0x400000에서 가져온 명령어≠B를 실행할 때 메모리 주소 0x400000에서 가져온 명령어
- 동일한 표준적인 메모리 주소를 가질 수 있는 이유
- 실행 파일 생성 후 실행 시 메모리 주소를 결정할 수 있는 이유 → 실행 여부와 관계 없이 프로세스 메모리 구조를 알고 있기 때문
- 코드 영역은 언제나 메모리 주소 0x400000에서 시작
- 스택 영역은 항상 메모리의 상위 주소에 위치
- 실제로 물리 메모리 어디에 위치하는지 신경 쓰지 X

<br/><br/>

**물리 메모리를 찾는 법**
- 사상mapping 관계 추가
- 메모리 페이지 단위로 관리됨
- 페이지 테이블: 사상 관계를 기록한 표<br/>
  <img src="https://images.velog.io/images/thdalstn6352/post/46720088-dbcb-444f-a4a3-0b2de9d6371d/image.png"><br/>

- 가상 메모리는 표준화 되어 있고 크기 동일. 영역이 배치되는 순서 동일
- 물리 메모리의 크기는 가상 메모리의 크기와는 무관
- 프로세스는 자신만의 페이지 테이블을 가지며 같은 가상 메모리 주소도 서로 다른 물리 메모리 주소를 획득

