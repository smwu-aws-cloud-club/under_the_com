# 1.1 여러분이 프로그래밍 언어를 발명한다면?
: 쉽고 재미있게 이야기하며 간단히 알아보는 내용

> 프로그래밍 언어는 어떻게 만들었을까? <br />
> 실행 파일은 왜 실행될 수 있을까? <br />
> 실행 파일은 어떤 형태로 어떻게 실행될까? <br />
> 실행되고 나면 어떤 형태를 갖출까? <br />
> 어떻게 하면 더 효율적으로 실행할 수 있을까? <br />


- **나온 개념**
  - CPU
  - 어셈블리어
  - 저수준언어
  - 구문 트리
  - 이진 트리
  - 컴파일러
  - 해석형 언어 인터프리터
<br/>

## 1.1.1 창세기: CPU는 똑똑한 바보
- 0과 1로 소통하는 CPU
- 초기에는 프로그래머들이 CPU 관점에서 코드를 작성
<br/>

## 1.1.2 어셈블리어의 등장
- 기계어와 해당 특정 작업을 간단하게 대응시킴
- 기계어를 인간이 읽고 이해할 수 있는 단어와 대응시킴
<br/>

## 1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화
> 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동 변환할 수 없을까?
- 저수준 언어 → 모든 세부 사항에 신경 써야 함
<br/>

## 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작
- 문장`statement`로 명령을 내림
- 동일한 동작에 다른 매개변수`parameter`를 넣어 다른 출력을 만듦
- 매개변수를 제외한 나머지 명령어를 묶어 코드로 지정해 함수`function` 생성
<br/>

## 1.1.5 <인셉션>과 재귀: 코드 본질
- 단계별로 계속 중첩되는 코드 → 재귀문으로 나타냄
<br/>

## 1.1.6 컴퓨터가 재귀를 이해하도록 만들기
- 재귀를 트리`tree` 구조로 표현
- 구문 트리
<br/>

## 1.1.7 우수한 번역가: 컴파일러
- 리프 노드에 적용 → 부모 노드에 적용 → 반복 → 루트 노드까지 적용
- 해당 과정을 거치면서 기계어를 생성
<br/>

## 1.1.8 해석형 언어의 탄생
> 가능한 많은 플랫폼에서 실행됐으면 좋겠지만 다시 컴파일 하고 싶진 않아
- 표준 명령어 집합을 정의 → CPU의 기계 실행 과정을 모방하는 프로그램 작성
- 각 CPU마다 상응하는 프로그램을 준비하면 서로 다른 플랫폼에서 실행 가능
- CPU 시뮬레이션 프로그램 → 인터프리터`interpreter`