# 1.2 컴파일러는 어떻게 작동하는 것일까?
![image](https://github.com/user-attachments/assets/db77a11b-20f4-4e3d-abd6-52d3aac28310)

## 1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다.
- 컴파일러: 고수준 언어를 저수준 언어로 번역하는 프로그램
- 소스 파일: 일반적인 텍스트 형태로 작성된 코드 파일
> 컴파일러는 소스 파일을 CPU가 실행할 수 있는 기계 명령어 파일로 변환
<br/>

## 1.2.2 각각의 토큰 추출하기
- 토큰 추출 = 항목 쪼개기
  ```
  int a = 1;
  ```
  ```
  // 토큰 의미    토큰이 가지는 값
  T_keyword      int
  T_Identifier    a
  T_Assign        =
  T_Int           1
  T_Semicolon     ;
  ...
  ```

## 1.2.3 토큰이 표현하고자 하는 의미
- 해석 `parsing` 과정을 거쳐 처리
- while 키워드 토큰 다음 토큰이 while 키워드에 필요한 토큰이 아니라면? <br/>
  → 문법 오류 `syntax error` 발생!
- 구문에 따라 해석해 낸 구조는 구문 트리로 표현하는 것이 가장 좋음 <br/>
  → 구문 분석 = 트리를 생성하는 전체 과정
<br/>

## 1.2.4 생성된 구문 트리에 이상은 없을까?
- 의미 분석`semantic analysis`: 구문 트리에 이상이 없는지 확인하고 통과 시 컴파일 오류가 없다는 것이 증명됨
 <br/>

## 1.2.5 구문 트리를 기반으로 중간 코드 생성하기
- 의미 분석이 끝난 후 컴파일러는 구문 트리를 탐색한 바탕으로 좀 더 다듬어진 형태인 중간 코드 `Intermediate Representation code, IR Code`를 생성
  ```
    a = 1
    b = 2
    goto B
  A: b = b -1
  B: if a < b goto A
  ```

## 1.2.6 코드 생성
- 컴파일러는 앞의 중간 코드를 어셈블리어 코드로 변환
  ```
    movl   $0x1, -0x4(%rbp) // a = 1
    ...
  A: subl  $0x1, -0x8(%rbp) // b = b - 1
  B: mov   -0x4(%rbp),%eax
  ...
  ```
- 마지막으로 어셈블리어를 기계 명령어로 변환
- 대상 파일`obejct file`: .o 확장자를 가지는 파일
- 모든 소스 파일에는 각각의 대상 파일이 있음 → 대상 파일을 하나의 실행 파일로 합쳐주는 것이 필요
- 링크`link`: 대상 파일을 병합하는 작업 → 링커`linker`는 링크 담당 프로그램
