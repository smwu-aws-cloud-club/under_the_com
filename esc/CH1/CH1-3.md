# 1.3 링커의 말할 수 없는 비밀

일반적으로 외부 코드는 정적 라이브러리 혹은 동적 라이브러리 형태로 제공된다.<br>
이런 라이브러리를 어떻게 내 코드에 적용할 수 있을까?<br>

## 1.3.1 링커는 이렇게 일한다

링커는 컴파일러가 생성한 대상 파일 여러 개를 하나로 묶어 하나의 최종 실행 파일을 생성한다.<br>
이때 코드에서 재배치가 일어난다.<br>
특정 소스 파일에서 다른 모듈에 정의되어 있는 함수를 참조할 때, 컴파일러가 이 소스 파일을 컴파일하는 시점에는 함수가 어느 메모리 주소에 위치할지 정확히 알 수 없다.<br>
컴파일러는 이 함수를 N으로 표시해 두고, 이후 링커가 실행 파일을 생성하는 과정에서 함수의 정확한 주소를 확인하고, N을 실제 메모리 주소로 대체한다.<br>

## 1.3.2 심벌 해석: 수요와 공급

심벌: 전역 변수와 함수의 이름을 포함하는 모든 변수 이름<br>
지역 변수는 모듈 내에서만 사용되어 외부 모듈에서 참조할 수 없기 때문에 링커의 대상이 아니다.<br>
이 단계에서 링커는 대상 파일에 참조하고 있는 각각의 모든 외부 심벌이 대상 정의가 반드시 존재하는지, 단 하나만 존재하는지 확인한다.<br><br>

컴파일러가 기계 명령어를 생성할 때, 이 명령어를 실행시키기 위한 데이터도 생성한다.<br>
이 데이터는 대상 파일에 반드시 포함되어야 하며 명령어 부분과 데이터 부분으로 구성된다.<br>
- 명령어 부분: 기계 명령어가 저장되는 부분, 코드 영역
- 데이터 부분: 전역 변수가 저장되는 부분, 데이터 영역 <br>

컴파일러는 외부 심벌 정보를 기록하는 **심벌 테이블**을 작성한다.<br>
- 공급 - 내가 정의한 심벌, 즉 다른 모듈에서 사용할 수 있는 심벌
- 수요 - 내가 사용하는 외부 심벌
심벌 테이블은 대상 파일에 저장된다.<br>
링커는 공급이 수요를 충족하는지 확인하기 위해 심벌 테이블로 심벌을 해석한다.<br>
공급이 수요를 초과할 수는 있으나 수요가 공급을 초과하면 ```undefined reference``` 오류가 발생한다.<br>

## 1.3.3 정적 라이브러리, 동적 라이브러리, 실행 파일

정적 라이브러리: 코드를 별도로 컴파일한 후 패키지로 묶고(링크), 구현된 모든 함수의 선언을 포함하는 헤더 파일을 제공<br>
정적 링크: 대상 파일을 한데 모아 각각의 대상 파일에서 데이터 영역과 코드 영역을 각각 결합<br>
소스 파일마다 단독으로 컴파일을 한다.<br>
이후 실행 파일을 생성할 때 컴파일이 완료된 정적 라이브러리는 다시 컴파일할 필요 없이 링크 과정에서 그대로 실행 파일에 복제되어 컴파일 속도가 빨라진다.<br>
실행 파일에는 ```_start``` 심벌 주소에서 프로그램을 실행하는 데 필요한 기계 명령어가 존재하며, 이 명령어를 실행한 후 main 함수가 실행된다.<br><br>

정적 링크는 라이브러리를 실행 파일에 직접 복사하기 때문에 많은 프로그램에 적용될수록 디스크와 메모리를 낭비하게 된다.<br>
이 문제를 해결하기 위해 **동적 라이브러리**를 사용할 수 있다.<br>
정적 라이브러리는 코드 영역과 데이터 영역을 모두 한데 묶어 실행 파일에 복사한다.<br>
동적 라이브러리는 동적 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보말 실행 파일에 포함시켜 실행 파일의 크기를 줄인다.<br>
참조된 동적 라이브러리 파일의 필수 정보는 실행 파일 내에 저장된다.<br>
이 필수 정보는 동적 링크가 일어날 때 사용된다.<br><br>

동적 링크에는 두 가지 방식이 있다.<br><br>

첫 번째 방식은 **프로그램이 메모리에 적재될 때 동적 링크를 진행**하는 것이다.<br>
적재: 실행 파일을 실행하기 위해 디스크에서 읽어 메모리의 특정 영역으로 이동시키는 과정<br>
실행 파일을 적재하고 나면 적재 도구는 실행 파일이 동적 라이브러리에 의존하는지 확인하고, 필요하다면 동적 링커를 실행해 참조하는 동적 라이브러리 존재 여부와 위치, 심벌의 메모리 위치 등을 확인하여 링크 과정을 마무리한다.<br>
동적 링크 과정이 정상적으로 완료되고 나면 프로그램이 시작된다.<br>
적재 중 동적 링크를 사용하기 위해서는 실행 파일이 어떤 동적 라이브러리를 참조하는지 컴파일러에 명시적으로 알려 줘야 한다.<br><br>

두 번째 방식은 프로그램이 먼저 실행된 후, **프로그램의 실행 시간(runtime) 동안 코드가 직접 동적 링크를 실행**하는 것이다.<br>
실행 시간: CPU가 프로그램을 실행하기 시작한 시점 ~ 실행이 완료되어 프로그램이 종료된 시점<br>
이 방식에서는 실행 파일을 생성하는 과정에서 실행 파일 내부에 동적 라이브러리 정보가 저장되지 않는다.<br>
그 대신 프로그래머가 코드에 특정 API를 사용하여 필요할 때마다 동적 라이브러리를 직접 동적으로 적재할 수 있다.<br>

## 1.3.4 동적 라이브러리의 장단점

동적 라이브러리를 사용하면 의존하는 프로그램의 개수에 상관없이 동적 라이브러리의 복사본 하나만 저장된다.<br>
마찬가지로 메모리에 적재되는 동적 라이브러리의 코드 역시 모든 프로세스가 하나의 코드를 공유한다.<br>
따라서 메모리 적재와 디스크 저장에 필요한 **리소스를 대폭 절약**할 수 있다.<br><br>

또한 동적 라이브러리 파일의 코드가 수정될 때 해당 동적 라이브러리만 다시 컴파일하면 된다.<br>
따라서 **프로그램 업그레이드와 버그 수정이 매우 간편**하다.<br><br>

동적 링크는 프로그램 실행 시간에도 발생할 수 있다.
이 방식을 이용해 플러그인에 필요한 함수들을 구현해두고, 프로그램 실행 시간에 플러그인을 적재하여 프로그램이 사용할 수 있도록 하여 **플러그인 구현**을 할 수 있다.<br><br>

동적 라이브러리는 **여러 언어를 혼합하여 개발**할 때도 사용된다.<br>
높은 성능이 요구되는 부분은 C로 작성하여 컴파일한 뒤 동적 라이브러리를 생성하고, 나머지 부분은 파이썬으로 작성하여 파이썬에서 C언어 동적 라이브러리로 함수를 호출해 언어를 혼합한 개발을 할 수 있다.<br><br>

동적 라이브러리는 프로그램이 적재되는 시간 또는 실행 시간에 링크되기 때문에 동적 링크를 사용하는 프로그램은 정적 링크를 사용할 때보다 **성능이 약간 떨어**진다.<br>
또한 동적 라이브러리는 메모리에 단 하나의 복사본만 존재하고 해당 코드는 여러 프로세스가 공유할 수 있기 때문에 동적 라이브러리 코드는 임의의 **메모리 절대 주소로 참조할 수 없다.**<br>
동적 라이브러리는 다른 프로세스를 통해 적재되고 나면 서로 다른 주소 공간을 가지게 되기 때문이다.<br>
적재할 때 동적 링크를 수행하는 프로그램은 종속된 동적 라이브러리를 제공하지 않거나 그 버전이 호환되지 않을 경우 프로그램 실행이 불가하므로 **동적 라이브러리 종속성** 문제가 발생할 수 있다.<br>

## 1.3.5 재배치: 심벌의 실행 시 주소 결정하기

링커가 실행 파일을 생성할 때 프로그램이 실행되는 시점에 함수가 적재될 메모리 주소를 확정해야 한다.<br>
컴파일러는 컴파일을 통해 대상 파일을 생성할 때 메모리 주소를 알 수 없어 ```0x00```로 지정한다.<br>
그리고 메모리 주소를 확정할 수 없는 변수를 발견할 때마다 ```relo.text```에 ```foo 60```과 같이 해당 명령어와 시작 지점으로부터의 주소를 저장하고 ```relo.data```에는 해당 명령어와 관련된 데이터를 저장한다.<br><br>

링커가 심벌 해석 단계에서 대상 파일의 동일한 유형의 영역끼리 병합을 완료하면 모든 기계 명령어와 전역 변수가 프로그램 실행 시간에 위치할 메모리 주소를 결정할 수 있다.<br>
링커는 ```relo.text``` 영역(segment)를 하나씩 읽어 심벌(명령어)와 위치(시작 지점 기준)을 확인하여 명령어를 찾고, 이동할 소스 주소를 수정한다.<br>
이와 같이 심벌의 메모리 주소를 수정하는 과정을 **재배치**라고 한다.<br><br>

변수나 명령어의 메모리 주소는 프로그램이 실행될 때마다 변경되기 때문에 실제로 그 시점이 되어야 알 수 있다고 생각할 수 있다.<br>
이 문제를 해결하기 위해 가상 메모리가 탄생했다.<br>

## 1.3.6 가상 메모리와 프로그램 메모리 구조

C언어를 공부하다 보면 다음과 같은 C언어 메모리 구조를 볼 수 있다.
![C언어 메모리 구조](https://user-images.githubusercontent.com/29933947/35561457-b6c8267c-05f3-11e8-8f74-c13644e5012b.png)

