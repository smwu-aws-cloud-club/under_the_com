# 1.1 여러분이 프로그래밍 언어를 발명한다면?

## 1.1.1 창세기: CPU는 똑똑한 바보

CPU는 데이터를 한 곳에서 다른 곳으로 옮기고 간단히 연산한 후 다시 그 데이터를 또 다른 자리르 옮기는 작업 외에는 할 줄 모른다. <br>
CPU의 가장 큰 장점은 엄청나게 빠르다는 것이다.<br>
프로그래머가 CPU와 소통하기 위해 작성한 0과 1로 구성된 명령어 = 코드 = 소스<br>

## 1.1.2 어셈블리어 등장

어셈블리어: CPU가 실행할 수 있는 가산 명령어, 점프 명령어 등을 기계어와 대응시켜 기계어를 인간이 읽고 이해할 수 있는 단어와 대응시킨 것<br>
처음으로 인간이 직접 인식할 수 있는 프로그래밍 언어 <br>

## 1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화

어셈블리어는 기계어와 마찬가지로 저수준 언어이므로 모든 세부 사항에 신경을 써야 한다.<br>
이는 "앞으로 한 발짝 움직여" 를<br>
"오른쪽 다리를 든다 -> 오른쪽 무릎을 굽힌다 -> 오른쪽 다리를 앞으로 내딛는다 -> 오른쪽 무릎을 편다"로 작성하는 것과 마찬가지이다.<br>
인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 자동으로 변환할 수 있는 방법이 있다면 프로그래밍 생산성을 획기적으로 높일 수 있을 것이다.<br>

## 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작

CPU에 특정 작업을 수행하라고 단도직입적으로 말하는 명령어에 **문**이라는 이름을 붙였다.<br>
- if문 - 조건문
- while문 - 반복문
- 매개변수 - 세부 사항과 함수 분리 <br>
이제 문 안에 들어갈 내용과, 인간이 인식할 수 있는 문자열을 CPU가 인식할 수 있는 기계 명령어로 변환하는 문제를 해결해야 한다.<br>

## 1.1.5 <인셉션>과 재귀: 코드 본질

문 안에 문이 들어가는, 단계 안에 단계가 포함되는 관계가 끝없이 이어지는 문제가 발생한다.<br>
이렇게 끝없이 중첩된 것처럼 보이는 것도 재귀로 표현이 가능하다.<br>
이를 **구문**이라고 부른다.<br>

## 1.1.6 컴퓨터가 재귀를 이해하도록 만들기

컴퓨터가 재귀 구문으로 표현된 문자열을 인식하려면 어떻게 해야 할까?<br>
재귀 구문에 따라 작성된 코드를 트리 구조로 표현할 수 있다.<br>

## 1.1.7 우수한 번역가: 컴파일러

구문 정의에 따라 트리 형태로 코드를 구성하게 되어 트리의 리프 노드 표현이 매우 간단해져 기계 명령어로 번역할 수 있게 되었다.<br>
이 작업을 담당하는 프로그램을 컴파일러라고 부른다.<br>

## 1.1.8 해석형 언어의 탄생

형식이 다른 CPU는 각각 자신만의 고유한 언어가 있다. (x86, ARM 등...)<br>
이를 해결하기 위해 표준 명령어 집합을 정의해서 CPU의 기계 명령어 실행 과정을 모방하는 프로그램을 작성하여 사용한다.<br>
이 CPU 시뮬레이션 프로그램 가상 머신을 인터프리터라고 부른다.<br>