# 3.1 메모리의 본질, 포인터와 참조

## 3.1.1 메모리의 본질은 무엇일까? 사물함, 비트, 바이트, 객체

메모리 셀에는 1비트(0과 1)만 보관할 수 있다.<br>
1비트로는 참(true) 또는 거짓(false)와 같은 대비되는 두 가지 정보만 표현할 수 있다.<br>
많은 정보를 표현하려면 더 많은 비트가 필요하므로 비트 여덟 개를 묶어 정보를 나타내는 하나의 단위인 1바이트(byte)를 사용한다.<br>
바이트의 메모리 내 주소를 일반적으로 메모리 주소라고 하고, 메모리 주소를 사용하여 셀을 찾는 것을 주소 지정이라고 한다.<br><br>

8비트로 만들 수 있는 조합은 256(2^8)개 뿐이므로 부호 없는 정수(unsigned integer)로 표현하면 0 - 255만 표현 가능하다.<br>
따라서 일반적으로 4바이트(32비트)를 묶어 하나의 **정수**를 표현하는 단위로 사용한다.<br>
**정보 조합**을 표현하기 위해서는 12바이트를 사용하며, 이를 구조체 또는 객체라고 표현한다.<br>

## 3.1.2 메모리에서 변수로: 변수의 의미

우리에게 8바이트에 불과한 아주 작은 메모리가 주어졌다고 가정하자.
- 사용 가능한 고급 프로그래밍 언어가 없다. = 메모리 읽기와 쓰기의 본질을 직접 마주해야 한다.
- 조작 가능한 데이터 단위는 바이트이다.<br><br>

메모리 읽기와 쓰기의 본질은, 메모리는 셀이라는 사실을 인지하고 있어야 한다.<br>
1바이트를 저장할 수 있는 셀 8개가 하나로 묶여 있고, 각 셀에는 각각 하나씩 번호(메모리 주소)가 붙어 있다.<br>
여기서 1 + 2 값을 계산하려면 먼저 숫자 1과 2를 메모리에 저장해야 한다.<br>
CPU는 메모리에서 값을 읽어 레지스터에 저장해야 연산을 수행할 수 있기 때문이다.<br>
따라서 `store $1 6`, `load r1 6`처럼 $는 값, 숫자는 메모리 주소, r은 레지스터를 의미한다.<br>
`store $1 6`에서 주소 6에 저장하는 숫자 1에 a라는 이름을 붙인다면 **a 변수가 나타내는 숫자 1이 메모리 주소 6에 저장되어 있다**는 의미가 된다.<br>

## 3.1.3 변수에서 포인터로: 포인터 이해하기

메모리 주소만 알고 있으면 변수의 데이터를 찾을 수 있고, 이는 해당 데이터가 차지하고 있는 메모리 공간 크기와는 무관하다.<br>
이때 데이터의 복사본을 만드는 대신 복사하고 싶은 데이터의 주소를 저장해 메모리를 절약할 수 있다.<br>
**포인터**는 메모리 주소를 더 높은 수준으로 추상화한 것이다.<br><br>

`load r1 1`이라는 명령어는 메모리 주소 1에 저장된 값을 r1 레지스터에 적재한다.<br>
`load r1 @1`이라는 명령어는 메모리 주소 1에 저장된 값을 읽어 이를 메모리 주소로 해석한 후 해당 메모리 주소가 가리키는 값을 진짜 데이터로 간주한다.<br>
이를 **간접 주소 지정**이라고 하며, 어셈블리어에는 변수라는 개념이 없기 때문에 필수적으로 알아야 한다.<br>
고급 언어는 변수 개념이 있으므로 굳이 간접 주소 지정을 고려할 필요가 없다.<br>
포인터는 간접 주소 지정을 감싸기 위해 추상화를 했기 때문에 더 높은 수준의 추상화라고 일컫는다.<br>

## 3.1.4 포인터의 힘과 파괴력: 능력과 책임

포인터 개념이 있으면 프로그래머는 메모리 같은 하드웨어를 직접 조작할 수 있지만, 포인터 개념이 없는 프로그래밍 언어에서는 이런 작업이 불가능하다.<br>
이것이 포인터가 있는 C언어가 저수준 계층을 제어하는 강력한 힘을 가진 이유이자 C언어가 시스템 프로그래밍에 가장 먼저 선택되는 중요 원인이기도 하다.<br><br>

포인터가 있는 언어에서 변수는 구체적으로 메모리의 어느 위치에 저장되어 있는지 직접 확인할 수 있을 정도로 뚜렷한 개념이 된다.<br>
이는 모든 추상화를 우회하여 직접 메모리를 읽고 쓸 수 있는 반면에 포인터 연산에 오류가 있을 때는 프로그램 실행 상태를 직접 파괴해 버릴 수 있다는 것을 의미하기도 한다.<br>
포인터는 메모리를 직접 조작할 수 있는 능력을 부여함과 동시에 포인터를 조작할 때는 실수하지 않아야 한다는 더 높은 기준을 요구한다.<br>

## 3.1.5 포인터에서 참조로: 메모리 주소 감추기

참조를 사용할 때는 변수의 구체적인 메모리 주소를 얻을 수 없으며, 참조는 포인터와 유사한 구조의 산술 연산을 할 수 없다.<br>
또한 데이터를 복사할 필요가 없기 때문에 포인터를 사용할 때와 동일한 효과를 얻을 수 있다.<br>
간단히 요약하면, 포인터는 메모리 주소를 추상화한 것이고 참조는 포인터를 한 번 더 추상화한 것이다.<br><br>

메모리 자체는 더 추상화될 수 있다. 바로 **가상 메모리**이다.<br>
가상 메모리를 지원하는 시스템에서 프로세스가 사용하는 메모리 주소는 사실 가상 메모리이다.<br>