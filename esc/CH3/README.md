# 3. 저수준 계층? 메모리라는 사물함에서부터 시작해 보자.

## 3.1 메모리의 본질, 포인터와 참조

메모리 셀에는 1비트(0과 1)만 보관할 수 있다.<br>
1비트로는 참(true) 또는 거짓(false)와 같은 대비되는 두 가지 정보만 표현할 수 있다.<br>
많은 정보를 표현하려면 더 많은 비트가 필요하므로 비트 여덟 개를 묶어 정보를 나타내는 하나의 단위인 1바이트(byte)를 사용한다.<br>
바이트의 메모리 내 주소를 일반적으로 메모리 주소라고 하고, 메모리 주소를 사용하여 셀을 찾는 것을 주소 지정이라고 한다.

8비트로 만들 수 있는 조합은 256(2^8)개 뿐이므로 부호 없는 정수(unsigned integer)로 표현하면 0 - 255만 표현 가능하다.<br>
따라서 일반적으로 4바이트(32비트)를 묶어 하나의 **정수**를 표현하는 단위로 사용한다.<br>
**정보 조합**을 표현하기 위해서는 12바이트를 사용하며, 이를 구조체 또는 객체라고 표현한다.

CPU는 메모리에서 값을 읽어 레지스터에 저장해 연산을 수행할 수 있다.<br>
`store $1 6`, `load r1 6`처럼 $는 값, 숫자는 메모리 주소, r은 레지스터를 의미한다.<br>
`store $1 6`에서 주소 6에 저장하는 숫자 1에 a라는 이름을 붙인다면 **a 변수가 나타내는 숫자 1이 메모리 주소 6에 저장되어 있다**는 의미가 된다.

메모리 주소만 알고 있으면 변수의 데이터를 찾을 수 있고, 이는 해당 데이터가 차지하고 있는 메모리 공간 크기와는 무관하다.<br>
이때 데이터의 복사본을 만드는 대신 복사하고 싶은 데이터의 주소를 저장해 메모리를 절약할 수 있다.<br>
**포인터**는 메모리 주소를 더 높은 수준으로 추상화한 것이다.<br>
왜냐하면 어셈블리어는 주소1 → 주소3 → 데이터의 간접 주소 지정을 사용하지만, 고급 언어는 b → 데이터처럼 변수가 값과 메모리 주소를 모두 담을 수 있기 때문이다.

포인터 개념이 있으면 프로그래머는 메모리 같은 하드웨어를 직접 조작할 수 있지만, 포인터 개념이 없는 프로그래밍 언어에서는 이런 작업이 불가능하다.<br>
이것이 포인터가 있는 C언어가 저수준 계층을 제어하는 강력한 힘을 가진 이유이자 C언어가 시스템 프로그래밍에 가장 먼저 선택되는 중요 원인이기도 하다.<br>
포인터가 있는 언어에서 변수는 구체적으로 메모리의 어느 위치에 저장되어 있는지 직접 확인할 수 있을 정도로 뚜렷한 개념이 된다.<br>
이는 모든 추상화를 우회하여 직접 메모리를 읽고 쓸 수 있는 반면에 포인터 연산에 오류가 있을 때는 프로그램 실행 상태를 직접 파괴해 버릴 수 있다는 것을 의미하기도 한다.<br>
포인터는 메모리를 직접 조작할 수 있는 능력을 부여함과 동시에 포인터를 조작할 때는 실수하지 않아야 한다는 더 높은 기준을 요구한다.

간단히 요약하면, 포인터는 메모리 주소를 추상화한 것이고 참조는 포인터를 한 번 더 추상화한 것이다.<br>
참조를 사용할 때는 변수의 구체적인 메모리 주소를 얻을 수 없으며, 참조는 포인터와 유사한 구조의 산술 연산을 할 수 없다.<br>
또한 데이터를 복사할 필요가 없기 때문에 포인터를 사용할 때와 동일한 효과를 얻을 수 있다.<br>
메모리 자체는 더 추상화될 수 있다. 바로 **가상 메모리**이다.<br>
가상 메모리를 지원하는 시스템에서 프로세스가 사용하는 메모리 주소는 사실 가상 메모리이다.

<br>

## 3.2 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?

모든 프로세스 주소 공간에는 코드 영역, 데이터 영역, 힙 영역, 스택 영역이 있다.
- 코드 영역, 데이터 영역: 실행 파일을 초기화할 때 생성되는 영역
- 힙 영역: 동적 메모리 할당에 사용
- 스택 영역: 함수 호출에 사용되며 매개변수, 반환 주소, 레지스터 정보 등을 포함한 함수 실행 시 정보를 저장하는 데 사용

<br>

모든 프로세스의 코드 영역은 `0x400000`에서 시작한다.<br>
그렇다면 서로 다른 프로세스 두 개가 메모리를 할당하기 위해 `malloc` 함수를 호출하면 동일한 시작 주소를 반환하면 동일한 주소에 데이터를 쓴다고 생각할 수 있다.<br>
하지만 해당 메모리 주소는 가상 메모리 주소이며, 이 주소는 메모리에 조작이 일어나기 전에 실제 메모리 주소로 변환되므로 문제가 발생하지 않는다.<br>
프로세스는 동일한 크기의 조각(chunk)로 나뉘어 물리 메모리에 저장되고, 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있다.<br>
**페이지 테이블**이 가상 메모리와 물리 메모리 사이의 사상(mapping) 관계를 유지하여 균일한 가상의 주소 공간을 제공한다.

가상 메모리 주소와 물리 메모리 주소의 사상 관계가 유지되는 한 프로세스 주소 공간의 데이터가 실제 물리 메모리의 어디에 저장되는지는 전혀 신경 쓸 필요가 없다.<br>
이런 사상 관계를 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 있어야 한다.<br>
또한 프로세스의 주소 공간을 동일한 크기의 조각으로 나누고, 이 조각을 **페이지**라고 부른다.

<br>

## 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

함수는 가장 기초적이고 간단한 코드 재사용 방식이다.<br>
이외에도 함수는 프로그래머가 구현의 세부 사항을 감출 수 있게 하므로 일종의 추상화에 해당한다.<br>
함수의 호출은 게임의 퀘스트에 비유할 수 있다. 때로는 메인 퀘스트를 완료하기 위해 무조건 서브 퀘스트를 진행해야 할 때가 있다.<br>
이러한 전체 퀘스트의 진행 궤적을 살펴보면 **후입선출** 순서로, 스택과 같은 데이터 구조가 처리하기에 적합하다.<br>
또한 스택 상단의 작업 궤적을 살펴보면 사실상 이진 트리의 탐색이라는 것을 알 수 있다.

모든 함수는 실행 시에 자신만의 **스택 프레임** 또는 **호출 스택**이 필요하다.<br>
이 스택 구조 안에는 해당 함수가 실행될 때 사용되는 여러 가지 정보가 저장되어 있으며, 우리가 일반적으로 말하는 프로세스의 스택 영역에 생성된다.<br>
스택 영역 안에서는 높은 주소가 맨 위에 있고 스택 영역은 낮은 주소 방향으로 커진다. 이는 스택 영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가하고 함수 호출이 완료될수록 감소한다는 의미이다.

함수 A가 함수 B를 호출하면, 제어권(CPU가 어떤 함수에 속하는 기계 명령어를 실행하는지)이 함수 A에서 함수 B로 옮겨진다.<br>
제어권이 이전될 때는 다음 두 가지 정보가 필요하다.
- 반환(return): 어디에서 왔는지에 대한 정보
- 점프(jump): 어디로 가는지에 대한 정보<br>

이런 정보는 스택 프레임을 통해 얻을 수 있다.<br>

![그림 3-28](/esc/CH3/images/pic3_28.png)<br>
함수 A에서 `call 0x400540` 기계 명령어에 대응하는 것은 코드의 함수 호출이며, call 뒤에 명령어 주소는 함수 B의 첫 번째 기계 명령어다.<br>
따라서 call 기계 명령어를 실행한 직후 CPU는 함수 B로 점프하게 된다.<br>
call 명령어를 실행한 직후, 함수 A에서 call 명령어 다음에 위치한 주소는 함수 A의 스택 프레임에 넣는다.<br>
이런 식으로 함수 B는 마지막 기계 명령어인 ret까지 실행되고, ret 명령어를 통해 CPU는 함수 A의 스택 프레임에 저장된 반환 주소로 점프하도록 전달하여 함수 A로 점프하여 계속 실행된다.

CPU는 기계 명령어를 실행할 때 점프와 반환이 가능하기 때문에 이를 이용하여 함수를 호출한다.<br>
x86-64에서는 대부분의 경우 매개변수의 전달과 반환값을 가져오는 작업을 레지스터로 한다.<br>
함수 A가 함수 B를 호출한다면 함수 A는 매개변수를 상응하는 레지스터에 저장하며, CPU가 함수 B를 실행할 때 이 레지스터에서 매개변수 정보를 얻을 수 있다.<br>
전달된 매개변수 수가 사용 가능한 레지스터 수보다 많다면 나머지 매개변수는 스택 프레임에 직접 넣을 수 있기 때문에 새로 호출된 함수가 이전 함수의 스택 프레임에서 매개변수를 가져온다.

함수 외부에 정의된 변수를 **전역 변수**라고 하고, 이 변수들은 실행 파일의 데이터 영역에 저장되어 있다 프로그램이 실행되면 프로세스 주소 공간의 데이터 영역에 적재된다.<br>
함수 내부에 정의된 변수는 **지역 변수**라고 하고, 이 변수들은 해당 함수에서만 사용 가능하고 외부에서는 접근이 불가능하다.<br>
지역 변수는 매개변수와 마찬가지로 레지스터에 저장할 수 있지만, 지역 변수 수가 레지스터 수보다 많으면 이 변수들도 스택 프레임에 저장되어야 한다.

레지스터는 CPU 내부의 리소스이므로 함수 A와 B에서 동일한 레지스터를 사용하면 함수 A가 함수 B를 호출할 때 함수 A가 레지스터에 기록한 지역 변수 정보를 함수 B가 덮어쓸 수 있다.<br>
따라서 레지스터에 지역 변수를 저장하기 전에 반드시 먼저 레지스터에 원래 저장되었던 초기값을 꺼냈다 레지스터를 사용하고 나면 다시 그 초기값을 저장해야 한다. 이러한 초기값은 함수의 스택 프레임에 저장된다.<br>
함수 실행이 완료된 후에는 스택 프레임에 저장되어 있는 초깃값을 상응하는 레지스터에 내용으로 복원하면 된다.

스택 프레임은 스택 영역에 위치해 있으며, 스택 영역은 프로세스 주소 공간의 일부이다.<br>
함수가 매번 호출될 때마다 상응하는 스택 프레임은 함수 실행 시 정보를 저장하기 위해 생성되며, 함수 호출 단계가 증가함에 따라 스택 영역이 점점 더 많은 메모리를 차지하게 된다.<br>
하지만 스택 영역의 크기에는 제한이 있으며, 이 제한을 초과하면 **stack overflow** 오류가 발생한다.<br>
따라서 프로그래머는 너무 큰 지역 변수를 만들지 않고, 함수 호출 단계가 너무 많지 않도록 주의해야 한다.

<br>

## 3.4 힙 영역: 메모리의 동적 할당은 어떻게 구현될까?

모든 함수에는 각각의 스택 프레임이 있으며 이 안에는 반환 주소, 함수의 지역 변수, 매개변수, 사용되는 레지스터를 비롯한 정보가 저장된다.<br>
여기서 두 가지 내용에 주의해야 한다.
1. 호출한 함수의 호출 과정이 완료되면 스택 프레임에 저장되어 있던 내용은 더 이상 사용되지 않고 무효화된다. 따라서 사용이 끝난 스택 프레임 정보를 사용해서는 안 된다.
2. 지역 변수의 수명 주기는 함수 호출과 동일하다. 이것의 장점은 지역 변수 메모리의 할당과 반환에 신경 쓸 필요가 없다는 것이고, 단점은 함수를 뛰어넘어 사용하는 것이 불가능하다는 것이다.

<br>

특정 데이터를 여러 함수에 걸쳐 사용하는 방법으로 전역 변수가 있지만, 전역 변수는 모든 모듈에 노출되어 있다.<br>
하지만 모든 모듈에 노출하고 싶지 않은 데이터는 프로그래머가 직접 관리하는 메모리 영역에 저장하고 이런 메모리 영역을 언제 요청할지, 데이터를 저장하는 데 얼마나 많은 메모리 영역을 요청할지 직접 결정해야 한다.<br>
이 메모리는 함수의 호출 횟수와 관계없이 프로그래머가 해당 메모리 영역의 사용이 완료되었다고 확신할 때까지 유효하게 유지된다.<br>
이렇게 프로그래머가 완전히 직접 제어할 수 있는 매우 큰 메모리 영역을 **힙 영역**이라고 한다.<br>
C/C++ 언어에서는 `malloc` 함수 또는 `new` 예약어를 사용하여 힙 영역에 메모리를 요청하며, `free` 함수나 `delete` 예약어를 이용하여 해당 메모리를 반환한다.

C/C++ 언어에서 메모리의 동적 할당과 해제 요청은 모두 `malloc` 메모리 할당자에서 이루어진다.<br>
실행 파일을 생성할 때 링커는 `malloc` 메모리 할당자가 포함되어 있는 C 표준 라이브러리를 자동으로 링크한다.

힙 영역의 메모리 관리 작업을 하는 자신만의 malloc 메모리 할당자를 구현하려면 적절한 크기의 메모리 영역을 제공하기만 하면 되고, 할당자는 메모리 영역에 무엇을 저장할지는 신경 쓰지 않는다.<br>
따라서 힙 영역은 커다란 배열 형태로 이루어져 있다. 이제 힙 영역 위에서 두 가지 문제를 해결해야 한다.<br>
- `malloc` : 메모리 영역을 요청하면 힙 영역에서 가능한 메모리 영역을 찾아 요청자에게 반환
- `free` : 메모리 영역의 사용이 완료되었을 때 힙 영역에 메모리 영역을 반환

<br>

요청하는 메모리 크기가 일정하지 않을 때 요청된 크기를 만족하는 여유 메모리를 최대한 빨리, 가능한 한 많은 메모리 할당 요청을 만족시켜야 한다.<br>
여기 네 가지 문제가 있다.
1. 메모리를 요청할 때, 어떤 메모리가 여유 메모리고 어떤 메모리가 이미 할당되어 있는지 어떻게 알 수 있을까?
2. 메모리 조각을 조직화 모든 메모리 조각의 할당 상태를 추적할 수 있다. 여러 여유 메모리 조각이 있을 때 어떤 메모리 조각을 사용자에게 반환해야 할까?
3. 여유 메모리 조각을 할당한 뒤 남은 메모리는 어떻게 처리해야 할까?
4. 사용자가 반환한 메모리를 어떻게 처리해야 할까?

<br>

모든 메모리 조각은 연결 리스트로 관리하면 어떤 것이 사용 가능하고 어떤 것이 이미 할당된 것인기 기록하기 편리하다.<br>
하지만 연결 리스트를 생성하려면 메모리 할당을 해야 하고, 메모리 할당자를 사용해야 하는데 우리는 지금 메모리 할당자를 구현하는 단계이다.<br>
따라서 연결 리스트와 메모리 사용 정보를 메모리 조각 그 자체에 함께 저장해야 한다.<br>
해당 메모리 조각이 비어 있는지를 알려주는 **flag**와 해당 메모리 조각의 크기를 기록한 숫자를 포함해 구현하면 된다.

![메모리 사용 정보 저장](/esc/CH3/images/pic3_39.png)<br>
메모리 조각의 최대 크기가 2GB로 제한되어 있기 때문에 31비트를 사용하여 조각 크기를 기록하고, 나머지 1비트는 조각이 비어 있는지 또는 할당되어 있는지 인식하는 데 사용한다.<br>
이 32비트는 **header**라고 하며, 메모리 조각의 사용 정보를 저장하는 데 사용된다.<br>
할당 가능한 메모리 조각을 **payload**라고 하며, `malloc` 호출 시 반환되는 메모리 주소이다.<br>
해당 구성에서는 header의 주소만 알고 있다면 다음 노드의 시작 주소를 알 수 있다.<br>
힙 영역의 모든 메모리를 남김없이 할당하는 것은 불가능하다. 일부분은 메모리 조각에 대한 필수 정보를 저장하기 위해 별도로 사용되어야 하기 때문이다.

![힙 영역에서 메모리 할당 요청 추적](/esc/CH3/images/pic3_41.png)<br>
힙 영역은 한 조각에 4바이트인 매우 작은 영역으로, 할당된 메모리 조각과 여유 메모리 조각을 나타낸다.<br>
header에는 a/b 형식으로 a에는 메모리 조각 크기가, b에는 할당 여부가 0과 1로 나타난다.<br>
마지막 조각의 0/1로 메모리 할당자의 끝을 나타낸다.<br>
header 정보를 통해 전체 힙 영역을 쉽게 추적할 수 있고, 마지막 비트를 확인하여 메모리 조각이 여유 상태인지 할당되었는지 알 수 있다.

여유 메모리 할당에는 다음과 같은 전략들이 있다:
- 최초 적합 방식(first-fit): 처음부터 탐색하다가 가장 먼저 발견된 요구 사항을 만족하는 항목을 반환하는 것
    - 장점: 단순하다.
    - 단점: 제일 처음부터 사용 가능한 메모리 조각을 찾으므로 메모리 할당 과정에서 앞부분에 작은 메모리 조각이 많이 남을 수 있다.
- 다음 적합 방식(next fit): 메모리를 요청할 때 처음부터 검색하는 대신 적합한 여유 메모리 조각이 마지막으로 발견된 위치에서 시작하는 것
    - 장점: 이론적으로 최초 적합 방식보다 더 빠르게 여유 메모리 조각을 탐색할 수 있다.
    - 단점: 다음 적합 방식의 메모리 사용률이 최초 적합 방식에 미치지 못한다.
- 최적 적합 방식(best fit): 사용 가능한 메모리 조각을 모두 찾은 후 그 중 요구 사항을 만족하면서 크기가 가장 작은 조각을 반환하는 것
    - 장점: 다른 방식보다 메모리를 더 잘 활용한다.
    - 단점: 메모리를 할당할 때 사용 가능한 모든 메모리 조각을 탐색해야 하므로 느리다.

<br>

여기에서는 최초 적합 방식을 사용한다고 가정한다.<br>
메모리 요청 시 할당을 위해 발견된 여유 메모리 조각을 할당한 것으로 표시하고, header 뒤에 따라오는 메모리 조각의 주소를 요청자에게 반환하여 메모리를 할당할 수 있다.<br>
이때 header 정보를 담고 있는 메모리는 손상되면 메모리 할당자가 정상적으로 작동할 수 없기 때문에 요청자에게 반환되면 안된다.<br>
여유 메모리 조각이 요청한 메모리보다 크다면 메모리가 낭비되는 **내부 단편화**가 발생하여 해당 메모리 조각의 남은 부분은 사용할 수 없다.<br>
여유 메모리 조각을 두 개로 분할하여 앞부분은 할당한 후 반환하고, 뒷부분은 새로운 여유 메모리 조각으로 만들어 이를 해결할 수 있다.<br>
이때 4바이트는 header로 설정하고 나머지를 여유 메모리 조각으로 표시해야 한다.

사용자가 요청할 때 얻은 주소를 해제 함수에 전달하여 메모리를 해제할 수 있다.<br>
`free(ADDR)`처럼 호출하여 header 정보에서 할당 설정값을 여유 메모리로 바꾸면 해제가 완료된다.<br>
해제되는 메모리 조각과 인접한 메모리 조각이 여유 메모리 조각일 때, 더 큰 메모리 조각으로 서로 병합해야 한다.<br>
메모리가 해제될 때 즉시 병합하는 것은 비교적 간단하지만 메모리 조각 병합으로 인한 부담이 발생한다.<br>
따라서 실제 메모리 할당자는 거의 대부분 다음 할당 때 요구 사항을 충족하는 여유 블록을 찾을 수 없을 때까지 여유 메모리 조각 병합을 연기하는 전략을 사용한다.

![메모리 조각 끝에 꼬리 정보 추가](/esc/CH3/images/pic3_55.png)<br>
현재 위치에서 뒤에 위치한 메모리 조각은 header를 확인해 비어 있는지를 확인할 수 있다.<br>
이전 메모리 조각에 대한 정보를 갖기 위해서 footer 정보를 추가했다.<br>
header와 footer를 통해 메모리 조각을 일종의 암시적 양방향 연결 리스트로 만든다.

<br>

## 3.5 메모리를 할당할 때 저수준 계층에서 일어나는 일

![프로그램 종류별로 존재하는 등급](/esc/CH3/images/Priv_rings.png)<br>
코드는 여러 가지 등급으로 나뉜다. x86 CPU는 **네 가지 특권 단계**를 제공한다. 숫자가 작을수록 CPU의 특권은 커진다.<br>
여기서 특권은 일부 명령어를 실행할 수 있는지를 나타낸다. 일반적으로 시스템은 CPU의 특권 단계 중 0과 3 두 단계만 사용한다.<br>
특권 3단계는 **사용자 상태(user mode)**라고 하며, 특권 0단계는 **커널 상태(kernel mode)**라고 한다.

CPU가 운영 체제의 코드를 실행할 때 커널 상태에 해당한다.<br>
커널 상태에서는 CPU가 모든 기계 명령어를 시랳ㅇ할 수 있고, 모든 주소 공간에 접근할 수 있으며, 제한 없이 하드웨어에 접근할 수 있다.<br>
프로그래머가 작성한 '일반적인' 코드를 CPU가 실행할 때 사용자 상태에 해당한다.<br>
사용자 상태 코드는 특정 주소 공간에 접근할 수 없으며 특권 명령어를 실행할 수 없다.

![사용자 상태에서 시작되어 커널 상테에서 처리되는 시스템 호출](/esc/CH3/images/system_call.png)<br>
CPU는 커널 상태에서는 응용 프로그램을 실행할 수 없는 반면, 사용자 상태에서는 운영 체제의 코드를 실행할 수 없다.<br>
프로그래머는 시스템 호출을 이용하여 운영 체제가 파일의 읽기와 쓰기, 네트워크 데이터 통신 같은 작업을 응용 프로그램 대신 처리하도록 한다.<br>
시스템 호출은 x86의 INT 명령어처럼 특정한 기계 명령어로 구현되며, 이 명령어를 실행할 때 CPU는 사용자 상태에서 커널 상태로 전환되어 운영 체제의 코드를 실행하는 방법으로 사용자 요청을 수행한다.

시스템 호출을 직접 사용하면 리눅스의 프로그램은 윈도에서 직접 실행할 수 없게 된다.<br>
따라서 저수준 계층 간 차이를 감추는 일종의 표준이 필요한데, C언어에서는 **표준 라이브러리**를 사용한다.<br>
일반적으로 프로그래머는 표준 라이브러리를 호출하여 파일의 읽고 쓰기 작업과 네트워크 통신을 수행하며, 표준 라이브러리는 실행 중인 운영 체제에 따라 대응되는 시스템 호출을 선택한다.

고수준 계층에서는 응용 프로그램이 위치하며, 일반적으로 표준 라이브러리만 의사소통 대상으로 간주한다.<br>
표준 라이브러리는 시스템 호출로 운영 체제와 소통하며, 운영 체제는 저수준 하드웨어를 관리한다.<br>
`malloc`, `tcmalloc`, `jemalloc` 등 다양한 메모리 할당자는 표준 라이브러리의 일부이다.

스택 영역의 함수 호출 단계까 깊어질수록 아래쪽으로 메모리 점유 공간이 늘어나는 것처럼, 힙 영역의 메모리가 부족하면 위쪽으로 더 많은 메모리를 점유하게 된다.<br>
malloc은 메모리가 부족해지면 운영 체제에 메모리를 요청하고, 힙 영역의 최상단을 가리키는 `brk` 변수를 위로 이동시켜 힙 영역을 확장한다. 이때 시스템 호출이 필요하다.<br>
이제 메모리 할당이 더 이상 사용자 상태의 힙 영역에만 국한되지 않으므로 메모리 할당 단계가 다음과 같이 달라진다.<br>
![메모리 할당 한 번에도 운영 체제의 도움이 필요할 수 있다.](/esc/CH3/images/pic3_67.png)<br>
1. 프로그램은 표준 라이브러리에 구현되어 있는 `malloc`을 호출하여 메모리 할당을 요청한다.
2. `malloc`은 여유 메모리 조각을 검색하고, 적절한 크기의 조각을 찾으면 이를 할당한다. 해당 단계는 사용자 상태에서 처리된다.
3. `malloc`이 여유 메모리 조각을 찾지 못하면 brk 시스템 호출 등을 통해 운영 체제에 힙 영역을 늘려 주라고 요청한다. brk는 운영 체제의 일부분이므로 커널 상태에서 처리된다.
4. 힙 영역이 늘어나면 `malloc`이 적절한 여유 메모리 조각을 찾아서 할당한다.

<br>

malloc을 이용하여 힙 영역에서 메모리를 요청하고, malloc 역시 운영 체제의 도움을 받아 힙 영역을 확장하지만, 이 힙 영역을 포함한 전체 프로세스 주소 공간은 모두 실제 물리 메모리가 아니다.<br>
프로세스 입장에서 사용하는 메모리는 모두 가상이며 운영 체제가 프로세스에 보여 주는 환상이다.<br>
실제 물리 메모리는 실제로 할당된 메모리가 사용되는 순간에 할당된다.<br>
이때 가상 메모리가 실제 물리 메모리와 연결되어 있지 않으면 내부적으로 페이지 누락 오류(page fault)가 발생할 수 있다.<br>
운영 체제가 이 오류를 감지하면 페이지 테이블을 수정하여 가상 메모리와 실제 물리 메모리의 사상 관계를 설정하며, 이것으로 실제 물리 메모리가 할당된다.<br>
이 과정이 완료되면 프로그램에서 할당받은 메모리를 사용할 수 있다.

`malloc`을 호출하여 메모리를 요청하면 다음 일이 일어난다.
1. `malloc`이 여유 메모리 조각을 검색하기 시작하고 적절한 크기의 조각을 찾으면 이를 할당한다.
2. `malloc`이 적절한 여유 메모리를 찾지 못하면 `brk` 같은 시스템 호출을 통해 힙 영역을 확장하여 더 많은 여유 메모리를 얻는다.
3. `malloc`이 `brk`를 호출하면 커널 상태로 전환되는데, 이때 운영 체제의 가상 메모리 시스템이 힙 영역을 확장하는 작업을 시작한다. 이때 메모리 영역은 가상 메모리이므로 운영 체제는 아직 실제 물리 메모리를 할당하지 않았을 수 있다.
4. `brk` 실행이 종료되면 `malloc`으로 제어권이 돌아가며 CPU도 커널 상태에서 사용자 상태로 전환된다. `malloc`은 적절한 여유 메모리 조각을 찾아 반환한다.
5. 프로그램은 메모리를 성공적으로 요청했기 때문에 계속 다음 단계를 실행한다.
6. 코드가 새로 요청된 메모리를 읽거나 쓰면 시스템 내에서 페이지 누락 인터럽트(page fault interrupt)가 발생한다. CPU가 사용자 상태에서 커널 상태로 전환되어 운영 체제가 실제 물리 메모리를 할당한다. 페이지 테이블 내 가상 메모리와 실제 물리 메모리의 사상 관계가 설정된 후 CPU는 다시 커널 상태에서 사용자 상태로 돌아가고 다음 처리로 넘어간다.<br>

`malloc`을 사용하지 않고 싶다면 메모리 풀 기술을 사용할 수 있다.

<br>

## 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

malloc은 범용적이므로 어떤 상황에서도 사용할 수 있으나, 특정 상황에 맞게 최적화되어 있지 않다.<br>
범용적인 malloc을 사용하는 대신 특정 상황을 위해 자체적으로 메모리 할당 전략을 구현하는 것이 **메모리 풀** 기술이다.<br>
malloc과 메모리 풀은 다음과 같은 차이점을 갖는다:
1. 포함 계층: malloc은 표준 라이브러리의 일부로 표준 라이브러리 계층에 속하지만 메모리 풀은 응용 프로그램의 일부이다.
2. 사용 대상: 메모리 풀 기술은 특정 상황에서만 적용 가능하고, 특정 상황에서만 메모리 할당 성능을 최적화하기에 범용성이 매우 떨어진다.

<br>

메모리 풀 기술은 한 번에 큰 메모리 조각을 요청하고 그 위에서 자체적으로 메모리 할당과 해제를 관리하는 방식으로 표준 라이브러리와 운영 체제를 우회한다.<br>
또한 특정 사용 패턴에 따라 추가 최적화도 가능하다.<br>
예를 들어 여러 종류의 객체를 생성해야 한다면 자체 메모리 풀에 미리 이런 객체를 생성해 두고 사용이 끝나면 메모리 풀에 반환할 수 있다.

서버 프로그래밍으로 메모리 풀 기법을 구현해 보자.<br>
우리의 서버 프로그램이 매우 간단하여 사용자 요청을 처리할 때 단 한 종류의 데이터 구조만 사용한다고 가정해 보자.<br>
미리 커다란 영역을 할당하고 실제로 사용할 때마다 하나씩 꺼내며 사용이 끝나면 반환한다.

이번에는 크기가 서로 다른 메모리 요청을 지원하는 서버 프로그래밍 상황을 가정해 보자.<br>
사용자 요청을 처리하는 동안에는 메모리 풀에서 메모리를 요청하는 것만 가능하고 해제는 처리하지 않는다.<br>
사용자 요청 처리가 모두 완료되는 시점에서 요청된 메모리를 한꺼번에 해제해 메모리의 할당과 해제에 따른 부담을 최소화할 수 있다.<br>
이처럼 메모리 풀의 설계는 특정 상황에만 적용할 수 있다.

![메모리 풀 연결 리스트](/esc/CH3/images/memory_pool.png)<br>
여러 크기의 메모리를 할당하기 위해 모든 메모리 조각을 연결 리스트로 관리한다.<br>
모든 메모리 조각을 연결 리스트로 연결하고 포인터를 사용하여 현재 여유 메모리 조각의 위치를 기록할 수 있다.<br>
메모리가 부족하면 malloc에 새로운 메모리 조각을 요청하는데, 이때 새로운 메모리 조각의 크기는 항상 이전 메모리 조각의 두 배여야 한다.<br>
이는 malloc에 메모리를 너무 빈번하게 요청하지 않기 위함이다.<br>
메모리 풀은 사실 malloc이 반환한 메모리 위에 재할당된다.<br>
메모리 풀의 여유 메모리 조각의 시작 위치를 가리키는 `Free_ptr` 포인터가 있어 빠르게 여유 메모리 조각을 찾을 수 있다.<br>
`free`처럼 메모리 조각을 해제하는 기능은 제공하지 않으며, 요청 처리가 완료되면 한 번에 전체 메모리 풀을 해제한다.

다중 스레드 환경에서는 어떻게 스레드 안전을 달성해야 할까?<br>
메모리 풀에 잠금 보호를 적용한다면 스레드 풀이 올바르게 작동하지만, 프로그램에서 대량의 스레드가 메모리 할당과 해제를 요청하면 이 방식은 시스템 성능이 저하될 수 있다.<br>
잠금을 추가하면 성능 문제가 따라올 수 있으므로, 각 스레드마다 메모리 풀을 유지하여 스레드 간 경쟁 문제를 근본적으로 해결하는 것이 좋다.<br>
스레드 풀을 스레드 전용 저장소에 넣으면 각 스레드가 자신에게 속한 스레드 풀만 사용할 수 있다.

<br>

## 3.7 대표적인 메모리 관련 버그

### 3.7.1 지역 변수의 포인터 반환하기

```
int* func() {
    int a = 2;
    return &a;
}

void main() {
    int* p = func();
    *p = 20;
}
```
지역 변수 a가 func 함수의 스택 프레임에 위치하며 func 함수의 실행이 끝나면 해당 스택 프레임도 없어지므로 main 함수가 func 함수를 호출한 후 얻는 포인터는 이미 없는 변수를 가리키게 된다.

<br>

### 3.7.2 포인터 연산의 잘못된 이해

```
int sum(int* arr, int len) {
    int sum = 0;
    for (int i = 0; i < len; i++) {
        sum += *arr;
        arr += sizeof(int);
    }
    return sum;
}
```
포인터 연산에서 1을 더하는 것은 1바이트만큼 이동하는 것이 아니라 단위 한 개만큼 이동하는 것을 의미한다.<br>
단위 한 개는 포인터가 가리키는 데이터 형식의 크기에 해당한다.<br>
따라서 포인터를 이동할 때 포인터가 가리키는 데이터 형식의 크기는 신경 쓸 필요가 없다.

<br>

### 3.7.3 문제 있는 포인터 역참조하기

```
int a;
scanf("%d", a);
```
`scanf("%d", a);` 코드의 결과는 a 값에 따라 달라진다.<br>
1. a 값이 코드 영역이나 기타 읽기 전용을 가리키는 포인터 값이면? 운영 체제는 이 프로세스를 강제 종료시킨다.
2. a 값이 스택 영역을 가리키는 포인터 값이면? 다른 함수의 스택 프레임이 파괴되었기 때문에 버그의 원인을 찾기 어렵다.
3. a 값이 힙 영역 또는 데이터 영역을 가리키는 포인터 값이면? 동적으로 할당한 메모리가 파괴되었기 때문에 버그의 원인을 찾기 어렵다.

<br>

### 3.7.4 초기화되지 않은 메모리 읽기

```
void add() {
    int* a = (int*)malloc(sizeof(int));
    *a += 10;
}
```
malloc을 호출할 때 실제로 두 가지 가능성이 존재한다.<br>
1. malloc이 자체적으로 충분한 메모리를 유지하고 있다면? malloc은 여유 메모리 조각에서 반환할 주소를 찾는다. 이 메모리가 이미 사용된 적이 있따면 이전에 사용된 정보가 남아 있을 수 있다.
2. malloc이 자체적으로 유지하고 있는 메모리가 충분하지 않다면? 시스템 호출로 메모리를 요청할 때 page fault interrupt가 발생하며 운영 체제가 실제 물리 메모리를 할당하기 때문에 0으로 초기화될 수 있다.<br>
따라서 malloc이 반환한 메모리가 당연히 0으로 초기화되어 있다고 가정해서는 안 되며, 직접 수동으로 메모리를 초기화해야 한다.

<br>

### 3.7.5 이미 해제된 메모리 참조하기

```
void add() {
    int* a = (int*)malloc(sizeof(int));
    ...
    free(a);
    int b = *a;
}
```
해제된 메모리를 가리키는 경우 어떤 값이 들어 있을지는 malloc 내부의 작업 상태에 따라 다르다.<br>
1. 메모리 조각이 해제된 후 아직 malloc으로 다시 할당하지 않았다면? 가리키는 값은 이전과 동일하다.
2. 메모리 조각이 이미 malloc으로 할당되었다면? 이미 덮어쓰기가 되었을 수 있으므로 역으로 참조하여 얻는 것은 이미 덮어쓰기가 된 데이터이다.

<br>

### 3.7.6 배열 첨자는 0부터 시작한다.

```
void init(int n){
    int* arr = (int*)malloc(n * sizeof(int));

    for (int i = 0; i <= n; i++){
        arr[i] = i;
    }
}
```
배열을 초기화하는 코드를 실행할 때, 덮어쓴 메모리에 malloc이 사용하는 메로리 할당 상태 정보가 있다면 malloc 동작을 파괴한다.

<br>

### 3.7.7 스택 넘침

```
void buffer_overflow() {
    char buf[32];
    gets(buf);
    return;
}
```
코드에서 지정한 사용자 입력을 초과하는 순간 스택 프레임 내에서 인접해 있는 데이터를 파괴한다.<br>
스택 프레임에는 함수의 반환 주소처럼 중요한 정보가 들어 있어 **stack buffer overflow**는 문제를 일으킬 가능성이 더 높다.<br>
코드에 stack buffer overflow 문제가 있을 때 넘치는 부분이 스택 프레임의 반환 주소를 덮어쓰게 된다. 이 주소에 해커가 악성 코드를 심어둔다면 프로세스가 실행될 때 해커의 악성 코드가 실행된다.

<br>

### 3.7.8 메모리 누수

```
void memory_leak() {
    int *p = (int *)malloc(sizeof(int));
    return;
}
```
메모리를 요청한 후 바로 반환할 때, 해당 메모리는 프로세스가 종료되기 전까지 다시 해제할 방법이 없어 메모리 누수가 일어난다.<br>
메모리 누수는 특히 자동 쓰레기 수집을 지원하지 않는 언어에서 흔하게 발생한다.<br>
프로그램이 메모리를 요청하기만 하고 해제를 하지 않는다면 프로세스의 힙 영역이 점점 늘어나 결국 운영 체제가 강제로 프로세스를 종료하는 상황이 발생한다.

<br>

## 3.8 왜 SSD는 메모리로 사용할 수 없을까?

파일 크기는 5.72KB지만, 차지하는 공간은 8KB가 되는 경우가 있다.<br>
이것은 파일 크기가 할당된 조각(block)과 관련이 있다.<br>
메모리의 주소 지정 단위는 바이트이다.<br>
즉, 각 바이트마다 메모리 주소가 부여되어 있고, CPU가 이 주소를 이용하여 해당 내용에 직접 접근할 수 있다는 것을 의미한다.

하지만 SSD는 조각 단위로 데이터를 관리하며, 이 조각 크기는 매우 다양하다.<br>
CPU는 SSD에 저장된 데이터에 직접 접근할 수 있는 방법이 없다.

최신 운영 체제의 메모리 관리는 기본적으로 가상 메모리 기반이다.<br>
32비트 시스템의 최대 주소 지정 범위는 4GB이므로 SSD의 저장 공간이 커져도 프로세스는 4GB 이상의 메모리를 사용할 수 없다.<br>
64비트 시스템에서는 이런 문제가 없다.

SSD는 TBW라는 기록한 데이터의 누적 크기를 나타내는 단위가 있다.<br>
TBW가 클 수록 SSD의 문제가 발생할 가능성이 높아진다.<br>
CPU는 프로그램을 실행할 때 대량의 메모리 읽기와 쓰기 작업을 실행하므로 SSD를 메모리로 사용하면 사용 수명 때문에 시스템에 병목 현상이 발생할 수 있지만, 메모리에는 이런 문제가 없다.