# 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

malloc은 범용적이므로 어떤 상황에서도 사용할 수 있으나, 특정 상황에 맞게 최적화되어 있지 않다.<br>
범용적인 malloc을 사용하는 대신 특정 상황을 위해 자체적으로 메모리 할당 전략을 구현하는 것이 **메모리 풀** 기술이다.<br>

## 3.6.1 메모리 풀 대 범용 메모리 할당자

첫 번째 차이는 포함 계층이다.<br>
malloc은 표준 라이브러리의 일부로 표준 라이브러리 계층에 속하지만 메모리 풀은 응용 프로그램의 일부이다.<br><br>

두 번째 차이는 사용 대상에 있다.<br>
메모리 풀 기술은 특정 상황에서만 적용 가능하고, 특정 상황에서만 메모리 할당 성능을 최적화하기에 범용성이 매우 떨어진다.<br>

## 3.6.2 메모리 풀 기술의 원리

메모리 풀 기술은 한 번에 큰 메모리 조각을 요청하고 그 위에서 자체적으로 메모리 할당과 해제를 관리하는 방식으로 표준 라이브러리와 운영 체제를 우회한다.<br>

또한 특정 사용 패턴에 따라 추가 최적화도 가능하다.<br>
예를 들어 여러 종류의 객체를 생성해야 한다면 자체 메모리 풀에 미리 이런 객체를 생성해 두고 사용이 끝나면 메모리 풀에 반환할 수 있다.<br>

## 3.6.3 초간단 메모리 풀 구현하기

서버 프로그래밍으로 메모리 풀 기법을 구현해 보자.<br>
우리의 서버 프로그램이 매우 간단하여 사용자 요청을 처리할 때 단 한 종류의 데이터 구조만 사용한다고 가정해 보자.<br>
미리 커다란 영역을 할당하고 실제로 사용할 때마다 하나씩 꺼내며 사용이 끝나면 반환한다.<br><br>

이번에는 크기가 서로 다른 메모리 요청ㅇ르 지원하는 서버 프로그래밍 상황을 가정해 보자.<br>
사용자 요청을 처리하는 동안에는 메모리 풀에서 메모리를 요청하는 것만 가능하고 해제는 처리하지 않는다.<br>
사용자 요청 처리가 몯 완료되는 시점에서 요청된 메모리를 한꺼번에 해재헤 메모리의 할당과 해제에 따른 부담을 최소화할 수 있다.<br>
이처럼 메모리 풀의 설계는 특정 상황에만 적용할 수 있다.<br>

## 3.6.4 약간 더 복잡한 메모리 풀 구현하기

모든 메모리 조각을 연결 리스트로 연결하고 포인터를 사용하여 현재 여유 메모리 조각의 위치를 기록할 수 있다.<br>
메모리가 부족하면 malloc에 새로운 메모리 조각을 요청하는데, 이때 새로운 메모리 조각의 크기는 항상 이전 메모리 조각의 두 배여야 한다.<br>
이는 malloc에 메모리를 너무 빈번하게 요청하지 않기 위함이다.<br>
메모리 풀은 사실 malloc이 반환한 메모리 위에 재할당된다.<br>
메모리 풀의 여유 메모리 조각의 시작 위치를 가리키는 `Free_ptr` 포인터가 있어 빠르게 여유 메모리 조각을 찾을 수 있다.<br>
`free`처럼 메모리 조각을 해제하는 기능은 제공하지 않으며, 요청 처리가 완료되면 한 번에 전체 메모리 풀을 해제한다.<br>

## 3.6.5 메모리 풀의 스레드 안전 문제

다중 스레드 환경에서는 어떻게 스레드 안전을 달성해야 할까?<br>
메모리 풀에 잠금 보호를 적용한다면 스레드 풀이 올바르게 작동하지만, 프로그램에서 대량의 스레드가 메모리 할당과 해제를 요청하면 이 방식은 시스템 성능이 저하될 수 있다.<br>
잠금을 추가하면 성능 문제가 따라올 수 있으므로, 각 스레드마다 메모리 풀을 유지하여 스레드 간 경쟁 문제를 근본적으로 해결하는 것이 좋다.<br>
스레드 풀을 스레드 전용 저장소에 넣으면 각 스레드가 자신에게 속한 스레드 풀만 사용할 수 있다.<br>
