# 3.7 대표적인 메모리 관련 버그

## 3.7.1 지역 변수의 포인터 반환하기

지역 변수 a가 func 함수의 스택 프레임의 위치하며 func 함수의 실행이 끝나면 해당 스택 프레임도 없어지므로 main 함수가 func 함수를 호출한 후 얻는 포인터는 이미 없는 변수를 가리키게 된다.<br>

## 3.7.2 포인터 연산의 잘못된 이해

포인터 연산에서 1을 더하는 것은 1바이트만큼 이동하는 것이 아니라 단위 한 개만큼 이동하는 것을 의미한다.<br>
단위 한 개는 포인터가 가리키는 데이터 형식의 크기에 해당한다.<br>
따라서 포인터를 이동할 때 포인터가 가리키는 데이터 형식의 크기는 신경 쓸 필요가 없다.<br>

## 3.7.3 문제 있는 포인터 역참조하기

`scanf("%d", a);` 코드의 결과는 a 값에 따라 달라진다.<br>
1. a 값이 코드 영역이나 기타 읽기 전용을 가리키는 포인터 값이면? 운영 체제는 이 프로세스를 강제 종료시킨다.
2. a 값이 스택 영역을 가리키는 포인터 값이면? 다른 함수의 스택 프레임이 파괴되었기 때문에 버그의 원인을 찾기 어렵다.
3. a 값이 힙 영역 또는 데이터 영역을 가리키는 포인터 값이면? 동적으로 할당한 메모리가 파괴되었기 때문에 버그의 원인을 찾기 어렵다.

## 3.7.4 초기화되지 않은 메모리 읽기

malloc을 호출할 때 실제로 두 가지 가능성이 존재한다.<br>
1. malloc이 자체적으로 충분한 메모리를 유지하고 있다면? malloc은 여유 메모리 조각에서 반환할 주소를 찾는다. 이 메모리가 이미 사용된 적이 있따면 이전에 사용된 정보가 남아 있을 수 있다.
2. malloc이 자체적으로 유지하고 있는 메모리가 충분하지 않다면? 시스템 호출로 메모리를 요청할 때 page fault interrupt가 발생하며 운영 체제가 실제 물리 메모리를 할당하기 때문에 0으로 초기화될 수 있다.<br>
따라서 malloc이 반환한 메모리가 당연히 0으로 초기화되어 있다고 가정해서는 안 되며, 직접 수동으로 메모리를 초기화해야 한다.<br>

## 3.7.5 이미 해제된 메모리 참조하기

해제된 메모리를 가리키는 경우 어떤 값이 들어 있을지는 malloc 내부의 작업 상태에 따라 다르다.<br>
1. 메모리 조각이 해제된 후 아직 malloc으로 다시 할당하지 않았다면? 가리키는 값은 이전과 동일하다.
2. 메모리 조각이 이미 malloc으로 할당되었다면? 이미 덮어쓰기가 되었을 수 있으므로 역으로 참조하여 얻는 것은 이미 덮어쓰기가 된 데이터이다.

## 3.7.6 배열 첨자는 0부터 시작한다.

배열을 초기화하는 코드를 실행할 때, 덮어쓴 메모리에 malloc디 사용하는 메로리 할당 상태 정보가 있다면 malloc 동작을 파괴한다.<br>

## 3.7.7 스택 넘침

코드에서 지정한 사용자 입력을 초과하는 순간 스택 프레임 내에서 인접해 있는 데이터를 파괴한다.<br>
스택 프레임에는 함수의 반환 주소처럼 중요한 정보가 들어 있어 **stack buffer overflow**는 문제를 일으킬 가능성이 더 높다.<br>
코드에 stack buffer overflow 문제가 있을 때 넘치는 부분이 스택 프레임의 반환 주소를 덮어쓰게 된다. 이 주소에 해커가 악성 코드를 심어둔다면 프로세스가 실행될 때 해커의 악성 코드가 실행된다.<br>

## 3.7.8 메모리 누수

메모리를 요청한 후 바로 반환할 때, 해당 메모리는 프로세스가 종료되기 전까지 다시 해제할 방법이 없어 메모리 누수가 일어난다.<br>
메모리 누수는 특히 자동 쓰레기 수집을 지원하지 않는 언어에서 흔하게 발생한다.<br>
프로그램이 메모리를 요청하기만 하고 해제를 하지 않는다면 프로세스의 힙 영역이 점점 늘어나 결국 운영 체제가 강제로 프로세스를 종료하는 상황이 발생한다.<br><br>