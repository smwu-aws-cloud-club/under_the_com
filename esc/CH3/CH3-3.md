# 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

## 3.3.1 프로그래머를 위한 도우미: 함수

함수는 가장 기초적이고 간단한 코드 재사용 방식이다.<br>
이외에도 함수는 프로그래머가 구현의 세부 사항을 감출 수 있게 하므로 일종의 추상화에 해당한다.<br>
그렇다면 함수의 호출은 어떻게 구현된 것일까?<br>

## 3.3.2 함수 호출 활동 추적하기: 스택

함수의 호출은 게임의 퀘스트에 비유할 수 있다.<br>
때로는 메인 퀘스트를 완료하기 위해 무조건 서브 퀘스트를 진행해야 할 때가 있다.<br>
이러한 전체 퀘스트의 진행 궤적을 살펴보면 **후입선출** 순서로, 스택과 같은 데이터 구조가 처리하기에 적합하다.<br>
또한 스택 상단의 작업 궤적을 살펴보면 사실상 이진 트리의 탐색이라는 것을 알 수 있다.<br>

## 3.3.3 스택 프레임 및 스택 영역: 거시적 관점

모든 함수는 실행 시에 자신만의 '작은 상자'가 필요하다.<br>
이 상자 안에는 해당 함수가 실행될 때 사용되는 여러 가지 정보가 저장되어 있으며, 이 상자들은 스택 구조를 통해 구성된다.<br>
여기에서 각각의 작은 상자를 **스택 프레임** 또는 **호출 스택**이라고 하며, 우리가 일반적으로 말하는 프로세스의 스택 영역에 생성된다.<br>
스택 영역 안에서는 높은 주소가 맨 위에 있고 스택 영역은 낮은 주소 방향으로 커진다. 이는 스택 영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가하고 함수 호출이 완료될수록 감소한다는 의미이다.<br>

## 3.3.4 함수 점프와 반환은 어떻게 구현될까?

함수 A가 함수 B를 호출하면, 제어권이 함수 A에서 함수 B로 옮겨진다.<br>
여기에서 제어권은 실제로 CPU가 어떤 함수에 속하는 기계 명령어를 실행하는지 의미한다.<br>
제어권이 이전될 때는 다음 두 가지 정보가 필요하다.
- 반환(return): 어디에서 왔는지에 대한 정보
- 점프(jump): 어디로 가는지에 대한 정보<br>
이런 정보는 스택 프레임을 통해 얻을 수 있다.<br><br>

`call 0x400540` 기계 명령어에 대응하는 것은 코드의 함수 호출이며, call 뒤에 명령어 주소가 하나 있음을 알 수 있다.<br>
해당 주소는 함수 B의 첫 번째 기계 명령어라는 것을 알 수 있다.<br>
따라서 call 기계 명령어를 실행한 직후 CPU는 함수 B로 점프하게 된다.<br>
call 명령어를 실행한 직후, 함수 A에서 call 명령어 다음에 위치한 주소는 함수 A의 스택 프레임에 넣는다.<br>
이런 식으로 함수 B는 마지막 기계 명령어인 ret까지 실행되고, ret 명령어를 통해 CPU는 함수 A의 스택 프레임에 저장된 반환 주소로 점프하도록 전달하여 함수 A로 점프하여 계속 실행된다.<br><br>

## 3.3.5 매개변수 전달과 반환값은 어떻게 구현될까?

CPU는 기계 명령어를 실행할 때 점프와 반환이 가능하기 때문에 이를 이용하여 함수를 호출한다.<br>
그렇다면 함수 이름 외의 매개변수와 반환값은 어떻게 가져올 수 있을까?<br><br>

x86-64에서는 대부분의 경우 매개변수의 전달과 반환값을 가져오는 작업을 레지스터로 한다.<br>
함수 A가 함수 B를 호출한다면 함수 A는 매개변수를 상응하는 레지스터에 저장하며, CPU가 함수 B를 실행할 때 이 레지스터에서 매개변수 정보를 얻을 수 있다.<br>
전달된 매개변수 수가 사용 가능한 레지스터 수보다 많다면 나머지 매개변수는 스택 프레임에 직접 넣을 수 있기 때문에 새로 호출된 함수가 이전 함수의 스택 프레임에서 매개변수를 가져온다.<br>

## 3.3.6 지역 변수는 어디에 있을까?

함수 외부에 정의된 변수를 **전역 변수**라고 하고, 이 변수들은 실행 파일의 데이터 영역에 저장되어 있다 프로그램이 실행되면 프로세스 주소 공간의 데이터 영역에 적재된다.<br>
함수 내부에 정의된 변수는 **지역 변수**라고 하고, 이 변수들은 해당 함수에서만 사용 가능하고 외부에서는 접근이 불가능하다. 지역 변수는 매개변수와 마찬가지로 레지스터에 저장할 수 있지만, 로컬 변수가 레지스터 수보다 많으면 이 변수들도 스택 프레임에 저장되어야 한다.<br>

## 3.3.7 레지스터의 저장과 복원

레지스터는 CPU 내부의 리소스이므로 함수 A와 B에서 동일한 레지스터를 사용하면 함수 A가 함수 B를 호출할 때 함수 A가 레지스터에 기록한 지역 변수 정보를 함수 B가 덮어쓸 수 있다.<br>
따라서 레지스터에 지역 변수를 저장하기 전에 반드시 먼저 레지스터에 원래 저장되었던 초깃값을 꺼냈다 레지스터를 사용하고 나면 다시 그 초깃값을 저장해야 한다.<br>
이러한 초기값은 함수의 스택 프레임에 저장된다.<br>
함수 실행이 완료된 후에는 스택 프레임에 저장되어 있는 초깃값을 상응하는 레지스터에 내용으로 복원하면 된다.<br>

## 3.3.8 큰 그림을 그려 보자, 우리는 지금 어디에 있을까?

스택 프레임은 스택 영역에 위치해 있으며, 스택 영역은 프로세스 주소 공간의 일부이다.<br>
함수가 매번 호출될 때마다 상응하는 스택 프레임은 함수 실행 시 정보를 저장하기 위해 생성되며, 함수 호출 단계가 증가함에 따라 스택 영역이 점점 더 많은 메모리를 차지하게 된다.<br>
하지만 스택 영역의 크기에는 제한이 있으며, 이 제한을 초과하면 **stack overflow** 오류가 발생한다.<br><br>

따라서 프로그래머는 다음을 주의해야 한다.
1. 너무 큰 지역 변수를 만들면 안 된다.
2. 함수 호출 단계가 너무 많으면 안 된다.<br><br>

매개변수가 너무 많으면 일부 매개변수가 스택에 저장되고, 레지스터 내용 중 일부는 스택 프레임에 저장된다.<br>
그렇다면 다음과 같은 의문점이 남는다.<br>
- 매개변수가 너무 많아 레지스터에 저장되지 못한다는 정보는 어떻게 알 수 있을까?
- 스택 영역의 증가와 감소는 어떻게 구현될까?
- 이를 구현하는 책임은 누구에게 있을까?