# 4.6 CPU 진화론(상): 복잡 명령어 집합의 탄생

## 4.6.1 프로그래머의 눈에 보이는 CPU

우리가 작성하는 모든 프로그램은 결국 컴파일러로 하나하나 간단한 기계 명령어로 변환한다. 그렇기에 본질적으로 CPU 입장에서는 프로그램에 따른 차이가 없다.<br>

## 4.6.2 CPU의 능력 범위: 명령어 집합

CPU 능력 범위는 명령어 집합으로 표현한다.<br>
명령어 집합에서 명령어를 하나 찾아 CPU로 보내면 CPU는 해당 명령어가 지시하는 작업을 실행한다.<br>
서로 다른 형태의 CPU는 다른 유형의 명령어 집합을 가지고 있다.<br>
명령어 집합의 유형은 프로그래머가 코드를 작성할 때뿐만 아니라 CPU의 하드웨어 설계에도 영향을 미친다.<br>
오늘날 데스크톱 PC와 서버에 공통으로 사용되는 x86 구조는 복잡 명령어 집합에 기초를 두고 있으며, 이런 x86 프로세서를 생산하는 제조업체는 우리에게 친숙한 Intel과 AMD이다.<br>

## 4.6.3 추상화: 적을수록 좋다

1970년대까지는 컴파일러가 아직 성숙되지 못했기 때문에 많은 프로그램이 어셈블리어로 작성되었다.<br>
따라서 명령어 집합이 더욱더 풍부해야 하며 명렁어 자체 기능도 더 강력해야 한다고 여겼다. 모든 사람이 어셈블리어로 직접 프로그램을 작성했기 때문에 이 방식은 매우 편리하게 여겨졌다.<br><br>

당시에는 함수 호출, 순환 제어, 복잡한 주소 지정 패턴, 데이터 구조, 배열 접근 등 고급 언어의 개념과 이에 직접 대응하는 기계 명령어가 있어야 한다고 생각했다.<br>
기계 명령어와 고급 언어 개념 간 차이를 줄여야만 더 적은 코드로 더 많은 작업을 할 수 있었기 때문이다.<br>
이것이 바로 이 시기 컴퓨터 과학자들이 말하는 의미상 간격을 이어 주는 것에 해당한다.<br><br>

현대 컴파일러는 충분히 강력하고 지능적이므로 운영 체제와 드라이버를 작성하는 사람을 제외한 현대 프로그래머는 어셈블리어의 존재를 거의 인지하지 못한다.<br>

## 4.6.4 코드도 저장 공간을 차지한다

어셈블리어로 코드를 작성할 때 고려해야 할 사항은 저장 공간의 효율적인 사용에 대한 것이다.<br>
오늘날의 컴퓨터는 기본적으로 폰 노이만 구조를 따른다. 이 구조의 핵심 사상은 **저장 개념에서 프로그램과 프로그램이 사용하는 데이터에 어떤 차이도 없어야 하며, 모두 컴퓨터의 저장 장치 안에 저장될 수 있어야 한다**는 것이다.<br><br>

![폰 노이만 구조](https://upload.wikimedia.org/wikipedia/commons/e/e5/Von_Neumann_Architecture.svg)<br>
폰 노이만 구조에서 실행 파일은 기계 명령어와 데이터를 모두 포함하고 있다는 것을 알 수 있다.<br>
또한 프로그래머가 작성한 코드는 디스크 저장 공간을 차지하며 실행 시에는 메모리에 적자되므로 메모리 저장 공간을 차지한다는 것을 알 수 있다.<br>
1970년대에는 메모리 크기가 겨우 몇 KB였으므로 작은 메모리에 더 많은 프로그램을 적재하려면 기계 명령어를 반드시 매우 세밀하게 설계해서 프로그램에서 차지하는 저장 공간을 줄여야 한다.<br><br>

이에 따라 다음 요구사항을 만족해야 한다.<br>
1. 하나의 기계 명령어로 더 많은 작업을 완료할 수 있으므로 프로그래머가 더 효율적으로 코드를 작성할 수 있게 해준다.
2. 기계 명령어 길이가 고정되어 잇찌 않아 프로그램 자체가 차지하는 저장 공간을 줄일 수 있다.
3. 기계 명령어는 밀도를 높여 공간ㅇ르 절약하려고 고도로 인코딩된다.<br>

## 4.6.5 필연적인 복잡 명령어 집합의 탄생

명령어를 사용한 편리한 프로그램을 작성하고 코드의 저장 공간을 절약해야 했기에 복잡 명령어 집합을 설계해야 하는 필요성이 대두되었다.<br>
그러나 얼마 후 새로운 문제가 발견되었다.<br>
이 시기 CPU 명령어 집합은 모두 직접 연결 방식이었다. 즉, 명령어 인출, 명령어 해독, 실행 등 각 단계가 특정 조합 회로로 직접 제어되기 때문에 유연성이 무척 떨어져 명령어 집합의 변경에 대응하기 어려웠다.<br><br>

이를 해결하기 위해 대부분의 명령어에 포함된 연산을 더 간단한 명령어로 구성된 작은 프로그램으로 정의하고 이를 CPU에 저장했다.<br>
이제 소프트웨어가 하드웨어를 대체하게 되어 모든 기계 명령어에 대응하기 위해 전용 하드웨어 회로를 설계할 필요가 없다.<br>
여기에서 사용되는 더 간단한 명령어가 바로 **마이크로코드**이다.<br>
더 많은 명령어를 추가할 때, 주요 작업은 마이크로코드 수정에 집중되며 하드웨어 수정은 거의 필요하지 않기에 CPU 설계 복잡도를 낮출 수 있다.<br>

## 4.6.6 마이크로코드 설계의 문제점

복잡 명령어 집합이 등장하면서 프로그래머는 어셈블리어로 프로그램을 더 쉽게 작성할 수 있게 되었고, 프로그램이 많은 저장 공간을 차지하지도 않게 되었다.<br>
복잡 명령어 집합으로 발생하는 프로세서 설계의 복잡한 문제는 마이크로코드로 단순화할 수 있다.<br><br>

하지만 마이크로코드의 버그를 수정하는 것은 일반 프로그램의 버그를 수정하는 것보다 훨씬 더 어려울 뿐만 아니라, 마이크로코드 설계가 트랜지스터를 매우 많이 소모한다는 문제가 발견되었다.<br>
