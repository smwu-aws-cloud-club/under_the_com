# 4. 트랜지스터에서 CPU로, 이보다 더 중요한 것은 없다

## 4.1 이 작은 장난감을 CPU라고 부른다

프로그래머가 작성한 프로그램이 아무리 복잡해도 소프트웨어가 수행하는 기능은 최종적으로 트랜지스터의 간단한 개폐 작업으로 완성된다.<br>
트랜지스터라는 스위치를 기초로 삼아 다음 세 가지 회로를 만들 수 있다.
- 논리곱 게이트: 스위치 두 개가 동시에 켜질 때만 전류가 흐르고 등이 켜진다
- 논리합 게이트: 두 스위치 중 하나라도 켜져 있으면 전류가 흐를 수 있으며 등이 켜진다
- 논리부정 게이트: 스위치를 닫으면 전류가 흘러 등이 켜지고, 스위치를 열면 전류가 흐르지 않고 등이 꺼진다

<br>

논리적 완전성이란 논리곱 게이트, 논리합 게이트, 논리부정 게이트로 모든 논리를 표현할 수 있다는 것이다.<br>
따라서 컴퓨터는 간단한 논리곱 게이트, 논리합 게이트, 논리부정 게이트로 구성되었다. 

CPU는 0과 1의 2진법만 알고 있다.<br>
두 입력 값이 서로 다르면 결과가 1이고, 두 입력 값이 서로 같으면 결과가 0이다.<br>
이것을 **배타적 논리합**이라고 하고, 논리곱 게이트 한 개와 배타적 논리합 게이트 한 개를 조합하면 2진 덧셈을 구현할 수 있다.<br>
CPU의 연산 능력은 여기에서 비롯된 것이며, 요구 사항에 따라 다른 산술 연산도 설계할 수 있다.

![NAND Gate](/esc/CH4/images/nand_gate.png)<br>
입력과 출력은 이를 저장할 곳이 있어야 하므로 정보를 저장할 수 있는 회로가 필요하다.<br>
논리곱 게이트, 논리부정 게이트를 조합한 **부정 논리곱 게이트**를 이용해서 저장을 할 수 있다.<br>
부정 논리곱 게이트는 먼저 논리곱 연산을 처리한 후 논리부정 연산을 처리한다.<br>
S단자와 R단자에 1이 입력되는 한 이 회로는 다음과 같이 두 가지 상태를 가진다.<br>
- 단자 a가 1이면, B = 0, A = 1, b = 0
- 단자 a가 0이면, B = 1, A = 0. b = 1<br>
이외에 다른 상태는 존재하지 않으므로 단자 a 값을 회로의 출력으로 사용한다.

S단자를 0으로 설정하면 단자 a는 항상 1이 된다. 이때 회로에는 1이 저장되어 있다고 할 수 있다.<br>
R단자를 0으로 설정하면 단자 a는 항상 0이 된다. 이때 회로에는 0이 저장되어 있다고 할 수 있다.<br>
회로에 WE 단자를 추가해 저장 여부를 선택하는 데 사용한다.<br>
입력 단이 D단자 하나가 되도록 수정하면 D 단자가 0이면 전체 회로가 저장하는 것은 0이며, 그렇지 않으면 1이 된다.

더 많은 비트를 저장하기 위해서는 회로를 조합한 **레지스터**를 사용하면 된다.<br>
더 많은 정보를 저장하고 주소 지정 기능을 제공하기 위해 8비트를 1바이트로 규정하고, 각각의 바이트가 자신의 번호를 받아 부여된 번호를 이용하여 저장된 정보를 읽을 수 있는 **메모리**가 탄생했다.<br>
회로는 정보를 저장할 수 있지만 전원이 끊기면 저장된 정보는 모두 사라진다.

실제로 모든 논리 함수를 논리곱 게이트, 논리합 게이트, 논리부정 게이트를 사용해서 구현하는 것은 비현실적이다.<br>
모든 연산 논리를 반드시 회로 같은 하드웨어로 구현할 필요는 없다.<br>
하드웨어는 가장 기본적인 기능만 제공하고 모든 연산 논리는 기본적인 기능을 이용하여 소프트웨어로 표현하는 것이 가장 좋은 방법이다.<br>
하드웨어는 변하지 않지만 소프트웨어는 변할 수 있기에 변하지 않는 하드웨어에 서로 다른 소프트웨어를 제공하면 하드웨어가 완전히 새로운 기능을 구현할 수 있다.

CPU에게 조합 회로를 이용하여 기계 명령어로 무엇을 계산할지 알려줘야 한다.<br>
CPU는 연산 능력만 제공하고, 프로그래머가 피연산자를 제공한다.<br>
CPU 표현 방식은 명령어 집합을 이용하여 구현된다.

명령어 집합: CPU가 실행할 수 있는 명령어(opcode)와 각 명령어에 필요한 피연산자(operand)를 묶은 것<br>
고급 언어로 작성한 프로그램이 간단하든 매우 복잡하든 간에 결국에는 명령어로 변환된 후 CPU에서 하나하나 실행된다.<br>
시스템 계층 관점에서 보면, 명령어 집합은 소프트웨어와 하드웨어가 만나는 곳이다.<br>
고급 프로그래밍 언어는 인간 언어와 매우 유사하여 프로그래머 생산성을 크게 향상시키지만, CPU는 여전히 기계 명령어만 이해할 수 있으므로 고급 프로그래밍 언어를 기계 명령어로 변환하는 컴파일러가 필요하다.

각 부분의 회로가 함께 작업할 수 있도록 조정하거나 동기화하려면 어떻게 해야 할까?<br>
CPU에서 지휘자 역할을 맡고 있는 것이 **클럭 신호**이다.
클럭 신호가 전압을 변경할 때마다 전체 회로의 각 레지스터, 즉 전체 회로 상태가 갱신된다.

각종 계산이 가능한 산술 논리 장치, 정보를 저장할 수 있는 레지스터, 작업을 함께하도록 제어해 주는 클럭 신호를 묶은 것을 일컬어 **중앙 처리 장치(CPU) 또는 프로세서**라고 한다.<br>
CPU는 컴퓨터 시스템에 모든 것과 관련이 있다.

<br>

## 4.2 CPU는 유휴 상태일 때 무엇을 할까?

대부분 CPU의 사용률은 7~8% 정도로 매우 낮으며 대부분 컴퓨터의 CPU 사용률은 높지 않다.<br>
작업 관리자를 확인해 보면 많은 프로세스는 기본적으로 아무런 작업도 하고 있지 않으며, 특정 이벤트가 발생하여 자신을 깨우기를 기다리고 있다.

작업 관리자에서 세부 정보 탭을 열어 보면 'System Idle Process' 항목이 대부분 90%가 넘는 CPU 사용률을 보이며, 때로는 99% 사용률을 보이는 것을 확인할 수 있다.<br>
이는 이 프로세스가 거의 모든 CPU 시간을 소모하고 있음을 의미한다.<br>
운영 체제는 프로세스에 우선순의를 할당하고, 우선순의에 따라 스케줄러가 스케줄링을 할 수 있도록 대기열에 프로세스를 넣는다.

운영 체제는 대기열을 이용하여 프로세스를 관리한다.<br>
준비 완료 대기열이 비어 있다면 운영 체제가 스케줄링해야 하는 프로세스가 없고, CPU가 유휴 상태에 있다는 것을 의미한다.<br>
대기열을 가득 채워 스케줄러가 대기열에서 항상 실행할 수 있는 프로세스를 찾도록 하면 예외 처리 없이 스케줄링을 할 수 있다.<br>
일반적으로 **감시자** 노드를 사용하여 별도의 NULL 판단 로직을 제거해 코드 오류 가능성을 줄이고 구조를 깔끔하게 유지한다.<br>
커널 설계자가 만든 유휴 작업 프로세스가 'System Idle Process'이다.<br>
시스템에 스케줄링 가능한 프로세스가 없을 때 스케줄러는 이 유휴 프로세스를 꺼내서 실행한다.<br>
유휴 프로세스는 항상 준비 완료 상태에 있으며 우선순위는 가장 낮다.

`halt` 명령어는 CPU 내부의 일부 모듈을 절전 상태로 전환하여 전력 소비를 크게 줄인다.<br>
`halt` 명령어는 특권 명령어라 커널 상태에서 CPU로만 실행될 수 있다.<br>
`sleep` 같은 프로세스 일시 중지 함수는 해당 함수를 호출한 프로세스만 일시 중지되고, 다른 프로세스가 여전히 실행 중이라면 CPU는 유휴 상태로 진입할 수 없다.<br>
스케줄링 가능한 프로세스가 더 이상 존재하지 않으면 스케줄러가 유휴 프로세스를 실행하는데, 이것으로 순환 구조에서 계속 `halt` 명령어가 실행되고 CPU는 저전력 상태로 진입한다.

운영 체제는 일정 시간마다 타이머 인터럽트를 생성하고, CPU는 인터럽트 신호를 감지하고 운영 체제 내부의 인터럽트 처리 프로그램을 실행한다.<br>
상응하는 인터럽트 처리 함수에서는 프로세스가 실행될 준비가 되었는지 판단하고, 준비가 되었다면 중단되었던 프로세스를 계속 실행한다.<br>
준비되어 있지 않았다면 프로세스를 일시 중지시키고, 스케줄러는 준비 완료 상태인 다른 프로세스를 스케줄링한다.<br>
프로그램에 무한 순환이 있더라도 운영 체제는 타이머 인터럽트를 통해 프로세스의 스케줄링을 제어할 수 있으며, 무한 순환이 있다고 운영 체제가 실행하지 못하는 문제는 발생하지 않는다.

<br>

## 4.3 CPU는 숫자를 어떻게 인식할까?

컴퓨터 시스템의 2진법은 위치 기수법을 사용하여 숫자를 표현한다.<br>
비트 k개를 사용하면 정수 2^k개를 나타낼 수 있고, 범위는 0 ~ 2^k -1이다.<br>
2^k개의 정수를 반으로 나눠, 절반은 양수를 나타내는 데 사용하고, 나머지 절반은 음수를 나타내는 데 사용한다.<br>
이 표시 방식에서는 최상위 비트가 정수 부호를 결정하며 이 값이 0이면 양수, 그렇지 않으면 음수라고 정의한다.

부호-크기 표현은 최상위 비트가 0이면 양수, 1이면 음수로 표현한다.<br>
하지만 0000이 0을 의미하고, 1000도 0을 의미하여 0과 -0은 같은 숫자이지만 다르게 표현된다는 문제가 발생한다.<br>

0010이 +2를 의미하므로, 이를 완전히 반전시킨 1101을 -2로 표시하는 방식을 **1의 보수**라고 한다.<br>
1의 보수 표현 방식에서도 0000은 0이며, 이것의 1의 보수인 1111은 -0이다.<br>
이와 같이 1의 보수 표현 방식은 부호-크기 표현 방식과 크게 다르지 않음을 알 수 있다.<br>
이러한 표기 방식들에서는 두 숫자를 더할 때 문제가 발생한다.

2 + (-2)를 계산해보자.<br>
부호 크기 표현 방식에서 2는 0010이고 -2는 1010이므로, 덧셈을 계산하면 1100이므로 결과가 -4이다.<br>
이는 잘못된 덧셈 결과이다.<br>

1의 보수 방식에서 2는 0010이고 -2는 1101이므로, 두 숫다를 더하면 1111이 되어 결과가 -0이다.<br>
-0이라는 값은 우아하지는 않지만 모순된 결과는 아니다.

여기에서 핵심은 `A + (-A) = 0`을 가능하게 하면서 동시에 0을 표현할 때 2진법에서 0000이라는 표현 한 가지만 존재하는 표현 방법이 필요하다는 것이다.<br>
따라서 `A + (-A) = 0`를 만족하도록 음수 비트를 표현하는 방식이 2의 보수이다.<br>
이 표현 방식에는 -0이 없고, -8~7 범위의 숫자를 표시할 수 없다.<br>
또한 1의 보수로 표현한 양수에 1을 더하면 2의 보수에서 대응하는 음수가 된다.

가산기는 양수와 음수에 대해 전혀 신경 쓰지 않을 뿐만 아니라, 근본적으로 2비트로 나타낸 숫자가 가지고 있는 의미조차 이해하지 못한다.<br>
단지 두 비트의 배타적 논리합 연산이 덧셈의 결과라는 것과 두 비트의 논리곱 연산이 자리 올림수라는 것만 알고 있다.<br>
이것에서 우리는 CPU 자체는 인간 두뇌에 존재하는 개념들을 이해할 수 없다는 것을 반드시 이해해야 한다.<br>
CPU는 단순한 세포와 같아서 자극을 주면 반응을 하는 것과 마찬가지로 명령을 내리면 실행할 뿐이다.<br>

거시적으로 보면 전체 시스템은 다음과 같이 동작한다.<br>
프로그래머는 두뇌의 바다를 헤엄치고 있는 사고 문제를 프로그램 방식으로 표현하고, 컴파일러는 인간이 이해할 수 있는 프로그램을 CPU를 제어할 때 사용하는 0과 1로 구성된 기계 명령어로 변환한다.<br>
출력 역시 0과 1의 연속이며, 이를 해석하는 것이 소프트웨어가 하는 일이다.<br>
따라서 CPU는 인간 개념을 이해하지 못하며, 인간이 제어해서 주어진 작업을 처리할 뿐이다.

<br>

## 4.4 CPU가 if 문을 만났을 때

C언어로 크기가 10,000인 정수 배열을 만들고 배열에서 128보다 큰 모든 요소의 합을 계산하는 작업을 100,000번 반복하는 코드를 실행해보자.<br>
배열 요소가 이미 정렬된 상태라면 2.8초 만에 실행이 완료되지만, 배열 요소가 임의로 배치되어 있다면 실행 시간이 7.5초에 달한다.<br>
리눅스의 `perf` 도구를 사용하여 프로그램이 실행 중일 때 CPU와 관련된 정보들을 확인해보자.<br>
분기 예측 실패율을 나타내는 branch-misses 항목에서 정렬된 배열을 이용한 프로그램에서는 예측 실패율이 0.02%에 불과하지만, 정렬되지 않은 배열을 이용한 프로그램에서는 최고 14.12%에 달한다.

파이프라인 기술이란 각 공정 단계를 수십 개로 나누고 각 단계마다 전문가를 배치하는 것이다.<br>
파이프라인 기술은 전체 처리 시간을 줄이는 것이 아니라 CPU의 처리 능력을 늘리는 것이다.

CPU 자체를 기계 명령어를 실행하는 메가팩토리로 생각할 수 있다.<br>
하나의 기계 명령어를 처리할 때 명령어 인출, 명령어 해독, 실행, 다시 쓰기 네 단계를 실행해야 한다.<br>
각 단계는 별도의 하드웨어로 처리된다.<br>
현재 CPU는 기계 명령어를 초당 수십억 개 처리할 수 있는 능력을 갖추고 잇으며, 파이프라인 기술은 필수 불가결하다.

프로그래머가 작성한 if 문은 일반적으로 컴파일러가 조건부 점프 명령어로 변환하며, 이 명령어는 분기 역할을 한다.<br>
조건이 참이면 점프해야 하고, 그렇지 않으면 순차적으로 실행된다.

분기 점프 명령어가 실행을 완료하기 전에 다음 명령어는 이미 파이프라인에 들어가 있어야 한다. 그렇지 않으면 파이프라인에 빈 공간이 생겨 프로세서의 리소스를 완전하게 사용할 수 없기 때문이다.<br>
이때 문제가 발생한다. 분기 점프 명령어는 자신의 실행 겨로가에 따라 점프 여부를 결정해야 하는데, 이 명령어 실행이 완료되지 않은 시점에서 CPU는 어떤 분기의 명령어를 파이프라인에 넣어야 할지 알 수 없다.<br>
따라서 CPU는 미리 예측을 한다.

CPU는 뒤이어 어디로 분기할 가능성이 있는지 추측한다.<br>
추측이 맞았다면 파이프라인은 계속 앞으로 흘러가고, 추측이 틀렸다면 파이프라인에서 이미 실행 중이던 잘못된 분기 명령어 모두를 무효화한다.<br>
이처럼 CPU 추측이 틀리면 바로 성능 손실이 발생한다.<br>
최신 CPU의 이런 추측 과정을 **분기 예측**이라고 한다.

배열이 정렬되어 있으면 if 조건의 결과는 매우 규칙적이다. 반면에 배열이 정렬되어 있지 않으면 if 조건의 결과는 규칙성이 없다.<br>
정렬되지 않은 배열을 사용하면 분기 예측 실패율이 매우 높아지고 프로그램 성능이 떨어진다.<br>
이것이 프로그래밍 언어에 `ㅣikely/unlikely` 매크로가 있는 이유이다.<br>
해당 매크로를 이용하여 컴파일러에 가능성이 더 높은 분기를 알려줄 수 있고, 컴파일러는 더 목적성을 가지고 최적화를 할 수 있다.

<br>

## 4.5 CPU 코어 수와 스레드 수 사이의 관계는 무엇일까?

요리사는 레시피에 따라 특정 작업을 실해앟여 특정한 요리를 만들고, CPU는 기계 명령어에 따라 프로세스와 스레드를 실행한다.<br>
운영 체제 입장에서 CPU가 사용자 상태에서 실행하는 명령어는 모두 스레드 또는 특정 스레드에 속해 있다. 따라서 명령어에 따라 프로세스를 실행한다.<br>
요리사 수는 CPU 코어 수에 비유할 수 있으며, 일정 시간 동안 볶을 수 잇는 요리 수는 스레드 수에 비유할 수 있다.<br>
CPU 코어 수와 스레드 수 사이에는 어떤 필연 관계도 없다. CPU는 하드웨어인데 반해 스레드는 소프트웨어 개념, 더 정확하게는 실행 흐름이자 작업이다.<br>
따라서 단일 코어 시스템에서도 메모리가 충분하고, 운영 체제에 제한이 없다면 얼마든지 많은 스레드를 생성할 수 있다.

CPU는 근본적으로 자신이 실행하는 명령어가 어떤 스레드에 속하는지 이해하지 못하며, 이를 이해해야 하는 것은 운영 체제이다.<br>
CPU가 해야 하는 일은 PC 레지스터 주소에 따라 메모리에서 기계 명령어를 꺼내 실해아는 것뿐이다.

단일 코어 시스템에서는 CPU는 일정 시간 동안 단 하나의 스레드만 실행할 수 있어 스레드 여러 개가 번갈아 실행되기는 하지만, 진정한 병렬 처리라고는 할 수 없다.<br>
그렇다고 단일 코어에서 단일 코어에서 다중 스레드가 의미가 없는 것은 아니다.<br>
스레드라는 개념은 프로그래머에게 매우 편리한 추상화 방법을 제공하므로 작업 하나를 여러 개로 분할한 후 각각의 하위 작업을 별도의 스레드에 배치하면 운영 체제에서 이를 스케줄링하고 실행할 수 있으므로 동시에 여러 작업을 실행할 수 있다.<br>
예를 들어 사용자 인터페이스 요소 뒤에서 대량의 계산을 수행해야 한다고 할 때, 계산 작업을 별도의 스레드에 넣어 계산을 수행하는 동안 사용자 인터페이스가 멈추는 것을 방지할 수 있다.<br>
이외에도 처리해야 하는 작업이 블로킹 입출력과 관련되었을 때 해당 블로킹 호출을 별도의 스레드에서 실행하면 나머지 코드는 영향 없이 계속 실행될 수 있다.<br>
스레드가 특정 작업을 기다리지 않고 진행하는 것이 목적이라면, 필요에 따라 스레드 여러 개를 생성하고 작업을 분할하여 스레드에서 실행해도 된다.

다중 코어 리소스를 최대한 활용해야 할 때 프로그래머가 가장 선호하는 도구는 스레드이다.<br>
일반적으로 생성되는 스레드 수는 코어 수와 일정한 선형 관계를 유지해야 한다.<br>
스레드가 순수하게 계싼을 위한 것이고 입출력이나 동기화 같은 작업이 없다면, 코어당 스레드 하나가 가장 나은 선택이다. 그러나 스레드에는 일정한 입출력과 동기화 등이 필요하므로 이때는 스레드 수를 적당히 늘려 운영 체제가 CPU에 할당할 수 있는 충분한 스레드를 확보하면 시스템 성능을 향상시킬 수 있다.<br>
하지만 스레드 수가 한계에 달하면 운영 체제 성능이 떨어지기 시작하는데, 이는 한 스레드에서 다른 스레드로 전환할 때 부담이 증가하기 때문이다.