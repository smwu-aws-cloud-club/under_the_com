# 4. 트랜지스터에서 CPU로, 이보다 더 중요한 것은 없다

## 4.1 이 작은 장난감을 CPU라고 부른다

프로그래머가 작성한 프로그램이 아무리 복잡해도 소프트웨어가 수행하는 기능은 최종적으로 트랜지스터의 간단한 개폐 작업으로 완성된다.<br>
트랜지스터라는 스위치를 기초로 삼아 다음 세 가지 회로를 만들 수 있다.
- 논리곱 게이트: 스위치 두 개가 동시에 켜질 때만 전류가 흐르고 등이 켜진다
- 논리합 게이트: 두 스위치 중 하나라도 켜져 있으면 전류가 흐를 수 있으며 등이 켜진다
- 논리부정 게이트: 스위치를 닫으면 전류가 흘러 등이 켜지고, 스위치를 열면 전류가 흐르지 않고 등이 꺼진다

<br>

논리적 완전성이란 논리곱 게이트, 논리합 게이트, 논리부정 게이트로 모든 논리를 표현할 수 있다는 것이다.<br>
따라서 컴퓨터는 간단한 논리곱 게이트, 논리합 게이트, 논리부정 게이트로 구성되었다. 

CPU는 0과 1의 2진법만 알고 있다.<br>
두 입력 값이 서로 다르면 결과가 1이고, 두 입력 값이 서로 같으면 결과가 0이다.<br>
이것을 **배타적 논리합**이라고 하고, 논리곱 게이트 한 개와 배타적 논리합 게이트 한 개를 조합하면 2진 덧셈을 구현할 수 있다.<br>
CPU의 연산 능력은 여기에서 비롯된 것이며, 요구 사항에 따라 다른 산술 연산도 설계할 수 있다.

![NAND Gate](/esc/CH4/images/nand_gate.png)<br>
입력과 출력은 이를 저장할 곳이 있어야 하므로 정보를 저장할 수 있는 회로가 필요하다.<br>
논리곱 게이트, 논리부정 게이트를 조합한 **부정 논리곱 게이트**를 이용해서 저장을 할 수 있다.<br>
부정 논리곱 게이트는 먼저 논리곱 연산을 처리한 후 논리부정 연산을 처리한다.<br>
S단자와 R단자에 1이 입력되는 한 이 회로는 다음과 같이 두 가지 상태를 가진다.<br>
- 단자 a가 1이면, B = 0, A = 1, b = 0
- 단자 a가 0이면, B = 1, A = 0. b = 1<br>
이외에 다른 상태는 존재하지 않으므로 단자 a 값을 회로의 출력으로 사용한다.

S단자를 0으로 설정하면 단자 a는 항상 1이 된다. 이때 회로에는 1이 저장되어 있다고 할 수 있다.<br>
R단자를 0으로 설정하면 단자 a는 항상 0이 된다. 이때 회로에는 0이 저장되어 있다고 할 수 있다.<br>
회로에 WE 단자를 추가해 저장 여부를 선택하는 데 사용한다.<br>
입력 단이 D단자 하나가 되도록 수정하면 D 단자가 0이면 전체 회로가 저장하는 것은 0이며, 그렇지 않으면 1이 된다.

더 많은 비트를 저장하기 위해서는 회로를 조합한 **레지스터**를 사용하면 된다.<br>
더 많은 정보를 저장하고 주소 지정 기능을 제공하기 위해 8비트를 1바이트로 규정하고, 각각의 바이트가 자신의 번호를 받아 부여된 번호를 이용하여 저장된 정보를 읽을 수 있는 **메모리**가 탄생했다.<br>
회로는 정보를 저장할 수 있지만 전원이 끊기면 저장된 정보는 모두 사라진다.

실제로 모든 논리 함수를 논리곱 게이트, 논리합 게이트, 논리부정 게이트를 사용해서 구현하는 것은 비현실적이다.<br>
모든 연산 논리를 반드시 회로 같은 하드웨어로 구현할 필요는 없다.<br>
하드웨어는 가장 기본적인 기능만 제공하고 모든 연산 논리는 기본적인 기능을 이용하여 소프트웨어로 표현하는 것이 가장 좋은 방법이다.<br>
하드웨어는 변하지 않지만 소프트웨어는 변할 수 있기에 변하지 않는 하드웨어에 서로 다른 소프트웨어를 제공하면 하드웨어가 완전히 새로운 기능을 구현할 수 있다.

CPU에게 조합 회로를 이용하여 기계 명령어로 무엇을 계산할지 알려줘야 한다.<br>
CPU는 연산 능력만 제공하고, 프로그래머가 피연산자를 제공한다.<br>
CPU 표현 방식은 명령어 집합을 이용하여 구현된다.

명령어 집합: CPU가 실행할 수 있는 명령어(opcode)와 각 명령어에 필요한 피연산자(operand)를 묶은 것<br>
고급 언어로 작성한 프로그램이 간단하든 매우 복잡하든 간에 결국에는 명령어로 변환된 후 CPU에서 하나하나 실행된다.<br>
시스템 계층 관점에서 보면, 명령어 집합은 소프트웨어와 하드웨어가 만나는 곳이다.<br>
고급 프로그래밍 언어는 인간 언어와 매우 유사하여 프로그래머 생산성을 크게 향상시키지만, CPU는 여전히 기계 명령어만 이해할 수 있으므로 고급 프로그래밍 언어를 기계 명령어로 변환하는 컴파일러가 필요하다.

각 부분의 회로가 함께 작업할 수 있도록 조정하거나 동기화하려면 어떻게 해야 할까?<br>
CPU에서 지휘자 역할을 맡고 있는 것이 **클럭 신호**이다.
클럭 신호가 전압을 변경할 때마다 전체 회로의 각 레지스터, 즉 전체 회로 상태가 갱신된다.

각종 계산이 가능한 산술 논리 장치, 정보를 저장할 수 있는 레지스터, 작업을 함께하도록 제어해 주는 클럭 신호를 묶은 것을 일컬어 **중앙 처리 장치(CPU) 또는 프로세서**라고 한다.<br>
CPU는 컴퓨터 시스템에 모든 것과 관련이 있다.

<br>

## 4.2 CPU는 유휴 상태일 때 무엇을 할까?

대부분 CPU의 사용률은 7~8% 정도로 매우 낮으며 대부분 컴퓨터의 CPU 사용률은 높지 않다.<br>
작업 관리자를 확인해 보면 많은 프로세스는 기본적으로 아무런 작업도 하고 있지 않으며, 특정 이벤트가 발생하여 자신을 깨우기를 기다리고 있다.

작업 관리자에서 세부 정보 탭을 열어 보면 'System Idle Process' 항목이 대부분 90%가 넘는 CPU 사용률을 보이며, 때로는 99% 사용률을 보이는 것을 확인할 수 있다.<br>
이는 이 프로세스가 거의 모든 CPU 시간을 소모하고 있음을 의미한다.<br>
운영 체제는 프로세스에 우선순의를 할당하고, 우선순의에 따라 스케줄러가 스케줄링을 할 수 있도록 대기열에 프로세스를 넣는다.

운영 체제는 대기열을 이용하여 프로세스를 관리한다.<br>
준비 완료 대기열이 비어 있다면 운영 체제가 스케줄링해야 하는 프로세스가 없고, CPU가 유휴 상태에 있다는 것을 의미한다.<br>
대기열을 가득 채워 스케줄러가 대기열에서 항상 실행할 수 있는 프로세스를 찾도록 하면 예외 처리 없이 스케줄링을 할 수 있다.<br>
일반적으로 **감시자** 노드를 사용하여 별도의 NULL 판단 로직을 제거해 코드 오류 가능성을 줄이고 구조를 깔끔하게 유지한다.<br>
커널 설계자가 만든 유휴 작업 프로세스가 'System Idle Process'이다.<br>
시스템에 스케줄링 가능한 프로세스가 없을 때 스케줄러는 이 유휴 프로세스를 꺼내서 실행한다.<br>
유휴 프로세스는 항상 준비 완료 상태에 있으며 우선순위는 가장 낮다.

`halt` 명령어는 CPU 내부의 일부 모듈을 절전 상태로 전환하여 전력 소비를 크게 줄인다.<br>
`halt` 명령어는 특권 명령어라 커널 상태에서 CPU로만 실행될 수 있다.<br>
`sleep` 같은 프로세스 일시 중지 함수는 해당 함수를 호출한 프로세스만 일시 중지되고, 다른 프로세스가 여전히 실행 중이라면 CPU는 유휴 상태로 진입할 수 없다.<br>
스케줄링 가능한 프로세스가 더 이상 존재하지 않으면 스케줄러가 유휴 프로세스를 실행하는데, 이것으로 순환 구조에서 계속 `halt` 명령어가 실행되고 CPU는 저전력 상태로 진입한다.

운영 체제는 일정 시간마다 타이머 인터럽트를 생성하고, CPU는 인터럽트 신호를 감지하고 운영 체제 내부의 인터럽트 처리 프로그램을 실행한다.<br>
상응하는 인터럽트 처리 함수에서는 프로세스가 실행될 준비가 되었는지 판단하고, 준비가 되었다면 중단되었던 프로세스를 계속 실행한다.<br>
준비되어 있지 않았다면 프로세스를 일시 중지시키고, 스케줄러는 준비 완료 상태인 다른 프로세스를 스케줄링한다.<br>
프로그램에 무한 순환이 있더라도 운영 체제는 타이머 인터럽트를 통해 프로세스의 스케줄링을 제어할 수 있으며, 무한 순환이 있다고 운영 체제가 실행하지 못하는 문제는 발생하지 않는다.

<br>

## 4.3 CPU는 숫자를 어떻게 인식할까?

컴퓨터 시스템의 2진법은 위치 기수법을 사용하여 숫자를 표현한다.<br>
비트 k개를 사용하면 정수 2^k개를 나타낼 수 있고, 범위는 0 ~ 2^k -1이다.<br>
2^k개의 정수를 반으로 나눠, 절반은 양수를 나타내는 데 사용하고, 나머지 절반은 음수를 나타내는 데 사용한다.<br>
이 표시 방식에서는 최상위 비트가 정수 부호를 결정하며 이 값이 0이면 양수, 그렇지 않으면 음수라고 정의한다.

부호-크기 표현은 최상위 비트가 0이면 양수, 1이면 음수로 표현한다.<br>
하지만 0000이 0을 의미하고, 1000도 0을 의미하여 0과 -0은 같은 숫자이지만 다르게 표현된다는 문제가 발생한다.<br>

0010이 +2를 의미하므로, 이를 완전히 반전시킨 1101을 -2로 표시하는 방식을 **1의 보수**라고 한다.<br>
1의 보수 표현 방식에서도 0000은 0이며, 이것의 1의 보수인 1111은 -0이다.<br>
이와 같이 1의 보수 표현 방식은 부호-크기 표현 방식과 크게 다르지 않음을 알 수 있다.<br>
이러한 표기 방식들에서는 두 숫자를 더할 때 문제가 발생한다.

2 + (-2)를 계산해보자.<br>
부호 크기 표현 방식에서 2는 0010이고 -2는 1010이므로, 덧셈을 계산하면 1100이므로 결과가 -4이다.<br>
이는 잘못된 덧셈 결과이다.<br>

1의 보수 방식에서 2는 0010이고 -2는 1101이므로, 두 숫다를 더하면 1111이 되어 결과가 -0이다.<br>
-0이라는 값은 우아하지는 않지만 모순된 결과는 아니다.

여기에서 핵심은 `A + (-A) = 0`을 가능하게 하면서 동시에 0을 표현할 때 2진법에서 0000이라는 표현 한 가지만 존재하는 표현 방법이 필요하다는 것이다.<br>
따라서 `A + (-A) = 0`를 만족하도록 음수 비트를 표현하는 방식이 2의 보수이다.<br>
이 표현 방식에는 -0이 없고, -8~7 범위의 숫자를 표시할 수 없다.<br>
또한 1의 보수로 표현한 양수에 1을 더하면 2의 보수에서 대응하는 음수가 된다.

가산기는 양수와 음수에 대해 전혀 신경 쓰지 않을 뿐만 아니라, 근본적으로 2비트로 나타낸 숫자가 가지고 있는 의미조차 이해하지 못한다.<br>
단지 두 비트의 배타적 논리합 연산이 덧셈의 결과라는 것과 두 비트의 논리곱 연산이 자리 올림수라는 것만 알고 있다.<br>
이것에서 우리는 CPU 자체는 인간 두뇌에 존재하는 개념들을 이해할 수 없다는 것을 반드시 이해해야 한다.<br>
CPU는 단순한 세포와 같아서 자극을 주면 반응을 하는 것과 마찬가지로 명령을 내리면 실행할 뿐이다.<br>

거시적으로 보면 전체 시스템은 다음과 같이 동작한다.<br>
프로그래머는 두뇌의 바다를 헤엄치고 있는 사고 문제를 프로그램 방식으로 표현하고, 컴파일러는 인간이 이해할 수 있는 프로그램을 CPU를 제어할 때 사용하는 0과 1로 구성된 기계 명령어로 변환한다.<br>
출력 역시 0과 1의 연속이며, 이를 해석하는 것이 소프트웨어가 하는 일이다.<br>
따라서 CPU는 인간 개념을 이해하지 못하며, 인간이 제어해서 주어진 작업을 처리할 뿐이다.

<br>

## 4.4 CPU가 if 문을 만났을 때

C언어로 크기가 10,000인 정수 배열을 만들고 배열에서 128보다 큰 모든 요소의 합을 계산하는 작업을 100,000번 반복하는 코드를 실행해보자.<br>
배열 요소가 이미 정렬된 상태라면 2.8초 만에 실행이 완료되지만, 배열 요소가 임의로 배치되어 있다면 실행 시간이 7.5초에 달한다.<br>
리눅스의 `perf` 도구를 사용하여 프로그램이 실행 중일 때 CPU와 관련된 정보들을 확인해보자.<br>
분기 예측 실패율을 나타내는 branch-misses 항목에서 정렬된 배열을 이용한 프로그램에서는 예측 실패율이 0.02%에 불과하지만, 정렬되지 않은 배열을 이용한 프로그램에서는 최고 14.12%에 달한다.

파이프라인 기술이란 각 공정 단계를 수십 개로 나누고 각 단계마다 전문가를 배치하는 것이다.<br>
파이프라인 기술은 전체 처리 시간을 줄이는 것이 아니라 CPU의 처리 능력을 늘리는 것이다.

CPU 자체를 기계 명령어를 실행하는 메가팩토리로 생각할 수 있다.<br>
하나의 기계 명령어를 처리할 때 명령어 인출, 명령어 해독, 실행, 다시 쓰기 네 단계를 실행해야 한다.<br>
각 단계는 별도의 하드웨어로 처리된다.<br>
현재 CPU는 기계 명령어를 초당 수십억 개 처리할 수 있는 능력을 갖추고 잇으며, 파이프라인 기술은 필수 불가결하다.

프로그래머가 작성한 if 문은 일반적으로 컴파일러가 조건부 점프 명령어로 변환하며, 이 명령어는 분기 역할을 한다.<br>
조건이 참이면 점프해야 하고, 그렇지 않으면 순차적으로 실행된다.

분기 점프 명령어가 실행을 완료하기 전에 다음 명령어는 이미 파이프라인에 들어가 있어야 한다. 그렇지 않으면 파이프라인에 빈 공간이 생겨 프로세서의 리소스를 완전하게 사용할 수 없기 때문이다.<br>
이때 문제가 발생한다. 분기 점프 명령어는 자신의 실행 겨로가에 따라 점프 여부를 결정해야 하는데, 이 명령어 실행이 완료되지 않은 시점에서 CPU는 어떤 분기의 명령어를 파이프라인에 넣어야 할지 알 수 없다.<br>
따라서 CPU는 미리 예측을 한다.

CPU는 뒤이어 어디로 분기할 가능성이 있는지 추측한다.<br>
추측이 맞았다면 파이프라인은 계속 앞으로 흘러가고, 추측이 틀렸다면 파이프라인에서 이미 실행 중이던 잘못된 분기 명령어 모두를 무효화한다.<br>
이처럼 CPU 추측이 틀리면 바로 성능 손실이 발생한다.<br>
최신 CPU의 이런 추측 과정을 **분기 예측**이라고 한다.

배열이 정렬되어 있으면 if 조건의 결과는 매우 규칙적이다. 반면에 배열이 정렬되어 있지 않으면 if 조건의 결과는 규칙성이 없다.<br>
정렬되지 않은 배열을 사용하면 분기 예측 실패율이 매우 높아지고 프로그램 성능이 떨어진다.<br>
이것이 프로그래밍 언어에 `ㅣikely/unlikely` 매크로가 있는 이유이다.<br>
해당 매크로를 이용하여 컴파일러에 가능성이 더 높은 분기를 알려줄 수 있고, 컴파일러는 더 목적성을 가지고 최적화를 할 수 있다.

<br>

## 4.5 CPU 코어 수와 스레드 수 사이의 관계는 무엇일까?

요리사는 레시피에 따라 특정 작업을 실행하여 특정한 요리를 만들고, CPU는 기계 명령어에 따라 프로세스와 스레드를 실행한다.<br>
운영 체제 입장에서 CPU가 사용자 상태에서 실행하는 명령어는 모두 스레드 또는 특정 스레드에 속해 있다. 따라서 명령어에 따라 프로세스를 실행한다.<br>
요리사 수는 CPU 코어 수에 비유할 수 있으며, 일정 시간 동안 볶을 수 있는 요리 수는 스레드 수에 비유할 수 있다.<br>
CPU 코어 수와 스레드 수 사이에는 어떤 필연 관계도 없다. CPU는 하드웨어인데 반해 스레드는 소프트웨어 개념, 더 정확하게는 실행 흐름이자 작업이다.<br>
따라서 단일 코어 시스템에서도 메모리가 충분하고, 운영 체제에 제한이 없다면 얼마든지 많은 스레드를 생성할 수 있다.

CPU는 근본적으로 자신이 실행하는 명령어가 어떤 스레드에 속하는지 이해하지 못하며, 이를 이해해야 하는 것은 운영 체제이다.<br>
CPU가 해야 하는 일은 PC 레지스터 주소에 따라 메모리에서 기계 명령어를 꺼내 실행하는 것뿐이다.

단일 코어 시스템에서는 CPU는 일정 시간 동안 단 하나의 스레드만 실행할 수 있어 스레드 여러 개가 번갈아 실행되기는 하지만, 진정한 병렬 처리라고는 할 수 없다.<br>
그렇다고 단일 코어에서 단일 코어에서 다중 스레드가 의미가 없는 것은 아니다.<br>
스레드라는 개념은 프로그래머에게 매우 편리한 추상화 방법을 제공하므로 작업 하나를 여러 개로 분할한 후 각각의 하위 작업을 별도의 스레드에 배치하면 운영 체제에서 이를 스케줄링하고 실행할 수 있으므로 동시에 여러 작업을 실행할 수 있다.<br>
예를 들어 사용자 인터페이스 요소 뒤에서 대량의 계산을 수행해야 한다고 할 때, 계산 작업을 별도의 스레드에 넣어 계산을 수행하는 동안 사용자 인터페이스가 멈추는 것을 방지할 수 있다.<br>
이외에도 처리해야 하는 작업이 블로킹 입출력과 관련되었을 때 해당 블로킹 호출을 별도의 스레드에서 실행하면 나머지 코드는 영향 없이 계속 실행될 수 있다.<br>
스레드가 특정 작업을 기다리지 않고 진행하는 것이 목적이라면, 필요에 따라 스레드 여러 개를 생성하고 작업을 분할하여 스레드에서 실행해도 된다.

다중 코어 리소스를 최대한 활용해야 할 때 프로그래머가 가장 선호하는 도구는 스레드이다.<br>
일반적으로 생성되는 스레드 수는 코어 수와 일정한 선형 관계를 유지해야 한다.<br>
스레드가 순수하게 계산을 위한 것이고 입출력이나 동기화 같은 작업이 없다면, 코어당 스레드 하나가 가장 나은 선택이다. 그러나 스레드에는 일정한 입출력과 동기화 등이 필요하므로 이때는 스레드 수를 적당히 늘려 운영 체제가 CPU에 할당할 수 있는 충분한 스레드를 확보하면 시스템 성능을 향상시킬 수 있다.<br>
하지만 스레드 수가 한계에 달하면 운영 체제 성능이 떨어지기 시작하는데, 이는 한 스레드에서 다른 스레드로 전환할 때 부담이 증가하기 때문이다.

<br>

## 4.6 CPU 잔화론(상): 복잡 명령어 집합의 탄생

CPU의 입장에서는 모든 프로그램은 컴파일러로 기계 명령어로 변환하기 때문에 프로그램에 따른 차이가 없다.<br>
이런 기계 명령어는 실행 파일에 저장되고, 프로그램이 실행되면 메모리에 적재되며, CPU는 메모리에서 명령을 읽어 실행한다.

CPU의 능력 범위는 명령어 집합으로 설명할 수 있다.<br>
명령어 집합에서 명령어를 찾아 CPU로 보내면 CPU는 해당 명령어가 지시하는 작업을 실행한다.<br>
이런 명령어 집합은 프로그래머가 프로그래밍을 하는데 사용한다.<br>
서로 다른 형태의 CPU는 다른 유형의 명령어 집합을 가지고 있으며, 명령어 집합의 유형은 프로그래머가 코드를 작성할 때 뿐만 아니라 CPU의 하드웨어 설계에도 영향을 미친다.<br>
오늘날 데스크톱 PC와 서버에 공통으로 사용되는 x86 구조는 복잡 명령어 집합에 기초를 두고 있으며, 인텔과 AMD가 x86 프로세서를 생산한다.

1970년대에는 컴파일러가 아직 성숙되지 못해 신뢰도가 낮았고, 많은 프로그램들이 어셈블리어로 작성되었기 때문에 일반적으로 명령어 집합이 풍부해야 하며 명령어 자체 기능도 강력해야 한다고 생각했다.<br>
이 시기에는 기계 명령어와 고급 언어 개념 간 차이를 줄여야 더 적은 코드로 많은 작업을 할 수 있었다.<br>
따라서 컴퓨터 과학자들은 고급 언어와 이에 직접 대응하는 기계 명령어가 있는, 의미상 간격을 이어 주는 것을 중요하게 생각했다.

![폰 노이만 구조](/esc/CH4/images/von_neumann_architecture.png)<br>
오늘날 컴퓨터는 기본적으로 폰 노이만 구조를 따르는데, 이 구조의 핵심 사상은 **'저장 개념에서 프로그램과 프로그램이 사용하는 데이터에 어떤 차이도 없어야 하며, 모두 컴퓨터의 저장 장치 안에 저장될 수 있어야 한다'**는 것이다.<br>
폰 노이만 구조에서 실행 파일은 기계 명령어와 데이터를 모두 포함하고 있다.<br>
또한 프로그래머가 작성한 코드는 디스크 저장 공간을 차지하며 실행 시에는 메모리에 적재되므로 메모리 공간을 차지하는데, 이 시기에는 메모리 크기가 수십 KB에 불과했다.<br>
이렇게 작은 메모리에 많은 프로그램을 적재하려면 기계 명령어를 매우 세밀하게 설계해서 프로그램이 차지하는 저장 공간을 줄여야 한다. 따라서 다음 요구 사항을 만족해야 한다.
- 하나의 기계 명령어로 더 많은 작업을 완료할 수 있도록 함
- 기계 명령어의 길이가 고정되어 있지 않아 프로그램 자체가 차지하는 저장 공간을 줄임
- 기계 명령어의 밀도를 높여 공간을 절약하기 위해 고도로 인코딩함

<br>

명령어를 사용한 편리한 프로그램 작성 및 코드의 저장 공간 절약을 위해 복잡 명령어를 설계했다.<br>
하지만 이 시기 CPU 명령어 집합은 모두 회로 직접 연결 방식이었다. 따라서 명령어를 실행하는 데에는 효율적이지만 유연성이 떨어져 명령어 집합의 변경에 대응하기 어려웠다.<br>
따라서 대부분의 명령어에 포함된 연산을 더 간단한 명령어로 구성된 작은 프로그램으로 정의하고 이를 CPU에 저장해 모든 기계 명령어에 대응할 수 있도록 만들었다.<br>
여기에서 사용되는 더 간단한 명령어가 마이크로코드이다.<br>
명령어를 추가할 때 주요 작업은 마이크로코드 수정에 집중되며 하드웨어 수정은 거의 필요하지 않으므로 CPU 설계 복잡도를 낮출 수 있다.

복잡 명령어 집합의 등장으로 어셈블리어로 프로그램을 쉽게 작성하면서 적은 저장 공간에 저장할 수 있게 되었다. 복잡 명령어 집합으로 발생하는 프로세서 설계의 복잡한 문제는 마이크로코드로 단순화할 수 있다.<br>
하지만 마이크로코드의 버그를 수정하는 것은 일반 프로그램의 버그를 수정하는 것보다 훨씬 더 어려울 뿐만 아니라, 마이크로코드 설계가 트랜지스터를 매우 많이 소모하는 문제가 발생했다.<br>
따라서 마이크로코드 자체가 해결해야 하는 대상으로 떠올랐고, 더 나은 설계를 찾게 되었다.

<br>

## 4.7 CPU 진화론(중): 축소 명령어 집합의 탄생

시간이 흐르고 기술이 발전하면서 최대 용량이 64KB인 메모리가 등장했고, 메모리 용량 대비 가격이 떨어졌다.<br>
또한 컴파일 기술이 발전을 이뤄 컴파일러 도입이 성행했고, 프로그래머도 점점 고급 언어로 프로그램을 작성하기 시작했다.

CPU는 약 80% 시간 동안 명령어 집합의 기계 명령어 중 20%를 실행한다.
복잡 명령어 집합에서 비교적 복잡한 명령어 중 일부는 자주 사용되지 않으며, 컴파일러를 설계하는 프로그래머는 고급 언어를 더 간단한 기계 명령어의 조합으로 변환하는 경향이 있다.
또한 컴파일러가 생성된 기계 명령어를 이용하여 CPU 내부에서 실행되는 마이크로코드에 영향을 미칠 방법이 없다. 따라서 마이크로코드에 버그가 있으면 컴파일러는 이를 피하기 위해 할 수 있는 일이 아무것도 없다. 컴파일러는 마이크로코드에서 출력된 간단한 명령어를 기계 명령어로 변환하기 때문이다.

복잡 명령어 집합에 대한 반성을 바탕으로 축소 명령어 집합 철학이 탄생했다.
1. 명령어 자체의 복잡성: 복잡한 명령어를 제거하고 간단한 명령어 여러 개로 대체해 마이크로코드를 배제함
2. 컴파일러: 컴파일러에서 생성된 기계 명령어의 CPU 제어 능력이 향상됨
3. LOAD/STORE 구조: 축소 명령어 집합의 명령어는 레지스터 내 데이터만 처리할 수 있으며, 메모리 내 데이터는 처리 X → LOAD/STORE 명령어가 메모리의 읽고 쓰기 처리

<br>

![축소 명령어 집합 모델](/esc/CH4/images/RISC.png)<br>
위의 그림은 단순화된 계산 모델이다. 오른쪽은 기계 명령어와 데이터를 저장하는 메모리이고, 왼쪽은 CPU이며, CPU 내부에 있는 것은 레지스터와 연산 장치인 ALU이다.<br>
두 숫자가 각각 메모리 주소 A와 B에 저장되고, 두 숫자를 곱한 값을 계산해 결과를 메모리 주소 A에 기록한다고 가정해보자.

복잡 명령어 집합은 가능한 적은 수의 명령어로 가능한 많은 작업을 수행한다.<br>
따라서 MULT라는 하나의 명령어를 이용해 메모리 주소 A와 B의 데이터를 읽어 레지스터에 저장하고, ALU가 레지스터 값을 이용해 곱셈 연한을 수행한 뒤 결과를 다시 메모리에 작성할 수 있다.<br>
복잡 명령어는 고급 언어와 기계 명령어 사이의 차이를 줄여 최소한의 코드로 작업을 완료하고, 프로그램 자체가 차지하는 저장 공간을 절약하려는 목적을 가지고 있다.<br>
복잡한 명령어의 의미는 명령어 자체가 복잡하다는 것이 아니라, 그 뒤에서 일어나는 작업이 복잡하다는 의미이다.

반대로 축소 명령어 집합은 일련의 간단한 명령어 여러 개를 사용해 작업을 완료하는 것을 선호한다.<br>
따라서 LOAD A → LOAD B → LROD A, B → STORE A 와 같이 어셈블리어 코드를 작성해 작업을 처리할 수 있다.<br>
이와 같이 동일한 작업에 대해 축소 명령어 집합을 사용하는 프로그램은 복잡 명령어 집합보다 더 많은 저장 공간이 필요하다.<br>
하지만 축소 명령어 집합 설계의 원래 의도는 프로그래머가 직접 어셈블리어로 코드를 작성하는 것이 아니라, 이 작업을 컴파일러에게 맡기고 컴파일러가 구체적인 기계 명령어를 자동으로 생성하게 하는 것이다.<br>
축소 명령어의 명령어 집합은 매우 간단하므로 CPU 내에서 코드를 해석하는 데 복잡한 하드웨어 구조가 필요하지 않아 트랜지스터를 절약할 수 있고, 절약한 트랜지스터는 CPU의 다른 기능에 활용할 수 있다.<br>
또한 각 명령어가 매우 간단해 실행 시간이 거의 동일한데, 이 경우 파이프라인 기술을 도입해 명령어의 실행 효율을 높일 수 있다. 파이프라인 기술은 명령어 하나가 실행되는 시간을 단축해 주지는 않지만 처리량을 늘릴 수 있다.<br>
1세대 축소 명령어 집합 프로세서는 명령어 하나가 1~2클럭 주기로 실행된다. 반면에 동시대의 복잡 명령어 집합 프로세서는 명령어 하나를 실행하는 데 5~10 클럭 주기가 필요하다.

정리해보자면 축소 명령어 집합의 간소화된 설계는 마이크로코드가 없기 때문에 더 적은 트랜지스터가 더 적은 트랜지스터가 필요하며, 더 작은 CPU를 만들 수 있다. 또한 더 높은 클럭 주파수를 가지게 되어 축소 명령어 집합 구조의 CPU는 동일한 작업을 할 때 복잡 명령어 집합 구조보다 훨씬 우수하다.

<br>

## 4.8 CPU 진화론(하): 절체절명의 위기에서 반격

함수 인터페이스가 변경되지 않는 한 내부 구현이 변경되어도 함수를 사용하는 코드는 변경될 필요가 없다.<br>
인터페이스에 해당하는 명령어 집합은 변경할 수 없지만 CPU 내부 구현인 명령어 실행 방식은 변경이 가능하다.

파이프라인을 활용하기 위해 복잡 명령어 집합의 명령어를 CPU 내부에서 축소 명령어 집합과 유사한 명령어인 **마이크로 명령어**로 변환했다.<br>
프로그래머는 어셈블리어로 프로그램을 작성하고 컴파일러가 실행 파일을 생성할 때도 여전히 복잡 명령어 집합을 사용하지만, CPU 내부에서 명령어를 실행할 때는 축소 명령어 집합과 유사하게 동작한다.<br>
이 방식은 복잡 명령어 집합의 호환성을 유지하면서 동시에 축소 명령어 집합의 장점을 얻을 수 있다.

또한 하드웨어 스레딩 기술인 **하이퍼스레딩** 기술을 추가로 개발했다.<br>
기존에는 시스템에 N개의 CPU 코어가 있다면 운영 체제는 N개의 준비 완료 상태인 스레드를 N개의 CPU 코어에 할당해서 동시에 실행할 수 있었다.<br>
하지만 하이퍼스레딩 기능을 탑재한 CPU는 운영체제에 환각을 심는다. 실제로는 컴퓨터 시스템에 하나의 물리 CPU 코어가 있지만 운영체제는 논리적으로 CPU 코어가 여러 개 있는 것으로 인식한다.<br>
이를 통해 하이퍼스레딩 기술이 탑재된 CPU는 한 번에 스레드 두 개에 속하는 명령어 흐름을 처리할 수 있다.

명령어 간 종속성으로 파이프라인이 항상 완벽하게 채워진 상태에서 실행될 수는 없으며 결국에는 빈 공간이 생긴다.<br>
이때 추가 명령어 흐름을 도입하여 빈 공간을 채우면 전체 파이프라인을 채워서 실행할 수 있어 CPU의 리소스를 최대한 활용할 수 있다.<br>
프로그래머가 인지할 수 있는 스레드는 생성, 스케줄링, 관리의 주체가 운영 체제이다.<br>
반면에 하드웨어 스레드에 해당하는 하이퍼스레딩은 CPU 하드웨어의 기능으로 운영 체제와는 상관이 없다.

하이퍼스레딩 기술은 축소 명령어 집합에서도 도입이 가능하다.<br>
이렇게 복잡 명령어 집합과 축소 명령어 집합은 끊임없이 서로의 장점은 취하고 약점은 보완하고 있다.<br>
하지만 축소 명령어 집합에서 컴파일러는 여전히 중요한 역할을 하고 있으며, 축소 명령어 집합은 명령어 길이가 일정하기 때문에 명령어 길이가 가변적인 복잡 명령어 집합에 비해 컴파일러 최적화에서 여전히 더 많은 장점이 있다.<br>
메모리에 접근할 때 축소 명령어 집합은 여전히 LOAD/STORE를 사용하지만 복잡 명령어 집합에는 이런 설계가 없다.

복잡 명령어 집합에는 x86 소프트웨어 생태계라는 매우 훌륭한 기반이 존재했다.<br>
축소 명령어 집합이 기술적으로 앞서 있을 때도 많은 훌륭한 소프트웨어가 x86 플랫폼에서 동작하고 있었다.<br>
ARM으로 대표되는 축소 명령어 집합은 임베디드와 저전력 영역으로 후퇴하는 듯 했으나 스마트폰과 맥북의 등장과 함께 다시 살아났다.<br>
오늘날 복잡 명령어 집합 기반의 x86은 여전히 데스크톱과 서버 영역을 점유하고 있고, 축소 명령어 집합 기반의 ARM은 모바일 시장의 대부분을 차지하고 있다.

<br>

## 4.9 CPU, 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 통달하기

함수 호출로 코드 재사용성을 개선할 수 있고, 시스템 호출로 운영체제에 요청을 보낼 수 있다. 또한 프로세스와 스레드 전환으로 다중 작업이 가능할 뿐만 아니라 인터럽트 처리로 운영 체제가 외부 장치를 관리하게 할 수 있다.

CPU에 레지스터가 필요한 이유는 속도 때문이다. CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도의 대략 100분의 1 정도이다.<br>
프로세스가 생성되면 코드와 코드에서 사용하는 데이터는 메모리에 적재되며, 기계 명령어를 실행할 때 메모리 데이터를 CPU가 사용할 레지스터로 옮겨야 한다.<br>
레지스터와 메모리는 본질적으로 차이가 없으며, 둘 다 정보를 저장하는 데 사용된다. 단지 레지스터의 읽기/쓰기 속도가 훨씬 빠르고 제조 비용이 비싸 용량의 한계가 있을 뿐이다.<br>
따라서 프로세스의 실행 시 정보를 모두 메모리에 저장하고 CPU가 사용할 때만 임시로 레지스터에 데이터를 보관한다.

실행되는 모든 함수는 스택 프레임을 가진다.<br>
스택의 가장 중요한 정보는 stack top으로, stack top 정보는 stack bottom을 가리키는 stack pointer에 저장된다. stack pointer로 함추 호출 스택의 추적이 가능하다.<br>
함수가 실행될 때, 함수에 정의된 로컬 변수와 전달된 매개변수 등을 저장하는 독립적인 메모리 공간을 stack frame이라고 한다. 스택 프레임이 모여 스택 영역을 구성한다.

함수가 지금 어떤 명령어를 실행하고 있는지에 대한 정보는 명령어 주소 레지스터가 가지고 있다.<br>
명령어 주소 레지스터는 program counter(PC)라고 부르거나 명령어 포인터(instruction pointer, IP)라고 불린다.<br>
프로그램이 실행되면 첫 번째로 실행할 기계 명령어의 주소가 PC 레지스터에 저장되며, CPU는 이 PC 레지스터에 저장되어 있는 주소에 따라 메모리에서 명령어를 가져와서 실행한다.

CPU 내부에는 스택 레지스터와 명령어 주소 레지스터 외에도 상태 레지스터가 있다.<br>
x86 구조에서는 이를 FLAGS 레지스터라고 하며, ARM 구조에서는 응용 프로그램 상태 레지스터라고 한다.<br>
상태 레지스터에는 산술 연산 중 올림수나 overflow가 발생한 정보, 사용자 상태에서 동작하는지 커널 상태에서 동작하는지에 대한 정보 등이 저장된다.

레지스터를 통해 프로그램이 실행된 직후부터 현시점까지 세세한 단면을 알 수 있으며, 현시점에 레지스터에 저장된 모든 정보를 일반적으로 **상황 정보**라고 한다.<br>
프로그램의 실행 시 상황 정보를 가져오고 저장할 수 있다면 언제든지 프로그램의 실행을 중지할 수 있으며, 반대로 이 정보를 이용해 언제든지 프로그램의 실행을 재개할 수도 있다.<br>
CPU는 엄격한 오름차순으로 기계 명령어를 실행하지 않는다. 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리가 발생할 때는 명령어가 오름차순으로 실행되지 않기 때문에 상황 정보의 저장과 복원을 통해 이전 흐름을 이어나갈 수 있다.

함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리는 모두 중첩 구조이기 때문에 스택을 이용하여 처리할 수 있다.<br>
또한 스택은 일종의 구조이므로 소프트웨어로 스택을 구현할 수도 있고, 하드웨어로 구현할 수도 있다.

![함수 호출](/esc/CH4/images/function_call.png)<br>
함수를 호출할 때 CPU는 호출된 함수의 첫 번째 기계 명령어로 점프한 이후 함수 실행이 완료되면 다시 원래 위치로 점프해야 한다.<br>
여기에는 함수의 상태의 보존과 복원을 포함하는데, 보존해야 하는 상태 정보에는 반환 주소 뿐만 아니라 사용한 레지스터 정보 등이 포함되는데 이런 함수 실행 시 상태 정보는 스택 프레임에 저장된다.<br>
함수 A가 함수 B를 호출할 때 실행 시 정보는 함수 A의 스택 프레임에 저장되며, 함수 B의 실행이 완료되면 스택 프레임 정보를 기반으로 함수 A의 실행이 재개된다.<br>
함수를 호출할 때마다 스택에 후입선출(LIFO) 순서로 스택 프레임이 생성된다.

![사용자 상태 스택과 커널 상태 스택](/esc/CH4/images/system_call_state_stack.png)<br>
open 같은 함수를 호출하면 운영 체제가 파일을 여는 작업을 진행한다. 응용 프로그램은 system call을 통해 운영 체제에 서비스를 요청한다.<br>
서비스 요청을 완료하는 것은 운영 체제이기 때문에 운영 체제 역시 내부적으로 이 요청을 처리하는 함수를 호출하는데, 이때 커널 상태 스택을 실행 시간 스택으로 사용한다.<br>
모든 사용자 상태 스레드는 커널 상태에 대응하는 커널 상태 스택을 가지고 있다.<br>
사용자 스레드가 운영 체제의 서비스를 요청해야 하는 경우 시스템 호출을 사용해 사용자 상태에서 커널 상태로 전환된다.<br>
커널 상태에서 사용자 상태 스레드에 대응하는 커널 상태 스택을 찾은 후 여기에서 대응하는 커널 코드를 실행하여 시스템 호출 요청을 처리한다.<br>
이때 사용자 상태 스레드의 레지스터 정보와 같은 실행 상황 정보는 커널 상태 스택에 저장된다.<br>
CPU는 커널에서 관련 코드를 실행하기 시작하며, 이후 커널 상태 스택은 함수의 호출과 반환에 따라 크기가 증감한다.<br>
시스템 호출이 완료되면 커널 상태 스택에 저장된 사용자 상태 프로그램의 상황 정보에 따라 CPU 상태가 복원되며, 커널 상태에서 사용자 상태로 전환된다.

![인터럽트 발생 시 프로그램 상태](/esc/CH4/images/intterupt_state_stack.png)<br>
컴퓨터가 프로그램을 실행하는 도중에도 다른 작업을 처리할 수 있는 것은 모두 인터럽트 작동 방식을 이용해 처리하기 때문이다.<br>
인터럽트는 본질적으로 현재 CPU의 실행 흐름을 끊고 특정 인터럽트 처리 함수로 점프하며, 인터럽트 처리 함수의 실행이 완료되면 원래 위치로 다시 점프한다.<br>
인터럽트 처리 함수의 실행 시간 스택은 커널 상태 스택을 사용하거나, 인터럼트 처리 함수 스택(ISR)을 가진다.<br>
인터럽트 처리 함수와 시스템 호출은 유사하지만, 시스템 콜은 사용자 상태 프로그램이 직접 실행하는 데 반해 인터럽트 처리는 외부 장치로 실행된다는 차이점이 있다.<br>
인터럽트가 발생하면 CPU는 사용자 상태에서 커널 상태로 전환되며, 사용자 상태 스레드에서 대응하는 커널 상태 스택을 찾아 커널 상태 스택에 사용자 상태 스레드의 실행 상황 정보를 저장한다. 이후 CPU는 인터럽트 처리 함수의 시작 주소로 점프해 인터럽트 처리 함수가 실행되고, 함수가 실행되는 동안 커널 상태 스택은 함수의 호출과 반환에 따라 크기가 증감한다.<br>
인터럽트 처리 함수의 실행이 완료되면 컨러 상태 스택에 저장된 상황 정보에 따라 CPU 상태가 복원되며, 커널 상태에서 다시 사용자 상태로 전환되어 사용자 상태 스레드가 계속 실행된다.

![스레드 전환](/esc/CH4/images/thread_context_switching.png)<br>
시스템 내부의 타이머가 인터럽트 신호를 발생시키면 CPU는 인터럽트 신호를 수신한 후 현재 스레드(A)의 실행을 일시 중지한다.<br>
이어서 사용자 상태에서 커널 상태로 전환하며 커널 안의 타이머 인터럽트 처리 프로그램을 실행한다.<br>
타이머 인터럽트 처리 프로그램은 스레드 A에 할당된 CPU 시간 조각이 전부 사용되었는지 판단해 시간이 남아 있다면 사용자 상태로 돌아가서 실행을 계속하고, 모두 사용되면 CPU를 다른 스레드에 할당하도록 스레드 전환 작업을 시작한다.<br>
스레드 전환 작업에서는 주소 공간을 전환하고, 스레드 A의 서술자에 상황 정보 저장 후 스레드 B의 서술자에 저장된 상황 정보를 CPU로 복원한다.<br>
스레드 B는 자신이 일시 중지되었다는 사실은 전혀 모른 채로 이어서 사용자 모드로 다시 전환해야 한다는 것만 기억하고 있다.<br>
이후 스레드 B는 커널 상태 스택에 저장된 상황 정보를 이용하여 사용자 상태로 다시 점프해 계속 실행된다.