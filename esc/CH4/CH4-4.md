# 4.4 CPU가 if 문을 만났을 때

C언어로 크기가 10,000인 정수 배열을 만들고 배열에서 128보다 큰 모든 요소의 합을 계산하는 작업을 100,000번 반복하는 코드를 실행해보자.<br>
배열 요소가 이미 정렬된 상태라면 2.8초 만에 실행이 완료되지만, 배열 요소가 임의로 배치되어 있다면 실행 시간이 7.5초에 달한다.<br>
리눅스의 `perf` 도구를 사용하여 프로그램이 실행 중일 때 CPU와 관련된 정보들을 확인해보자.<br>
분기 예측 실패율을 나타내는 branch-misses 항목에서 정렬된 배열을 이용한 프로그램에서는 예측 실패율이 0.02%에 불과하지만, 정렬되지 않은 배열을 이용한 프로그램에서는 최고 14.12%에 달한다.<br>

## 4.4.1 파이프라인 기술의 탄생

파이프라인 기술이란 각 공정 단계를 수십 개로 나누고 각 단계마다 전문가를 배치하는 것이다.<br>
파이프라인 기술은 전체 처리 시간을 줄이는 것이 아니라 CPU의 처리 능력을 늘리는 것이다.<br>

## 4.4.2 CPU: 메가팩토리와 파이프라인

CPU 자체를 기계 명령어를 실행하는 메가팩토리로 생각할 수 있다.<br>
하나의 기계 명령어를 처리할 때 명령어 인출, 명령어 해독, 실행, 다시 쓰기 네 단계를 실행해야 한다.<br>
각 단계는 별도의 하드웨어로 처리된다.<br>
현재 CPU는 기계 명ㄹ여어를 초당 수십억 개 처리할 수 있는 능력을 갖추고 잇으며, 파이프라인 기술은 필수 불가결하다.<br>

## 4.4.3 if가 파이프라인을 만나면?

프로그래머가 작성한 if 문은 일반적으로 컴파일러가 조건부 점프 명령어로 변환하며, 이 명령어는 분기 역할을 한다.<br>
조건이 참이면 점프해야 하고, 그렇지 않으면 순차적으로 실행된다.<br><br>

분기 점프 명령어가 실행을 완료하기 전에 다음 명령어는 이미 파이프라인에 들어가 있어야 한다. 그렇지 않으면 파이프라인에 빈 공간이 생겨 프로세서의 리소스를 완전하게 사용할 수 없기 때문이다.<br>
이때 문제가 발생한다. 분기 점프 명령어는 자신의 실행 겨로가에 따라 점프 여부를 결정해야 하는데, 이 명령어 실행이 완료되지 않은 시점에서 CPU는 어떤 분기의 명령어를 파이프라인에 넣어야 할지 알 수 없다.<br>
따라서 CPU는 미리 예측을 한다.<br>

## 4.4.4 분기 예측: 가능한 한 CPU가 올바르게 추측하도록

CPU는 뒤이어 어디로 분기할 가능성이 있는지 추측한다.<br>
추측이 맞았다면 파이프라인은 계속 앞으로 흘러가고, 추측이 틀렸다면 파이프라인에서 이미 실행 중이던 잘못된 분기 명령어 모두를 무효화한다.<br>
이처럼 CPU 추측이 틀리면 바로 성능 손실이 발생한다.<br>
최신 CPU의 이런 추측 과정을 **분기 예측**이라고 한다.<br><br>

배열이 정렬되어 있으면 if 조건의 결과는 매우 규칙적이다. 반면에 배열이 정렬되어 있지 않으면 if 조건의 결과는 규칙성이 없다.<br>
정렬되지 않은 배열을 사용하면 분기 예측 실패율이 매우 높아지고 프로그램 성능이 떨어진다.<br>
이것이 프로그래밍 언어에 `ㅣikely/unlikely` 매크로가 있는 이유이다.<br>
해당 매크로를 이용하여 컴파일러에 가능성이 더 높은 분기를 알려줄 수 있고, 컴파일러는 더 목적성을 가지고 최적화를 할 수 있다.<br>