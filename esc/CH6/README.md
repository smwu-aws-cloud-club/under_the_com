# 6. 입출력이 없는 컴퓨터가 있을까?

## 6.1 CPU는 어떻게 입출력 작업을 처리할까?

CPU 내부에 레지스터가 있는 것과 마찬가지로, 장치에도 장치에 관련된 일부 정보를 저장하는 장치 레지스터가 있다.
1. 데이터를 저장하는 레지스터: 사용자가 키보드의 키를 누르면 정보가 저장되는 레지스터
2. 제어 정보와 상태 정보를 저장하는 레지스터: 읽고 쓰는 작업을 이용해 장치를 제어하거나 장치 상태 확인 가능

<br>

프로그래머 관점에서 장치는 저수준 계층의 레지스터를 한데 묶은 것이고, 장치에서 생성된 데이터를 얻거나 장치를 제어하는 작업은 모두 이런 레지스터를 읽고 쓰는 것을 한다.<br>
장치 레지스터를 읽고 쓰는 과정은 기계 명령어 중 입출력 명령어(IN, OUT)를 통해 실행한다.<br>
어떤 장치 레지스터를 읽고 써야 하는지는 장치마다 부여된 고유 주소를 입출력 명령어에 저장해 지정한다.<br>
CPU의 입장에서는 메모리 역시 하나의 외부 장치로 간주할 수 잇으므로 장치 레지스터를 읽고 쓰는 데 LOAD와 STORE를 사용할 수 있다.

LOAD와 STORE 명령어만으로는 읽고 쓰는 대상이 메모리인지, 장치 레지스터인지 알 수 없다.<br>
LOAD, STORE 명령어가 전달하는 메모리 주소 공간이 메모리에 할당되어 있는지, 장치에 할당되어 있는지를 통해 대상을 구분한다.<br>
이렇게 주소 공간의 일부분을 장치에 할당하여 메모리를 읽고 쓰는 것처럼 장치를 제어하는 방법이 __메모리 사상 입출력(memory mapping input and output)__ 이다.

메모리 사상 입출력 방식을 채용하고 키보드가 레지스터 주소 공간의 0xfe00에 사상되어 있다고 가정하면, CPU가 키보드를 읽는 기계 명령어는 `Load R1 0xFE00`일 것이다.<br>
하지만 키보드는 어떻게 데이터를 언제 읽어야 할지 알 수 있을까? 대다수의 장치는 사람이 조작하는 것이기 때문에 언제 동작할지 알 수 없다.<br>
CPU는 장치 상태 레지스터의 값을 읽음으로써 장치를 읽을 수 있는지 쓸 수 있는지 알 수 있다.

장치 상태 레지스터를 지속적으로 읽는 작업으로 키보드를 누르면 바로 해당 키보드의 문자를 읽을 수 있으며, 누르지 않을 때는 계속 검사를 반복한다는 **폴링**을 생각할 수 있다.<br>
문제는 사용자가 키를 누르지 않으면 CPU는 항상 불피룡하게 순환하며 대기하게 된다.<br>
본질적으로 폴링은 일종의 동기식 설계 방식이므로, 이를 개선하기 위한 방법은 동기를 비동기로 바꾸는 것이다.<br>
따라서 CPU가 명령어를 실행하고 있을 때 새로운 이벤트가 발생해 외부 장치가 인터럽트 신호를 보내면 CPU는 실행 중인 현재 작업의 우선순위가 인터럽트 요청보다 높은지 판단한다. 인터럽트가 우선순위가 더 높다면 현재 작업 실행을 일시 중지하고 인터럽트를 처리하며, 인터럽트 처리를 끝낸 후에 다시 현재 작업으로 돌아온다.

하지만 인터럽트를 사용하는 방법에서도 프로그램의 실행 상태를 저장하고 복원하는 과정에서 약간의 시간을 낭비하게 된다.<br>
입출력을 비동기로 처리하는 이 방법이 바로 **인터럽트 구동식 입출력**이다. 이를 통해 동기 기반의 폴링에서 비동기 인터럽트 처리로 바뀌었다.<br>
인터럽트를 처리할 때는 먼저 중단된 작업 상태를 보존해야 한다. 이어서 CPU는 인터럽트 처리 함수의 시작 위치로 점프하여  인터럽트 처리 함수의 명령어를 실행한 후 처리가 끝나면 다시 원래 자리로 점프하여 중단되었던 작업을 계속 실행한다.

인터럽트 처리는 일반 함수의 호출과 매우 유사하지만, 함수 호출은 단일 스레드 내부에서 발생하는 반면 인터럽트 처리 함수는 서로 다른 두 실행 흐름을 포함하므로 함수 호출에 비해 인터럽트 점프는 저장해야 할 정보가 훨씬 많다.<br>
상태 저장의 경우 프로그램 실행 상태를 저장하는 전용 스택을 커널에 만들어서 사용한다.

<br>

## 6.2 디스크가 입출력을 처리할 때 CPU가 하는 일은 무엇일까?

최신 컴퓨터 시스템의 경우 디스크가 입출력 요청을 처리하는 동안 CPU는 다른 작업을 수행하도록 스케줄링한다.<br>
디스크의 입출력 처리와 CPU가 실행하는 작업은 서로 의존하지 않는 독립적인 작업이므로 병행 처리가 가능하다.

디스크는 입출력 요청이 들어왔을 때 읽어야 하는 데이터가 헤드에 위치한 트랙에 없을 가능성이 있다.<br>
이때 헤드가 특정 트랙으로 이동하는 과정을 탐색이라고 하고, 탐색이 디스크 입출력 중에서 매우 시간을 많이 소모하는 작업에 해당한다.<br>
전자 부분은 전자 부품으로 구성되어 있으며, 이를 장치 제어기라고 한다. <br>
장치 제어기는 마이크로 컴퓨터 시스템으로 발전하여 자체적인 프로세스와 펌웨어를 갖추고 있으므로 CPU가 도와주지 않는 상황에서도 복잡한 작업을 할 수 있으며, 자신만의 버퍼나 레지스터를 갖추고 잇어 장치에서 읽은 데이터나 장치에 저장할 데이터를 저장할 수 있다.<br>
장치 제어기는 운영 체제에서 해당하는 장치 드라이버와 외부 장치를 연결하는 다리에 해당하며, 장치 제어기가 점점 더 복잡해지는 목적 중 하나가 CPU를 해방시키기 위해서이다.

CPU 개입이 없는 상황에서 직접 장치와 메모리 사이에 데이터를 전송하는 작동 방식을 **직접 메모리 접근**이라고 부른다.<br>
CPU는 어떻게 데이터를 복사할지 알려주는 명령어를 DMA에 전달한다.<br>
DMA는 자신의 작업 목표를 명확히 하고 버스 중재(= 버스의 사용 권한 요청) 후 이어서 장치를 작동시킨다.<br>
디스크에서 데이터를 읽는다고 가정했을 때, 장치 제어기의 버퍼에서 데이터를 읽으면 DMA가 지정된 메모리 주소에 데이터를 쓰는 방식으로 데이터 복사가 완료된다.

DMA가 CPU를 해방시키면서 가상 메모리와 캐시를 지원하는 시스템에서 문제가 발생했다.<br>
가상 메모리를 지원하는 시스템에는 가상 주소와 물리 메모리 주소가 있는데, DMA는 읽은 데이터를 어느 쪽 주소에 저장해야 하는지 알 수 없다.<br>
이를 해결하기 위해 운영 체제가 DMA에 필요한 가상 주소와 물리 메모리 주소 사이의 mapping 정보를 전달한다.<br>
이외에도 캐시가 존재하는 시스템에서는 메모리의 데이터가 캐시와 동일하지 않을 수 있다. DMA가 메모리에서 정보를 읽어 왔는데, 캐시에 최신값이 아직 동기화되지 않은 상태라면 문제가 발생한다.<br>
이 문제를 해결하기 위해 상응하는 캐시의 데이터를 즉시 메모리에 갱신하여 일관성 문제가 나타나지 않도록 할 수 있다.<br>
CPU는 DMA가 발생시키는 인터럽트를 통해 데이터 전송이 완로된 것을 알 수 있다.

1. CPU로 실행되는 스레드 1이 시스템 호출로 입출력 요청을 시작하면, 운영체제는 스레드 1의 실행을 일시 중지하고 CPU를 스레드 2에 할당하고 스레드 2가 실행된다.
2. 디스크가 동작하여 데이터 준비가 완료되면 DMA 작동 방식이 직접 장치와 메모리 사이에서 데이터를 전송한다.
3. 데이터 전송이 완료되면 인터럽트를 이용해 CPU에게 알리고, CPU는 스레드 2의 실행을 일시 중지하고 인터럽트를 처리한다.

<br>

소프트웨어든 하드웨어든 간에 높은 효율성을 이끌어 내는 비결은 비동기이다.<br>
다른 말로는 무의존성 또는 분리라고 불리며, 상대적으로 독립적일 때만 시스템의 리소스를 더 효율적으로 사용할 수 있다.