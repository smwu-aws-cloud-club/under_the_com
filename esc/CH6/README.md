# 6. 입출력이 없는 컴퓨터가 있을까?

## 6.1 CPU는 어떻게 입출력 작업을 처리할까?

CPU 내부에 레지스터가 있는 것과 마찬가지로, 장치에도 장치에 관련된 일부 정보를 저장하는 장치 레지스터가 있다.
1. 데이터를 저장하는 레지스터: 사용자가 키보드의 키를 누르면 정보가 저장되는 레지스터
2. 제어 정보와 상태 정보를 저장하는 레지스터: 읽고 쓰는 작업을 이용해 장치를 제어하거나 장치 상태 확인 가능

<br>

프로그래머 관점에서 장치는 저수준 계층의 레지스터를 한데 묶은 것이고, 장치에서 생성된 데이터를 얻거나 장치를 제어하는 작업은 모두 이런 레지스터를 읽고 쓰는 것을 한다.<br>
장치 레지스터를 읽고 쓰는 과정은 기계 명령어 중 입출력 명령어(IN, OUT)를 통해 실행한다.<br>
어떤 장치 레지스터를 읽고 써야 하는지는 장치마다 부여된 고유 주소를 입출력 명령어에 저장해 지정한다.<br>
CPU의 입장에서는 메모리 역시 하나의 외부 장치로 간주할 수 잇으므로 장치 레지스터를 읽고 쓰는 데 LOAD와 STORE를 사용할 수 있다.

LOAD와 STORE 명령어만으로는 읽고 쓰는 대상이 메모리인지, 장치 레지스터인지 알 수 없다.<br>
LOAD, STORE 명령어가 전달하는 메모리 주소 공간이 메모리에 할당되어 있는지, 장치에 할당되어 있는지를 통해 대상을 구분한다.<br>
이렇게 주소 공간의 일부분을 장치에 할당하여 메모리를 읽고 쓰는 것처럼 장치를 제어하는 방법이 __메모리 사상 입출력(memory mapping input and output)__ 이다.

메모리 사상 입출력 방식을 채용하고 키보드가 레지스터 주소 공간의 0xfe00에 사상되어 있다고 가정하면, CPU가 키보드를 읽는 기계 명령어는 `Load R1 0xFE00`일 것이다.<br>
하지만 키보드는 어떻게 데이터를 언제 읽어야 할지 알 수 있을까? 대다수의 장치는 사람이 조작하는 것이기 때문에 언제 동작할지 알 수 없다.<br>
CPU는 장치 상태 레지스터의 값을 읽음으로써 장치를 읽을 수 있는지 쓸 수 있는지 알 수 있다.

장치 상태 레지스터를 지속적으로 읽는 작업으로 키보드를 누르면 바로 해당 키보드의 문자를 읽을 수 있으며, 누르지 않을 때는 계속 검사를 반복한다는 **폴링**을 생각할 수 있다.<br>
문제는 사용자가 키를 누르지 않으면 CPU는 항상 불피룡하게 순환하며 대기하게 된다.<br>
본질적으로 폴링은 일종의 동기식 설계 방식이므로, 이를 개선하기 위한 방법은 동기를 비동기로 바꾸는 것이다.<br>
따라서 CPU가 명령어를 실행하고 있을 때 새로운 이벤트가 발생해 외부 장치가 인터럽트 신호를 보내면 CPU는 실행 중인 현재 작업의 우선순위가 인터럽트 요청보다 높은지 판단한다. 인터럽트가 우선순위가 더 높다면 현재 작업 실행을 일시 중지하고 인터럽트를 처리하며, 인터럽트 처리를 끝낸 후에 다시 현재 작업으로 돌아온다.

하지만 인터럽트를 사용하는 방법에서도 프로그램의 실행 상태를 저장하고 복원하는 과정에서 약간의 시간을 낭비하게 된다.
입출력을 비동기로 처리하는 이 방법이 바로 **인터럽트 구동식 입출력**이다. 이를 통해 동기 기반의 폴링에서 비동기 인터럽트 처리로 바뀌었다.

