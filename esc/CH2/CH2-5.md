# 2.5 콜백 함수를 철저하게 이해한다

## 2.5.1 모든 것은 다음 요구에서 시작된다

핵심 모듈 함수만을 사용하면 조건에 따라 수백 개의 ```else if``문을 작성하고, 요청 사항이 추가될 때마다 핵심 모듈 함수를 수정해야 한다.<br>

## 2.5.2 콜백이 필요한 이유

핵심 모듈 함수를 수정하는 대신, 자신이 정의한 함수를 전달하는 함수 변수로 문제를 해결할 수 있다.<br>
이 함수 변수를 **콜백 함수**라고 부른다.<br>
일반적으로 콜백 함수는 직접 구현하지만, 다른 모듈이나 스레드에서 함수를 호출한다.<br>

## 2.5.3 비동기 콜백

함수 호출 횟수가 증가할수록 핵심 모듈 함수의 실행 시간이 길어지고, 함수가 반환되는 데 시간이 오래 걸리게 된다.<br>
우선 순위가 높은 함수를 먼저 실행하기 위해 함수 내부에서 스레드를 생성하고 해당 스레드로 함수를 실행할 수 있다.<br>
각자의 스레드에서 병렬로 실행되기 때문에 이전 함수의 실행이 완료되기 전에 다음 함수의 실행이 끝날 수 있는데, 이를 **비동기**라고 한다.<br>
이와 같이 호출 스레드가 콜백 함수 실행에 의존하지 않는 것을 **비동기 콜백**이라고 한다.<br>

## 2.5.4 비동기 콜백은 새로운 프로그래밍 사고방식으로 이어진다

함수를 호출할 때 프로그래머에게 가장 익숙한 사고방식은 다음과 같다.
1. 함수를 호출하고 결과를 획득한다.
2. 획득한 결과를 처리한다.<br>
```
res = request();
handle(res);
```
이것이 바로 함수의 **동기 호출**이며, 이전 함수가 반환되는 것을 무조건 기다려야 한다.<br><br>

함수는 호출자가 정보를 채워 넣기 전까지는 매개변수 정보가 무엇인지 알 수 없다.<br>
프로그래머가 함수를 호출할 때 데이터 형태의 일반적인 변수 외에 코드로 된 함수 형태의 변수도 전달할 수 있다.<br>
따라서 함수를 직접 호출하는 대신 ```request(handle);```과 같이 해당 함수를 다른 함수의 매개변수로 전달할 수 있다.<br>
함수 호출이 비동기 콜백이라면 함수는 즉시 반환될 수 있으며, 결과를 받아 처리하는 프로세스는 다른 스레드와 프로세스, 다른 시스템에서 완료될 수 있다.<br><br>

![동기 호출 vs 비동기 호출](https://wikidocs.net/images/page/168327/concurrency-Page-4.drawio_1.png)<br>
프로그래밍 관점에서 보면, 비동기 호출과 동기 호출은 매우 큰 차이가 있다.<br>
처리 흐름을 하나의 작업으로 생각할 때, 동기 호출 프로그래밍 방식에서는 함수를 호출한 스레드에서 전체 작업이 처리되는데 반해 비동기 호출 프로그래밍 방식에서는 작업 처리가 두 부분으로 나뉜다.<br>
1. 첫 번째 부분은 함수를 호출하는 스레드에서 처리된다. (request가 호출되기 전에 해당하는 부분)
2. 두 번째 부분은 함수를 호출하는 스레드에서 처리되지 않고 다른 스레드, 프로세스 혹은 다른 시스템에서 처리된다.<br>
호출자는 해당 작업이 끝난 후 무엇을 해야 하는지 알고 있으므로, 그 작업을 대신 처리해 줄 콜백 함수를 미리 전달해야 한다.<br>

## 2.5.5 콜백 함수의 정의

콜백 함수: 다른 코드에 매개변수로 전달되는 실행 가능한 코드<br>
일반적으로 콜백 함수의 호출 대상은 참조하는 외부 모듈이다.<br>

서드파티 라이브러리 작성자는 사용자가 어떤 작업을 하고 싶은지 알 수 없다.<br>
따라서, 작업이 끝나면 어떤 행동을 할지는 사용자가 콜백 함수로 정의해서 전달해야 한다.<br>
라이브러리는 특정 시점(이벤트 발생 등)에 콜백 함수를 자동으로 실행한다.<br>
콜백 함수는 사용자가 작성하지만 직접 호출하지 않고, 호출은 서드파티 라이브러리(또는 시스템)가 한다.<br>
따라서, 콜백과 주 프로그램은 같은 계층에 있지만 역할은 다르다고 할 수 있다.<br>
네트워크 응답 도착, 파일 다운로드 완료 등의 이벤트 발생에 맞춰 미리 등록한 콜백 함수가 자동으로 실행될 수 있어 콜백은 이벤트 중심(Event-driven) 프로그래밍에 매우 적합하다.<br>

## 2.5.6 두 가지 콜백 유형

동기 콜백은 가장 익숙한 콜백 유형으로, 블로킹 콜백이라고도 한다.<br>
함수 A를 호출할 때 콜백 함수를 매개변수로 전달한다고 가정하면, 함수 A가 반환되기 전에 콜백 함수가 실행된다.<br><br>

함수 A를 호출하고 콜백 함수를 매개변수 형태로 전달한다고 가정해보자. 함수 A의 호출이 즉시 완료되고 일정 시간이 지나면 콜백 함수가 실행된다.<br>
이때 주 프로그램과 콜백 함수의 실행이 동시에 진행될 수 있기에 보통 주 프로그램과 콜백 함수는 서로 다른 스레드 혹은 프로세스에서 실행되는데, 이를 **비동기 콜백**이라고 한다. 지연 콜백이라고도 부른다.<br>
비동기 콜백은 동기 콜백에 비해 다중 코어 리소스를 더 잘 활용하며, 입출력 작업이나 웹 서비스처럼 동시성이 높은 시나리오에 적합하다.<br>

## 2.5.7 비동기 콜백의 문제: 콜백 지옥

비즈니스 구성이 상대적으로 복잡한 경우 이 서비스 호출을 비동기 콜백으로 처리하면 콜백 지옥에 빠질 가능성이 높다.<br>
예를 들어 특정 작업을 처리하려면 서비스 네 개를 호출해야 하며, 각 서비스는 앞서 호출한 서비스의 결과를 사용하여 처리한다고 가정해보자.<br>
코드를 작성했을 때, 비동기 콜백이 동기 콜백에 비해 직관적으로 이해되지 않으며 복잡하다.<br>
비동기 콜백의 효율성과 동기 콜백의 코드 단순성과 가독성을 함께 누리기 위해 코루틴을 사용할 수 있다.<br>
