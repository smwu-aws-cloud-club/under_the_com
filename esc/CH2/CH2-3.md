# 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

## 2.3.1 자유와 제약

스레드 안전을 위한 2가지 시나리오가 있다.<br>
- 전용 리소스를 사용하는 스레드는 스레드 안전을 달성할 수 있다.
- 공유 리소스를 사용하는 스레드는 다른 스레드에 영향을 주지 않도록 하는 대기 제약 조건에 맞게 공유 리소스를 사용하면 스레드 안전을 달성할 수 있다.<br>

## 2.3.2 스레드 안전이란 무엇일까?

어떤 코드가 주어졌을 때, 그 코드가 스레드 호출 횟수와 순서에 상관없이 올바른 결과가 나오는 것을 **스레드 안전**이라고 한다.<br>
다시 말하자면 코드가 단일 스레드에서 실행되든 다중 스레드에서 실행되든 올바른 결과가 나와야 한다는 뜻이다.<br>
스레드 안전 문제의 핵심은 **어떤 것이 스레드 전용 리소스이고, 어떤 것이 스레드 공유 리소스인지 구분**하는 데 있다.<br>

## 2.3.3 스레드 전용 리소스와 공유 리소스

- 스레드 전용 리소스: 함수의 지역 변수, 스레드의 스택 영역, 스레드 전용 저장소
- 공유 리소스
    - 힙 영역: 메모리의 동적 할당에 사용되는 영역
    - 데이터 영역: 전역 변수가 저장되는 영역
    - 코드 영역: 읽기 전용<br><br>

공유 리소스를 사용하는 스레드는 반드시 순서를 따라야 하며, 핵심은 공유 리소스를 사용하는 작업이 다른 스레드를 방해할 수 없다는 것이다.<br>
이를 위해 각종 잠금이나 세마포어(semaphore)와 같은 장치를 사용할 수 있다.<br>

## 2.3.4 스레드 전용 리소스만 사용하기

스레드 전용 리소스인 지역 변수만 사용하는 함수는 실행된 후 스레드의 스택 영역에서 관리한다.<br>
이런 코드를 무상태 함수라고도 하며, 스레드 안전이다.<br>

## 2.3.5 스레드 전용 리소스와 함수 매개변수

함수 매개변수를 값으로 전달(call by value)하는 경우라면 스레드 안전이다.<br>
값으로 전달된 매개변수도 스레드 전용 리소스이며, 이 매개변수들도 스레드의 스택 영역에 저장되기 때문이다.<br><br>

함수 매개변수를 포인터로 전달하면 상황이 달라진다.<br>
전달된 매개변수가 데이터 영역에 위치한 전역 변수를 가리키고 있고, 이 전역 변수는 모든 스레드가 공유하는 리소스에 해당하기 때문에 스레드 안전이 아니다.<br>
따라서 이 경우 전역 변수와 관련된 작업에 잠금과 같은 형태의 순서가 반드시 부여되어야 한다.<br><br>

포인터가 힙 영역을 가리키는 경우에도 포인터를 통해 모든 스레드가 포인터가 가리키는 데이터에 접근할 수 있기 때문에 스레드 안전이 아니다.<br>
이 경우 모든 스레드가 함수를 호출할 때 해당 스레드에 속하는 리소스 주소를 전달하는 것으로 해결할 수 있다.<br><br>

이처럼 스레드 안전인 코드를 작성하는 원칙 중 하나는 **스레드 간에 공유 리소스를 사용하지 않도록 가능한 한 모든 조치를 취하는 것**이다.<br>

## 2.3.6 전역 변수 사용

사용되는 전역 변수가 처음 프로그램이 실행될 때 한 번 초기화되고 나서 모든 코드가 이 변수를 읽는다면 스레드 안전 코드가 된다.<br>
전역 변수의 변경 과정은 반드시 잠금 등의 보호 또는 덧셈 작업을 원자성 작업으로 설정해서 보호해야 한다.<br>

## 2.3.7 스레드 전용 저장소

전역 변수 앞에 ```__thread```를 붙여 스레드 안전으로 만들 수 있다.<br>
```__thread``` 수식어가 붙은 변수는 스레드 전용 저장소에 배치되기 때문이다. (2.2.7 참고)<br>

## 2.3.8 함수 반환값

함수가 값을 반환할 때는 함수가 값을 반환하는 경우와 함수가 포인터를 반환하는 경우로 나눌 수 있다.<br>
함수가 값을 반환하는 경우에는 스레드 안전이다.<br>
하지만 변수의 주소(포인터)를 반환하면 잠재적으로 스레드 공유 리소스가 되어 해당 주소를 획득할 수 있는 모든 스레드가 해당 변수를 수정할 수 있게 되고, 스레드 안전이 아니다.<br><br>

```
class S
{
public:
    static S & getInstance()
    {
        static S instance;
        return instance;
    }

private:
    S() {}
...
};
```
하지만 위의 코드처럼 클래스 내부에서만 생성자를 호출해 인스턴스를 생성한다면 ```static S instance;```가 함수 안의 static 지역 변수가 되므로 스레드 안전이라고 할 수 있다.<br>

## 2.3.9 스레드 안전이 아닌 코드 호출하기

스레드 안전이 아닌 코드는 함수를 호출하기 전에 잠금으로 보호하여 스레드 안전으로 만들 수 있다.<br>
잠금으로 전역 변수를 간접적으로 보호하기 때문이다.<br><br>

또한 매개변수로 전달된 포인터가 저역 변수를 가리키는지 알 수 없을 때 스레드 안전이 아니다.<br>
이때 ```int b = func(&a);```처럼 전달된 매개변수를 스레드 전용 리소스인 지역 변수로 만들면 스레드 안전으로 만들 수 있다.<br>

## 2.3.10 스레드 안전 코드는 어떻게 구현할까?

공유 리소스가 어느 영역에 저장되어 있든 관계없이 다중 스레드 프로그래밍 중에는 어떤 리소스라도 최대한 공유하지 않는 것이 원칙이다.<br>
처리해야 할 작업이 스레드 사이에서 리소스를 공유해야 한다면 반드시 코드의 스레드 안전에 주의를 기울여야 한다.<br>
스레드 안전을 달성하려면 **무엇이 스레드 전용 리소스와 스레드 공유 리소스인지 분류**하는 것이 중요하다.<br><br>

- 스레드 전용 저장소: 전역 리소스를 사용해야 하는 경우 스레드 전용 저장소로 선언 가능한지 확인해본다.
- 읽기 전용: 전역 리소스를 사용해야 한다면 해당 전역 리소스를 읽기 전용으로 사용 가능한지 확인해본다.
- 원자성 연산: 도중에 중단되지 않는 원자성 연산을 이용한다.
- 동기화 시 상호 배제: 한 번에 하나의 스레드만 공유 리소스에 접근할 수 있도록 뮤텍스, 스핀 잠금, 세마포어 등의 방식을 사용한다.<br>

지금까지의 스레드는 기본적으로 커널 스레드이므로, 스레드의 관리를 운영 체제가 수행한다.<br>
운영 체제에 의존하지 않는 상황에서 직접 스레드를 구현하기 위해서 **코루틴**을 사용할 수 있다.<br>