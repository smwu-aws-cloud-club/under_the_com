# 2.8 높은 동시성과 고성능을 갖춘 서버 구현

## 2.8.1 다중 프로세스

다중 프로세스: 가장 간단한 형태의 병행 처리 방식, 부모 프로세스가 사용자 요청을 먼저 수신하고, 자식 프로세스를 생성해서 해당 사용자 요청을 처리한다.<br>
모든 요청에는 각각 대응하는 프로세스가 있다.<br><br>

다중 프로세스의 장점은 다음과 같다.
1. 프로그래밍이 간단하다.
2. 개별 프로세스의 주소 공간이 서로 격리되어 있어 하나의 프로세스에 문제가 발생해도 다른 프로세스에 영향 X
3. 다중 코어 리소스를 최대한 활용 가능<br><br>

다중 프로세스의 단점은 다음과 같다.
1. 개별 프로세스의 주소 공간이 서로 격리되어 있어 프로세스 간 통신 작동 방식이 어려움
2. 프로세스를 생성할 때 부담이 상대적으로 크고, 프로세스의 빈번한 생성과 종료로 인해 시스템 부담이 증가함<br>

## 2.8.2 다중 스레드

스레드는 프로세스 주소 공간을 공유하기 때문에 스레드 간 통신을 위해 별도의 통신 작동 방식을 사용할 필요가 없다.<br>
주소 공간은 프로세스가 소유하고 있기 때문에 스레드는 가볍고 생성과 종료에 드는 부담이 적다.<br>
각 요청에 대응하는 스레드를 생성하여 사용자 요청을 처리한다.<br><br>

하지만 스레드는 서로 같은 주소 공간을 공유학 ㅣ때문에 하나의 스레드에 문제가 발생하면 같은 프로세스를 공유하는 모든 스레드와 프로세스에 문제가 발생한다.<br>
또한 여러 스레드가 동시에 공유 리소스의 데이터를 읽고 쓸 수 없기 때문에 공유 데이터의 스레드 안전 문제를 방지하기 위해 동기화 시 상호 배제와 같은 작동 방식을 사용해야 하고, 교착 상태와 같은 문제를 일으킬 수 있다.<br>
스레드를 생성할 때 발생하는 부담이 프로세스에 비해서는 덜하지만, 부담 자체가 없는 것은 아니므로 높은 동시성을 가지는 경우 과도한 메모리 소비나 성능 문제가 발생할 수 있다.<br>

## 2.8.3 이벤트 순환과 이벤트 구동

병행 프로그래밍을 위해 이벤트 기반의 동시성을 이용한 이벤트 기반 프로그래밍 기술을 사용할 수 있다.<br><br>

이벤트 기반 프로그래밍 기술에는 두 가지 요소가 필요하다.
1. 이벤트: 네트워크 데이터의 수신 여부, 파일의 읽기 및 쓰기 가능 여부 등이 관심 대상인 이벤트
2. 이벤트 처리 함수 = 이벤트 핸들러<br>
이벤트 도착 → 이벤트 유형 확인 → 대응하는 이벤트 핸들러 호출<br>
이벤트가 계속해서 발생하므로 ```while``` 또는 ```for``` 반복문을 사용해 반복적으로 처리하고, 이 반복을 **이벤트 순환**이라고 한다.<br><br>

이벤트 순환에는 두 가지 문제가 있다.
1. ```getEvent()``` 같은 함수로 어떻게 여러 이벤트를 가져올 것인가?
2. 이벤트를 처리하는 ```handler``` 함수가 반드시 이벤트 순환과 동일한 스레드에서 실행되어야 하는가?<br>

## 2.8.4 첫 번째 문제: 이벤트 소스와 입출력 다중화

가장 단순한 방법으로, 사용자 연결에 대응하는 소켓 서술자를 사용자 연결만큼 만들어 데이터를 수신할 수 있다.<br>
```
recv(fd1, buf1);
recv(fd2, buf2);
...
```
이 경우 첫 번째 사용자가 데이터를 보내지 않으면 ```recv(fd1, buf1);```가 반환되지 않아 서버가 두 번째 사용자의 데이터를 수신할 수 없다.<br><br>

따라서 입출력 다중화 방식으로, 운영 체제에 다음 내용을 전달하는 작동 방식을 사용하는 것이 더 낫다.<br>
리눅스에서는 입출력 다중화 방식을 위해 ```epoll```을 사용한다.<br>
```
epoll_fd = epoll_create(); // epoll 생성

Epoll_ctl(epoll_fd, fd1, fd2, fd3, fd4...); // 서술자를 epoll이 처리하도록 지정

while (1) {
    int n = epoll_wait(epoll_fd);
    for (i = 0; i < n; i++) {
        // 특정 이벤트 처리
    }
}
```
```epoll_wait()```을 이용해 이벤트가 발생한 fd 리스트를 반환하여 이벤트 순환의 엔진이 되고, 지속적으로 다양한 이벤트를 제공한다.<br>

## 2.8.5 두 번째 문제: 이벤트 순환과 다중 스레드

이벤트 핸들러에 다음과 같은 두 가지 특징이 있다고 가정해보자.<br>
1. 입출력 작업 X
2. 처리 함수가 간단해 소유 시간이 매우 짧음<br>
이 경우 이벤트 핸들러와 이벤트 순환을 동일한 스레드에서 실행할 수 있다.<br>
하지만 사용자 요청을 처리하는 데 CPU 시간을 많이 소모한다면 단일 스레드는 처리가 느리다.<br>
요청의 처리 속도를 높이고 다중 코어를 최대한 활용하기 위해서는 다중 스레드를 사용해야 한다.<br>
이벤트 핸들러를 독립적인 스레드에 배치해 작업자 스레드를 만들고, 작업자 스레드에 이벤트를 분배할 이벤트 순환 스레드를 생성해 다중 스레드를 이용한 병행 실행을 할 수 있다.<br>
해당 구조는 시스템의 다중 코어를 최대한 활용해 요청 처리를 가속화하며, 스레드 풀로 구현할 수도 있다.<br>
이러한 설계 방법을 **반응자 패턴**이라고 부른다.

## 2.8.6 카페는 어떻게 운영되는가: 반응자 패턴

카운터에서 한 명의 종업원이 주문을 받고, 여러 명의 주방 요리사가 요리를 하여 전달할 수 있다.<br>
이때 고객은 이벤트 순환, 주방 요리사는 작업자 스레드, 카페를 운영하는 전체적인 방식을 반응자 패턴에 대응할 수 있다.<br>

## 2.8.7 이벤트 순환과 입출력

이제 요청 처리 과정에 입출력 작업도 포함된다고 가정해보자.<br>
이때 입출력 작업을 두 가지 상황으로 나눌 수 있다.
1. 입출력 작업에 대응하는 논블로킹 인터페이스가 있는 경우 - 직접 논블로킹 인터페이스를 호출해도 스레드가 일시 중지 X, 인터페이스 즉시 반환 → 이벤트 순환에서 직접 호출 OK
2. 입출력 작업에 블로킹 인터페이스만 있는 경우 - 이벤트 순환 내에서 블로킹 인터페이스를 호출하면 이벤트 순환 스레드가 중지되어 시스템이 멈춤 → 블로킹 입출력 호출이 포함된 작업은 작업자 스레드에 전달<br><br>

시스템의 전체적인 형태는 아래 그림과 같이 구성된다.<br>
![이벤트 순환과 입출력](/esc/CH2/images/pic2_68.png)<br>

## 2.8.8 비동기와 콜백 함수

서버 기능이 복잡해지며 서버 기능을 용도에 따라 여러 부분으로 나뉘어 각 부분을 별도의 서버에 배치하게 되었다.<br>
서버는 일반적으로 **RPC(원격 프로시저 호출)**를 통해 네트워크 설정, 데이터 전송, 데이터 분석 등의 작업을 담아 일반 함수를 호출하는 것처럼 네트워크로 통신할 수 있도록 한다.<br>
```
GetUserInfo(request, response);
```
<br>
RPC 호출은 모두 블로킹 호출이기 때문에 사용자가 응답하기 전에는 함수가 반환되지 않는다. 이로 인해 스레드가 빈번하게 중단되면 CPU의 리소스를 최대한 활용하지 못한다.<br>
이를 보완하기 위해 동기 방식의 RPC 호출을 비동기 호출로 수정해야 한다.
```
GetUserInfo(request, callback);
```
비동기 호출은 호출 스레드를 블로킹하지 않기 때문에 함수가 즉시 반환되지만, 함수 반환 시 사용자 응답에 대한 결과가 없을 수도 있다.<br>
따라서 ```GetUserInfo()```를 호출한 후 처리할 내용을 콜백 함수에 담아 RPC 호출에 포함시켜야 한다.<br>

## 2.8.9 코루틴: 동기 방식의 비동기 프로그래밍

코루틴: 일시 중지(```yield```)와 재개가 가능한 함수
프로그래밍 언어나 프레임워크가 코루틴을 지원하는 경우 ```handler``` 함수를 코루틴에서 실행되게 할 수 있다.<br>
```handler``` 함수는 동기적으로 작성되지만, RPC 통신과 같이 같이 오래 걸리는 작업을 만나면 yield로 제어권을 반환해 코루틴은 멈추고, 작업자 스레드는 다른 코루틴을 즉시 실행할 수 있다. 이처럼 동기 코드처럼 보이지만 비동기로 동작한다.<br>
여기서 가장 중요한 점은 **코루틴이 일시 중지되더라도 작업자 스레드가 블로킹되지 않는다**는 것이다.<br><br>

![코루틴 추가 후 서버의 전체 구조](/esc/CH2/images/pic2_72.png)<br>

코루틴이 일시 중지되면 작업자 스레드는 준비 완료된 다른 코루틴을 실행하기 위해 전환되며, 일시 중지된 코루틴에 할당된 사용자 서비스가 응답한 후 그 처리 결과를 반환하면 다시 준비 상태가 되어 스케줄링 차례가 돌아오길 기다린다. 이후 코루틴은 마지막으로 중지되었던 곳에서 이어서 계속 실행된다.<br>
코루틴의 도움으로 동기 방식으로 프로그래밍하더라도 비동기 실행과 같은 효과를 얻는다는 목표를 달성할 수 있다.<br>
이와 같이 코루틴이 블로킹 방식으로 RPC 호출을 하더라도 작업자 스레드는 블로킹되지 않기 때문에 시스템 리소스를 효율적으로 사용하겠다는 목적을 달성할 수 있다.<br>

## 2.8.10 CPU, 스레드, 코루틴

- CPU: 기계 명령어를 실행하여 컴퓨터를 움직임, 하드웨어
- 스레드: 커널 상태 스레드, 커널로 생성되고 스케줄링. 스레드 우선순위에 따라 CPU 연산 리소스 할당
- 코루틴: 사용자 상태 스레드, 커널 입장에서는 알 수 없음. 프로그래머가 스레드에 할당된 시간 내 실행할 코루틴을 결정할 수 있음.