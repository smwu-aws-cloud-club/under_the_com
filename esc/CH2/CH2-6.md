# 2.6 동기와 비동기를 철저하게 이해한다.

## 2.6.1 고된 프로그래머

작업을 주고 완료할 때까지 계속 기다리는 시나리오는 **동기 작업**에 해당한다.<br>
작업을 마칠 때까지 기다리지 않고 다른 작업을 처리하다가, 해당 작업의 처리가 완료된 후 보고하는 시나리오는 **비동기 작업**에 해당한다.<br>
두 가지 작업을 동시에 진행할 수 있기 때문에 일반적으로 비동기가 동기보다 더 효율적이다.<br>

## 2.6.2 전화 통화와 이메일 보내기

전화 통화를 할 때, 한 사람이 말하면 다른 사람은 듣는다. 전화 의사소통은 동기이며, "의존성", "연관성", "기다림" 등의 단어를 떠올릴 수 있다.<br>
이메일을 작성하는 동안, 다른 사람들은 다른 일을 처리할 수 있다. 이메일 의사소통은 비동기이며, "기다릴 필요 없음"이라는 단어를 떠올릴 수 있다.<br>

## 2.6.3 동기 호출

일반적인 함수 호출은 동기 방식이다.<br>
동기 호출 방식은 여러 함수가 동일한 스레드에서 실행된다.<br>
입출력 작업의 경우, 최하단 계층에서 시스템 호출로 운영 체제에 요청을 보내 호출 스레드를 일시 중지시키고 커널이 디스크 내용을 읽어온 뒤 스레드를 재개한다.<br>
이것을 블로킹 입출력이라고 부르며, 코드가 다른 스레드에서 실행되고 있는 동기 호출이다.<br>
여기서 동기 호출은 호출자와 수신자가 같은 스레드에서 실행 중인지 여부와는 관련이 없다는 결론을 내릴 수 있다.<br>
동기 프로그래밍은 이해하기 쉬우나 일부 상황에서 호출자가 요청한 작업이 끝날 때까지 기다려야 하기 때문에 효율은 높지 않다.<br>

## 2.6.4 비동기 호출

일반적으로 비동기 호출은 디스크의 파일 읽고 쓰기, 네트워크 데이터 송수신, 데이터베이스 작업처럼 시간이 많이 걸리는 입출력 작업을 백그라운드 형태로 실행한다.<br>
비동기 입출력에서는 호출자가 블로킹되지 않고 함수가 즉시 반환되기 때문에 호출자는 즉시 다음 작업을 실행할 수 있어 높은 효율성이 나타난다.<br>
그러나 비동기 호출은 프로그래머가 이해하는 데 부담이 될 수 있으며, 코드를 작성하기 어렵다.<br><br>

비동기 호출 방식에서 작업이 실제로 완료되는 시점은 어떻게 파악할 수 있을까?
이에 대한 처리는 두 가지 상황이 있을 수 있다.
1. 호출자가 실행 결과를 전혀 신경 쓰지 않을 때
2. 호출자가 실행 결과를 반드시 알아야 할 때<br><br>

```
void handler(void* buf) {
    ... // 파일 내용 처리 중
}
read(buf, handler);
```
첫 번째 상황을 위해 콜백 함수를 사용할 수 있다.<br>
```read``` 함수를 비동기 호출할 때 파일 내용을 처리하는 함수를 함께 매개변수로 전달할 수 있다.<br>
```read(buf, handler);``` 코드에서 파일을 읽고, 작업이 완료되면 전달된 함수를 사용하여 파일을 처리하게 된다.<br>
이때 파일 내용은 호출자 스레드가 아닌 콜백 함수가 실행되는 다른 스레드 또는 프로세스 등에서 처리되며, 콜백 함수의 실행 결과는 호출자 스레드에 반환되지 않는다.<br><br>

두 번째 상황을 구현하는 방법 중 하나는 알림 작동 방식을 사용하는 것이다.<br>
작업 실행이 완료되면 호출자에게 작업 완료를 알리는 신호나 메시지를 보내고, 결과 처리는 호출 스레드에서 진행한다.<br>

## 2.6.5 웹 서버에서 동기와 비동기 작업

웹 서버에서 사용자 요청을 처리하기 위해 다음과 같은 단계를 거친다고 가정해보자.<br>
```A → B → C → DB 요청 → D → E → F```
여기에서 입출력 작업이 필요한 유일한 단계는 DB 요청 작업이다.<br>
일반적으로 이런 형태의 웹 서버에는 주 스레드와 DB 처리 스레드라는 전형적인 스레드 2개가 있다.<br><br>

동기 방식의 경우, DB 요청 후 주 스레드가 블로킹되어 일시 중지되며, DB 스레드에서 DB 처리가 완료된 시점에서 다음 단계가 실행된다.<br>
이로 인해 주 스레드에서 유휴 시간이 발생한다.<br><br>

비동기 방식에서는 주 스레드가 DB 처리가 완료될 때까지 기다리는 대신, DB 처리 요청을 전송하자마자 바로 다음에 넘어온 새로운 사용자 요청을 직접 처리한다.<br>
비동기 방식에서는 두 가지 상황이 존재한다.<br><br>

첫 번째 상황: 주 스레드가 DB 처리 결과를 전혀 신경 쓰지 않을 때<br>
주 스레드에서 A, B, C를 처리하고, 비동기 호출을 통해 DB 스레드에서 DB 처리를 진행한 후 D, E, F 작업을 처리한다.<br>
이때 DB를 처리한 후 콜백 함수를 통해 D, E, F 단계에 대한 작업 방식을 알 수 있다.<br>
DB 스레드에서는 자신의 주 업무인 DB를 처리하고, 콜백 함수를 호출해 자신의 임무를 완료한다. 이후 콜백 함수를 통해 함수에 작성된 D, E, F 작업을 처리한다.<br>
주 스레드의 유휴 시간이 없어지고 끊임없이 작업을 처리하기 때문에 시스템 리소스 활둉도가 높아져 효율성이 높아진다.<br>
하지만 비동기 프로그램은 동기 프로그램보다 이해하기 어려우며 시스템 유지 보수가 어렵다.<br><br>

두 번째 상황: 주 스레드가 DB 작업 결과에 관심을 가질 때
DB 스레드가 알림 작동 방식을 이용하여 작업 결과를 주 스레드로 전송하고, 주 스레드는 메시지를 수신하면 이전 사용자 요청의 후반부를 이어서 처리한다.<br>
DB 스레드가 처리하고 있는 동안 주 스레드에서는 다음 작업을 이어서 실행한다.<br>
DB 스레드는 유휴 상태이지만 주 스레드에 유휴 시간이 없기 때문에 동기 호출에 비하면 효율적이다.<br>
다만 모든 비동기 호출이 반드시 동기 호출보다 더 효율적인 것은 아니기 때문에 구체적인 상황에 따라 분석해야 한다.<br><br>
