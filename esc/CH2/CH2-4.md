# 2.4 프로그래머는 코루틴을 어떻게 이해해야 할까?

## 2.4.1 일반 함수

일반 함수는 return 명령어를 만나거나 코드의 마지막 줄까지 실행되어야 반환이 가능하다.<br>
또한 해당 함수가 재호출되면 다시 처음부터 시작하여 반환될 때까지 모든 줄을 하나씩 실행한다.<br>

## 2.4.2 일반 함수에서 코루틴으로

일반 함수와 코루팀에 형식적인 차이는 없으나 코루틴에는 일시 중지와 재개 기능이 있다.<br>
코루틴은 자신의 실행 상태를 저장할 수 있기 때문에 코루틴이 반환된 후에도 계속 호출이 가능하며, 마지막으로 일시 중지된 지점에서 다시 이어서 실행된다.<br>
```return``` 명령어를 사용한 뒤 코드를 실행할 방법이 없는 것과 대비된다.<br>
코루틴 코드에서 코루틴 획득은 ```co = func()```로, 호출은 ```next(co)```로, 정지는 ```yield```로 할 수 있다.<br>

## 2.4.3 직관적인 코루틴 설명

funcA 함수는 어느 정도 실행되다가 코루틴을 실행한다.<br>
코루틴이 시작되면 첫 번째 연결 시작 지점까지 실행하다가 일반 함수와 같은 형태로 funcA 함수로 돌아간다.<br>
funcA 함수는 이어서 실행되다가 다시 코루틴을 실행하고, 앞의 연결 지점부터 실행되어 일반 함수와 같은 형태로 돌아간다.<br>

## 2.4.4 함수는 그저 코루틴의 특별한 예에 불과하다

코루틴이 일반 함수와 다른 점은 **자신이 이전에 마지막으로 실행된 위치를 알 수 있다**는 것이다.<br>
이는 운영체제가 스레드를 스케줄링 하는 것과 동일하다.<br>
유의할 점은 코루틴은 온전히 사용자 상태 내에서 구현된 것이기 때문에 운영체제는 코루틴 생성에 대한 정보를 알지 못한다는 것이다.<br>
따라서 코루틴은 **사용자 상태 스레드**로 해석할 수 있다.<br>

## 2.4.5 코루틴의 역사

코루틴 개념은 1958년에 등장했다. 이 시기에는 아직 스레드가 없었기 때문에 동시성을 가지는 프로그램을 작성하려면 코루틴과 같은 기술을 사용할 수밖에 없었다.<br>
이후 스레드가 등장하고 운영체제가 기본적으로 프로그램의 동시 실행을 지원하면서 코루틴은 잊혀져갔다.<br>
인터넷이 발달하며 서버에서 처리해야 하는 사용자 요청이 기하급수적으로 늘어나며 코루틴은 높은 성능과 동시성을 요구하는 분야에서 다시 사용되게 되었다.<br>

## 2.4.6 코루틴은 어떻게 구현될까?

코루틴의 구현은 스레드의 구현과 본질적으로 차이가 없다.<br>
코루틴은 일시 중지도거나 다시 시작될 수 있으며, 일시 중지될 대의 상태 정보를 반드시 기록해야 이를 기반으로 코루틴을 다시 시작해야 한다.<br>
상태 정보에는 CPU의 레지스터 정보, 함수 실행 시 상태 정보가 포함되며 주로 함수의 스택 프레임에 저장된다.<br>
코루틴의 스택 프레임 정보는 힙 영역에 배치된다.<br><br>

코루틴은 프로그래머가 동기 방식으로 비동기 프로그래밍을 가능하게 한다.<br>