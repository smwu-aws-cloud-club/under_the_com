# 2.1 운영 체제, 프로세스, 스레드의 근본 이해하기

정적인 프로그램을 넘어 프로그램의 동적 실행에 대해 다뤄보자.<br>

## 2.1.1 모든 것은 CPU에서 시작된다

CPU가 실행할 수 있는 것은 다음과 같다.
1. 메모리에서 명령어(Instruction)을 하나 가져온다.(dispatch)
2. 이 명령어를 실행(execute)한 후 다시 1.로 돌아간다.

프로그램 카운터(PC) 레지스터에는 CPU가 다음에 실행할 명령어 주소가 저장된다. <br>
PC 레지스터가 저장하는 주소는 기본적으로 1씩 자동으로 증가하지만, 함수 호출 같은 명령어를 만나면 CPU는 연산 결과 또는 명령어에서 지정한 점프할 대상 주소에 따라 PC 레지스터 값을 동적으로 변경한다. <br>
최초의 PC 레지스터 값은 main 함수에 대응하는 첫 번째 기계  명령어 주소이다. <br>

## 2.1.2 CPU에서 운영 체제까지

CPU가 프로그램을 실행하게 하려면 실행 파일을 수동으로 메모리에 복사한 후 main 함수에 해당하는 첫 번째 기계 명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재하면 된다.<br>
이를 위해서는 수동으로 다음과 같은 작업을 실행해야 한다.<br>
- 프로그램을 적재할 수 있는 적절한 메모리 영역 찾기
- CPU 레지스터를 초기화하고 함수의 진입 포인트를 찾아 PC 레지스터 설정하기 <br><br>

또한 수동으로 프로그램을 실행하면 다음과 같은 문제가 발생한다.<br>
- 한 번에 하나의 프로그램만 실행할 수 있다.
- 모든 프로그램은 사용할 하드웨어를 직접 특정 드라이버와 연결해야 한다.
- 라이브러리를 직접 구현해야 한다.
- 상호 작용 인터페이스를 직접 구현해야 한다. <br>

CPU는 한 번에 한 가지 일만 할 수 있다.<br>
하지만 빠르게 프로그램을 전환하면 프로그램이 동시에 실행되는 것처럼 보인다. 이것이 **멀티태스킹**이다.<br>
각 프로그램을 재개하기 위해서 **프로세스**에 상황 정보(context)를 저장하여 프로그램 실행 상태를 저장하고 복구한다.<br>
이러한 기능들을 모아 둔 프로그램을 **운영 체제**라고 부른다.<br>

## 2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다

프로세스 주소 공간은 다음과 같이 구성된다. <br>
![프로세스 주소 공간](https://velog.velcdn.com/images%2Fklm03025%2Fpost%2Fcd3ef853-de73-4a07-b062-263ff9d1acdc%2Fimage.png)<br>
- 코드 영역: 코드를 컴파일하여 생성된 기계 명령어 저장
- 데이터 영역: 전역 변수 등 저장
- 힙 영역: malloc 함수가 요청을 반환한 메모리 할당
- 스택 영역: 함수의 실행 시간 스택<br><br>

프로세스를 각각 실행한 뒤 프로세스 간 통신을 이용해 **다중 프로세스 프로그래밍**을 구현할 수 있다. 하지만 이 다중 프로세스 프로그래밍에는 다음과 같은 단점이 있다.<br>

1. 프로세스를 생성할 때 오버헤드가 발생한다.
2. 프로세스마다 자체 주소 공간이 있기 때문에 프로세스 간 통신을 프로그램이하기 어렵다.<br>

## 2.1.4 프로세스에서 스레드로 진화

프로세스의 단점은 진입 함수가 ```main``` 함수 하나밖에 없어 프로세스의 기계 명령어를 한 번에 하나의 CPU에셔만 실행할 수 있다는 것이다.<br>
PC 레지스터가 ```main``` 함수가 아닌 다른 함수를 가리키게 하여 새로운 실행 흐름을 형성할 수 있다. <br>
가장 중요한 점은 실행 흐름이 동일한 프로세스 주소 공간을 공유하므로 프로세스간 통신이 불필요하다는 것이다. <br><br>

![스레드와 프로세스](https://velog.velcdn.com/cloudflare/aeong98/9145d4b1-b054-4bde-926c-d02506dc5592/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3.png)
이렇게 하나의 프로세스 안에 여러 실행 흐름이 존재하는 것을 **스레드**라고 부른다.<br>
스레드는 코어 개수와는 무관하기 때문에 단일 코어인 상황에서도 스레드 여러 개를 생성할 수 있다. 이 덕분에 처리 시간이 긴 이벤트를 위한 별도의 스레드를 생성하는 방식으로 프로그래밍을 할 수 있다.<br>
하지만 다중 스레드 공유 리소스에서는 상호 배제와 동기화 문제를 해결해야 한다.<br>

## 2.1.5 다중 스레드와 메모리 구조

스레드를 사용하게 되면서 하나의 프로세스에 실행 진입점과 실행 흐름이 여러 개 존재할 수 있게 되었다.<br>
이에 따라 실행 흐름을 저장하기 위한 스택 영역이 여러 개 필요하게 되었다.<br>

## 2.1.6 스레드 활용 예

스레드 활용은 수명 주기 관점에서 볼 때, 긴 작업과 짧은 작업 두 가지 유형이 있다.<br>
**긴 작업**을 처리하기 위해서는 전용 스레드를 생성하는 것이 가장 적합하다.<br><br>

**짧은 작업**은 네트워크 요청, 데이터베이스 쿼리 등 처리 시간이 매우 짧은 작업이다.<br>
짧은 작업은 작업 처리에 필요한 시간이 짧지만, 작업 수가 매우 많다.<br>
따라서 요청이 들어올 때마다 해당 작업을 처리하는 요청당 스레드 방식을 사용하면 다음과 같은 문제가 발생한다.<br>
1. 스레드의 생성과 종료에 시간 소모
2. 스레드의 독립적인 스택 영역으로 인한 메모리 과다 소비
3. 스레드 간 전환에 따른 부담 증가<br>
이를 해결하기 위해 **스레드 풀**이 도입되었다.<br>

## 2.1.7 스레드 풀의 동작 방식

스레드 풀은 스레드 여러 개를 미리 생성해 두고, 스레드가 처리할 작업이 생기면 해당 스레드에 처리를 요청하는 방법이다.<br>
이 개념에서 중요한 점은 스레드를 **재사용**하는 것이고, 이를 위해 자료 구조 중 queue를 사용한다.<br>
스레드 풀에 작업이 전달되는 과정은 다음과 같다.<br>
1. 스레드 풀의 스레드는 작업 대기열에서 블로킹 상태로 대기한다.
2. 생산자가 작업 대기열에 데이터를 기록한다.
3. 스레드 풀의 스레드가 깨어나 작업 대기열에서 처리할 데이터를 가져온 후 처리 함수를 실행한다.<br>

## 2.1.8 스레드 풀의 스레드 수

스레드 풀에서 처리할 작업에 따라 스레드 풀의 스레드 수가 변한다.<br>
작업을 처리할 때 필요한 리소스 관점에서 작업을 CPU 집약적인 작업과 입출력 집약적인 작업으로 구분할 수 있다.<br>
CPU 집약적인 작업은 스레드 수와 CPU의 코어 수가 동일하다면 CPU의 리소스를 충분히 활용할 수 있다.<br>
입출력 집약적인 작업은 성능 테스트 도구를 사용하여 입출력 대기 시간(WT)와 CPU 연산 시간(CT)를 계산하고, N개의 코어를 가졌다고 할 때 적절한 스레드 수는
``` N * (1 + WT / CT)```로 계산할 수 있다.<br>