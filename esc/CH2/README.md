# 2. 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다.

프로그램의 동적 실행으로 시선을 옮겨 보자. <br>
→ 프로그램이 실행되면 어떻게 변화하는지? 운영체제는 왜 필요한지? 프로세스, 스레드, 코루틴, 콜백 함수, 동기화, 비동기화, 블로킹, 논블로킹이 무엇인지? 왜 이런 개념들을 이해해야 하는지?

## 2.1 운영 체제, 프로세스, 스레드의 근본 이해하기

CPU는 메모리에서 명령어를 가져와서 실행하는 것만 할 수 있다.<br>
프로그램 카운터(PC)는 CPU가 다음에 실행할 명령어의 가상 주소를 저장하는 레지스터이며, 일반적으로 현재 명령어의 길이만큼 증가한다.<br>
분기나 함수 호출과 같은 명령어를 만나면 CPU는 해당 명령어가 지정한 대상 주소에 따라 PC 값을 변경한다.

CPU가 프로그램을 실행하게 하려면 실행 파일을 수동으로 메모리에 복사한 후 main 함수에 해당하는 첫 번째 기계 명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재하면 된다.<br>
이를 위해서는 수동으로 프로그램을 적재할 수 있는 적절한 메모리 영역을 찾고, CPU 레지스터를 초기화하고 함수의 진입 포인트를 찾아 PC 레지스터를 설정하는 작업을 실행해야 한다.<br>
또한 수동으로 실행하는 프로그램은 한 번에 하나만 실행할 수 있으며, 사용할 하드웨어를 직접 특정 드라이버와 연결해야 외부 장치를 사용할 수 있다. 네트워크로 통신하려면 TCP/IP 스택 소스 코드도 연결해야 한다. 라이브러리도 직접 구현해야 하고, 상호 작용 인터페이스도 구현해야 한다.<br>
이러한 방식 대신 **적재 도구**를 실행해 프로그램을 메모리에 적재한다.

CPU는 한 시점에 하나의 실행 흐름만 처리할 수 있지만 운영체제가 **프로세스**의 레지스터 상태와 같은 실행 문맥(context)을 저장하고 복구하면서 빠르게 전환함으로써 여러 프로그램이 동시에 실행되는 것처럼 보이게 한다.<br>
이러한 기능을 포함하여 프로그램 적재, 프로세스 관리, 하드웨어 자원 관리 등의 역할을 수행하는 소프트웨어 집합을 **운영체제**라고 한다.

프로그램이 실행 중일 때 운영 체제의 가상 메모리는 각각의 프로세스가 표준적인 메모리 크기를 독점적으로 사용하는 것처럼 보이게 한다. 이를 프로세스 주소 공간이라고 부른다.
- 코드 영역: 코드를 컴파일하여 생성된 기계 명령어 저장
- 데이터 영역: 전역 변수 등 저장
- 힙 영역: malloc 함수가 요청을 반환한 메모리 할당
- 스택 영역: 함수의 실행 시간 스택

<br>

독립적인 프로세스를 각각 실행한 후 프로세스 통신을 이용해 다중 프로세스 프로그래밍을 구현하여 실행 속도를 높일 수 있다.<br>
하지만 프로세스를 생성할 때 오버헤드가 발생하고, 프로세스마다 자체 공간이 있어 프로세스 간 통신을 프로그래밍 하기에 복잡하다는 단점이 있다.

<br>

<img width="350" height="300" alt="image" src="images/thread.png" /><br>

또한 프로세스는 진입 함수가 `main` 함수 하나밖에 없어 프로세스의 기계 명령어를 한 번에 하나의 CPU에셔만 실행할 수 있다.<br>
이때 CPU가 여러 개가 있다면, 각 CPU의 PC 레지스터가 `main` 함수가 아닌 다른 함수를 가리키게 하여 새로운 실행 흐름을 형성할 수 있다. <br>
중요한 점은 실행 흐름이 동일한 프로세스 주소 공간을 공유하므로 프로세스간 통신이 필요하지 않다는 것이다.<br>
그리고 공유 프로세스 주소 공간에서 동일한 프로세스에 속한 명령어를 동시에 실행할 수 있다.

이렇게 하나의 프로세스 안에 여러 실행 흐름이 존재하는 것을 **스레드**라고 부른다.<br>
스레드는 코어 개수와는 무관하기 때문에 단일 코어인 상황에서도 스레드 여러 개를 생성할 수 있다. 이 덕분에 처리 시간이 긴 이벤트를 위한 별도의 스레드를 생성하는 방식으로 프로그래밍을 할 수 있다.<br>
하지만 다중 스레드가 공유 리소스에 접근할 때 상호 배제와 동기화 문제를 해결해야 한다.

함수가 실행될 때 필요한 매개변수, 지역변수, 반환 주소 등의 정보는 스택 프레임에 저장된다.<br>
스레드를 사용하게 되면서 하나의 프로세스에 실행 진입점과 실행 흐름이 여러 개 존재할 수 있게 되었다.<br>
이에 따라 프로세스에 주소 공간에 스레드의 실행 흐름을 저장하기 위한 스택 영역이 여러 개 추가되었다.

스레드 활용은 수명 주기 관점에서 볼 때, 긴 작업과 짧은 작업 두 가지 유형이 있다.<br>
**긴 작업**을 디스크에 데이터를 작성하는 행위 등이 있으며, 이를 처리하기 위해서는 전용 스레드를 생성하는 것이 가장 적합하다.<br>
**짧은 작업**은 네트워크 요청, 데이터베이스 쿼리 등 처리 시간이 매우 짧은 작업이다.<br>
짧은 작업은 작업 처리에 필요한 시간이 짧지만, 작업 수가 매우 많기 때문에 요청이 들어올 때마다 해당 작업을 처리하는 요청당 스레드 방식을 사용하면 스레드의 생성과 종료에 시간이 소모되고, 스레드의 독립적인 스택 영역으로 인한 메모리 과다 소비가 발생하고, 스레드 간 전환에 따른 부담이 증가한다.

이를 해결하기 위해 스레드 여러 개를 미리 생성해 두고, 스레드가 처리할 작업이 생기면 해당 스레드에 처리를 요청하는 방법인 **스레드 풀**이 도입되었다.<br>
이 개념에서 중요한 점은 스레드를 **재사용**하는 것이고, 이를 위해 자료 구조 중 queue를 사용한다.

<br>

<img width="400" height="250" alt="image" src="images/thread_producer_consumer.png" /><br>
스레드 풀에 작업이 전달되는 과정은 다음과 같다.<br>
1. 스레드 풀의 스레드(처리할 데이터, 데이터 처리 함수)는 작업 대기열에서 블로킹 상태로 대기한다.
2. 생산자가 작업 대기열에 데이터를 기록한다.
3. 스레드 풀의 스레드가 깨어나 작업 대기열에서 처리할 스레드의 데이터를 가져온 후 데이터 처리 함수를 실행한다.<br>

작업 대기열은 여러 스레드 간에 공유되는 리소스이므로 동기화를 할 때 상호 배제 문제도 처리해야 한다.

스레드 풀의 스레드 수가 너무 적다면 CPU를 최대한 활용할 수 없으며, 너무 많은 스레드를 생성하면 시스템의 성능 저하, 메모리 과다 점유 등의 문제가 발생한다.<br>
스레드 수를 결정하는 절대 공식은 없으며, 이를 위해서는 구체적인 상황과 그에 대한 분석이 필요하다.<br>
작업을 처리할 때 필요한 리소스 관점에서 작업을 CPU 집약적인 작업과 입출력 집약적인 작업으로 구분할 수 있다.<br>
CPU 집약적인 작업은 외부 입출력에 의존할 필요 없이 처리할 수 있는 작업을 의미하며, 스레드 수와 CPU의 코어 수가 동일하다면 CPU의 리소스를 충분히 활용할 수 있다.<br>
입출력 집약적인 작업은 대부분의 시간을 입출력에 소비하는 작업의 의미한다. 성능 테스트 도구를 사용하여 입출력 대기 시간(WT)와 CPU 연산 시간(CT)를 계산하고, N개의 코어를 가졌다고 할 때 적절한 스레드 수는 `N * (1 + WT / CT)`로 계산할 수 있다.

<br>

## 2.2 스레드 간 공유되는 프로세스 리소스

사전적으로 정의하면 "프로세스는 운영 체제가 리소스를 할당하는 기본 단위고, 스레드는 스케줄링의 기본 단위이며, 프로세스 리소스는 스레드 간에 공유된다"고 할 수 있다.<br>
그렇다면 스레드 전용 리소스에는 무엇이 있을까?

<img width="400" height="250" alt="image" src="images/stack_frame.png" /><br>

상태 변화 관점에서 보면 스레드는 CPU가 진입 함수의 명령어를 실행해 만든 실행 흐름이다.<br>
각 스레드는 자신만 사용할 수 있는 스택 영역을 가지므로 스레드 여러 개가 있을 때는 여러 스택 영역이 존재하게 된다.<br>
함수 실행 시간 정보는 스택 영역을 구성하는 스택 프레임에 저장된다. 이때 스택 프레임에는 매개변수, 지역 변수와 레지스터 정보가 저장된다.<br>
이외에도 다음에 실행될 명령어 주소를 저장하는 PC 레지스터, 스레드 스택 영역에서 스택 상단 위치를 저장하는 스택 포인터 등 CPU가 기계 명령어를 실행할 때 내부 레지스터 값도 스레드 전용으로, 다른 스레드가 접근할 수 없다.<br>
스레드 전용 정보를 통틀어 스레드 상황 정보라고 한다. 또한 **전용 리소스(스택 영역)**를 제외한 나머지 영역은 모두 스레드 간에 공용되는 리소스에 해당한다.

**코드 영역**에는 컴파일한 후 생성된 실행 가능한 기계 명령어가 저장된다. 이런 기계 명령어는 실행 파일에 저장되어 있으며, 프로그램이 시작될 때 프로세스 주소 공간에 적재된다.<br>
코드 영역은 스레드 간에 공유되므로 모든 함수는 스레드에 적재하여 실행할 수 있고, 특정 함수를 특정 스레드에서만 실행되도록 하는 것은 불가능하다.<br>
코드 영역은 읽기 전용이기 때문에 프로그램이 실행되는 동안에는 어떤 스레드도 코드 영역의 내용을 변결할 수 없어 스레드 안전 문제가 발생하지 않는다.

**데이터 영역**은 전역 변수가 저장되는 곳이다.<br>
프로그램이 실행되는 동안 데이터 영역 내에 전역 변수의 인스턴스는 하나만 있기 때문에 모든 스레드는 이 전역 변수에 접근할 수 있다.

**힙 영역**은 malloc 함수와 new 예약어로 요청하는 메모리가 할당되는 영역이다.<br>
모든 스레드는 해당 변수 주소(= 포인터)만 알고 있다면 포인터가 가리키는 데이터에 접근할 수 있으므로 힙 영역은 스레드 간 공유 리소스이다.

스레드의 추상화 측면에서 바라보면 스택 영역은 스레드 전용 공간이지만 실제 구현 측면에서 바라보면 스택 영역은 엄밀하게 격리된 스레드 전용 공간은 아니다.<br>
서로 다른 스레드의 스택 영역 간 보호를 위한 작동 방식이 존재하지 않기 때문이다.<br>
따라서 하나의 스레드가 다른 스레드의 스택 프레임에서 포인터를 가져올 수 있다면 해당 스레드는 다른 스레드의 스택 영역을 직접 읽고 쓸 수 있다.<br>
다시 말해 스레드 여러 개가 하나의 프로세스에 속하는 경우에는 하나의 스레드가 다른 스레드의 스택 영역이라고 하더라도 모두 데이터를 읽고 쓸 수 있다.<br>
이러한 스레드 간 느슨한 격리 작동 방식은 문제가 발생했을 때 디버깅 도구로 원인을 찾기 어렵다.

링크는 컴파일 후 최종적으로 실행 파일을 생성하는 단계이다.<br>
정적 링크의 경우 종속된 모든 라이브러리가 실행 파일에 포함되기 때문에 프로그램을 시작할 때 추가적인 작업이 필요하지 않다.<br>
동적 링크는 실행 파일에 종속된 라이브러리의 코드와 데이터 포함되어 있지 않아 실행 중 혹은 시작할 때 링크 과정이 완료되어야 한다.<br>
링크를 위한 데이터와 코드를 스택 영역과 힙 영역 중간에 있는 여유 공간에 배치하면 프로세스 내의 모든 스레드가 동적 라이브러리의 코드와 데이터를 사용할 수 있다.<br>
이 부분은 모든 스레드가 공유하고 있으므로 프로세스 내 모든 스레드가 동적 라이브러리 코드의 데이터를 사용할 수 있다는 의미이다.<br>
프로그램이 동작 중에 열린 파일 정보도 프로세스 주소 공간에 저장되므로 스레드 간 공유 리소스에 속한다.

스레드 전용 저장소에 저장된 변수는 모든 스레드에서 접근할 수 있다.<br>
그렇지만 변수의 인스턴스는 각각의 스레드에 속하기 때문에 하나의 스레드에서 변수 값을 변경해도 다른 스레드에는 반영되지 않는다.<br>
즉, 이 변수들은 모든 스레드에서 접근할 수 있지만 해당 변수는 초기화한 후 각각의 스레드가 복사본을 가지게 되어 각각의 스레드에서 독점적으로 변수를 사용할 수 있다.

정리
- 공유 영역: 코드, 데이터, 힙, 동적 라이브러리, 파일
- 전용 영역: 스택, 레지스터, 스레드 전용 저장소(TLS)

<br>

## 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

스레드 안전을 위한 2가지 시나리오가 있다.<br>
- 전용 리소스를 사용하는 스레드는 스레드 안전을 달성할 수 있다.
- 공유 리소스를 사용하는 스레드는 다른 스레드에 영향을 주지 않도록 하는 대기 제약 조건에 맞게 공유 리소스를 사용하면 스레드 안전을 달성할 수 있다.

<br>

어떤 코드가 주어졌을 때, 그 코드가 스레드 호출 횟수와 순서에 상관없이 올바른 결과가 나오는 것을 **스레드 안전**이라고 한다.<br>
스레드 안전 문제의 핵심은 **어떤 것이 스레드 전용 리소스이고, 어떤 것이 스레드 공유 리소스인지 구분**하는 데 있다.

- 스레드 전용 리소스: 함수의 지역 변수, 스레드의 스택 영역, 스레드 전용 저장소
- 공유 리소스
    - 힙 영역: 메모리의 동적 할당에 사용되는 영역
    - 데이터 영역: 전역 변수가 저장되는 영역
    - 코드 영역: 읽기 전용

<br>

공유 리소스를 사용하는 스레드는 반드시 순서를 따라야 하며, 핵심은 공유 리소스를 사용하는 작업이 다른 스레드를 방해할 수 없다는 것이다.<br>
이를 위해 각종 잠금이나 세마포어(semaphore)와 같은 장치를 사용할 수 있다.<br>
스레드 전용 리소스인 지역 변수만 사용하는 함수는 실행된 후 스레드의 스택 영역에서 관리한다. 이런 코드를 무상태 함수라고도 하며, 스레드 안전이다.

함수 매개변수를 값으로 전달(call by value)하는 경우라면 스레드 안전이다.<br>
값으로 전달된 매개변수도 스레드 전용 리소스이며, 이 매개변수들도 스레드의 스택 영역에 저장되기 때문이다.

함수 매개변수를 포인터로 전달하면 상황이 달라진다.<br>
전달된 매개변수가 데이터 영역에 위치한 전역 변수를 가리키고 있고, 이 전역 변수는 모든 스레드가 공유하는 리소스에 해당하기 때문에 스레드 안전이 아니다.<br>
따라서 이 경우 전역 변수와 관련된 작업에 잠금과 같은 형태의 순서가 반드시 부여되어야 한다.

포인터가 힙 영역을 가리키는 경우에도 포인터를 통해 모든 스레드가 포인터가 가리키는 데이터에 접근할 수 있기 때문에 스레드 안전이 아니다.<br>
이 경우 모든 스레드가 함수를 호출할 때 해당 스레드에 속하는 리소스 주소를 전달하는 것으로 해결할 수 있다.<br>
이처럼 스레드 안전인 코드를 작성하는 원칙 중 하나는 **스레드 간에 공유 리소스를 사용하지 않도록 가능한 한 모든 조치를 취하는 것**이다.

사용되는 전역 변수가 처음 프로그램이 실행될 때 한 번 초기화되고 나서 모든 코드가 이 변수를 읽는다면 스레드 안전 코드가 된다.<br>
전역 변수의 변경 과정은 반드시 잠금 등의 보호 또는 덧셈 작업을 원자성 작업으로 설정해서 보호해야 한다.<br>
여기서 원자성 작업이란 여러 단계로 나뉘어 보일 수 있는 작업을 CPU·메모리 관점에서 하나의 분할 불가능한 동작처럼 수행하는 것이다.<br>
전역 변수 앞에 ```__thread```를 붙이면 스레드 전용 저장소에 배치되므로 스레드 안전으로 만들 수 있다.(2.2.7 참고)

함수가 값을 반환할 때는 함수가 값을 반환하는 경우와 함수가 포인터를 반환하는 경우로 나눌 수 있다.<br>
함수가 값을 반환하는 경우에는 스레드 안전이다.<br>
하지만 변수의 주소(포인터)를 반환하면 잠재적으로 스레드 공유 리소스가 되어 해당 주소를 획득할 수 있는 모든 스레드가 해당 변수를 수정할 수 있게 되고, 스레드 안전이 아니다.<br>
클래스 내부에서만 생성자를 호출해 인스턴스를 생성한다면 생성자가 함수 안의 static 지역 변수가 되므로 스레드 안전이라고 할 수 있다.

스레드 안전이 아닌 코드는 함수를 호출하기 전에 잠금으로 보호하여 스레드 안전으로 만들 수 있다.<br>
잠금으로 전역 변수를 간접적으로 보호하기 때문이다.<br>
또한 매개변수로 전달된 포인터가 저역 변수를 가리키는지 알 수 없을 때 스레드 안전이 아니다.<br>
이때 ```int b = func(&a);```처럼 전달된 매개변수를 스레드 전용 리소스인 지역 변수로 만들면 스레드 안전으로 만들 수 있다.

공유 리소스가 어느 영역에 저장되어 있든 관계없이 다중 스레드 프로그래밍 중에는 어떤 리소스라도 최대한 공유하지 않는 것이 원칙이다.<br>
처리해야 할 작업이 스레드 사이에서 리소스를 공유해야 한다면 반드시 코드의 스레드 안전에 주의를 기울여야 한다.<br>
스레드 안전을 달성하려면 **무엇이 스레드 전용 리소스와 스레드 공유 리소스인지 분류**하는 것이 중요하다.

- 스레드 전용 저장소: 전역 리소스를 사용해야 하는 경우 스레드 전용 저장소로 선언 가능한지 확인해본다.
- 읽기 전용: 전역 리소스를 사용해야 한다면 해당 전역 리소스를 읽기 전용으로 사용 가능한지 확인해본다.
- 원자성 연산: 도중에 중단되지 않는 원자성 연산을 이용한다.
- 동기화 시 상호 배제: 한 번에 하나의 스레드만 공유 리소스에 접근할 수 있도록 뮤텍스, 스핀 잠금, 세마포어 등의 방식을 사용한다.

<br>

지금까지의 스레드는 기본적으로 커널 스레드이므로, 스레드의 관리를 운영 체제가 수행한다.<br>
운영 체제에 의존하지 않는 상황에서 직접 스레드를 구현하기 위해서 **코루틴**을 사용할 수 있다.

<br>

## 2.4 프로그래머는 코루틴을 어떻게 이해해야 할까?

일반 함수는 return 명령어를 만나거나 코드의 마지막 줄까지 실행되어야 반환이 가능하다. 또한 해당 함수가 재호출되면 다시 처음부터 시작하여 반환될 때까지 모든 줄을 하나씩 실행한다.<br>
일반 함수와 코루팀에 형식적인 차이는 없으나 코루틴에는 일시 중지와 재개 기능이 있다.<br>
코루틴은 자신의 실행 상태를 저장할 수 있기 때문에 코루틴이 반환된 후에도 계속 호출이 가능하며, 마지막으로 일시 중지된 지점에서 다시 이어서 실행된다.<br>
일반 함수가 `return` 명령어를 사용한 뒤 코드를 실행할 방법이 없는 것과 대비된다.<br>
코루틴 코드에서 코루틴 획득은 `co = func()`로, 호출은 `next(co)`로, 정지는 `yield`로 할 수 있다.

<br>

<img width="400" height="250" alt="image" src="images/coroutine.png" /><br>

코루틴이 일반 함수와 다른 점은 **자신이 이전에 마지막으로 실행된 위치를 알 수 있다**는 것이다. 이는 운영체제가 스레드를 스케줄링 하는 것과 동일하다.<br>
유의할 점은 코루틴은 온전히 사용자 상태 내에서 구현된 것이기 때문에 운영체제는 코루틴 생성에 대한 정보를 알지 못한다는 것이다.<br>
따라서 코루틴은 하나의 스레드 위에서 여러 실행 흐름을 사용자 코드가 직접 교대 실행하는 **사용자 상태 스레드**로 해석할 수 있다.

코루틴 개념은 1958년에 등장했는데, 이 시기에는 아직 스레드가 없었기 때문에 동시성을 가지는 프로그램을 작성하려면 코루틴과 같은 기술을 사용할 수밖에 없었다.<br>
이후 스레드가 등장하고 운영체제가 기본적으로 프로그램의 동시 실행을 지원하면서 코루틴은 잊혀져갔다.<br>
인터넷이 발달하며 서버에서 처리해야 하는 사용자 요청이 기하급수적으로 늘어나며 코루틴은 높은 성능과 동시성을 요구하는 분야에서 다시 사용되게 되었다.

코루틴의 구현은 스레드의 구현과 본질적으로 차이가 없다.<br>
코루틴은 일시 중지되거나 다시 시작될 수 있으며, 일시 중지될 대의 상태 정보를 반드시 기록해야 이를 기반으로 코루틴을 다시 시작해야 한다.<br>
상태 정보에는 CPU의 레지스터 정보, 함수 실행 시 상태 정보가 포함되며 주로 함수의 스택 프레임에 저장된다.<br>
코루틴의 스택 프레임 정보는 힙 영역에 배치된다.

스레드는 운영체제가 관리하는 실행 단위로, 커널 스케줄링의 대상이다. 따라서 생성 및 관리 주체가 운영체제이며, 선점형으로 실행되고 언제든지 OS가 강제로 중단하고 인터럽트가 발생할 수 있기 때문에 락, 원자성, 메모리 모델 등으로 데이터 손상을 막아야 한다.<br>
코루틴은 사용자 공간에서 라이브러리/런타임이 관리하는 실행 단위이다. await이나 yield가 명시적으로 작성되었을 때만 중단되며, 스스로 양보하지 않으면 계속 실행된다.

프로그래머는 동기 방식으로 순차적으로 코드를 작성한다. 하지만 코루틴은 await으로 지금 실행을 잠시 중단하고 스레드 내에서 다른 코루틴을 실행할 수 있다.<br>
따라서 코루틴은 프로그래머가 동기 방식으로 비동기 프로그래밍을 가능하게 한다.

<br>