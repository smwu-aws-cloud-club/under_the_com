# 2.7 아 맞다! 블로킹과 논블로킹도 있다.

동기 또는 비동기를 이야기할 때 항상 두 가지 대상을 언급한다.<br>
작업 A가 작업 B에 의존하는 관계가 존재할 때 A와 B는 동기이며, 강하게 결합된 것이다.<br>
작업 A와 B가 강한 결합과 같은 제약이 없어 각자 자신의 작업을 실행할 수 있을 때 A와 B는 비동기이다.<br>

## 2.7.1 블로킹과 논블로킹

함수 A가 함수 B를 호출할 때, 함수 B를 호출함과 동시에 운영체제가 함수 A가 실행 중인 스레드나 프로세스를 일시 중지시킨다면 함수 B에 대한 호출 방식은 **블로킹 방식**이며, 그렇지 않다면 **논블로킹 방식**이다.<br>
블로킹 호출 핵심은 스레드 또는 프로세스가 일시 중지되는 것이다.<br>

## 2.7.2 블로킹의 핵심 문제: 입출력

일반적으로 블로킹은 대부분 입출력과 관련이 있다. 입출력을 처리하는 데 시간이 오래 걸리기 때문이다.<br>
입출력 작업을 진행하는 동안 CPU 제어권을 다른 스레드에 넘겨 다른 작업을 할 수 있도록 하고, 입출력 작업이 완료되면 다시 CPU 제어권을 우리 스레드 또는 프로세스에서 넘겨받아 계속 다음 작업을 실행할 수 있도록 한다.<br>
CPU 제어권을 상실했다가 되찾는 시간 동안 스레드나 프로세스는 블로킹되어 일시 중지된다.<br>
블로킹 입출력 방식을 사용하면 운영 체제가 CPU의 리소스를 최대한 활용할 수 있다.<br>

## 2.7.3 논블로킹과 비동기 입출력

호출 스레드가 일시 중지되지 않으면서 입출력 작업을 시작하는 것을 **논블로킹**이라고 하며, 이런 유형의 입출력 작업을 **비동기 입출력**이라고 한다.<br>
네트워크 데이터 수신을 예로 들어보자면, 데이터를 수신하는 함수인 ```recv```가 논블로킹이면 이 함수를 호출할 때 운영체제는 스레드를 일시 중지시키는 대신 ```recv``` 함수를 즉시 반환한다. 이후 호출 스레드는 자신의 작업을 계속 진행하며, 데이터 수신 작업은 커널이 처리한다. 따라서 2가지 작업이 비동기적으로 처리된다.<br><br>

논블로킹 방식에서 데이터 수신을 확인하는 방법은 다음과 같다.
1. 요청 전달 시 결과를 확인하는 폴링 함수를 함께 제공하고, 폴링 함수를 호출해 수신된 데이터가 있는지 확인
2. 데이터가 수신되면 스레드에 메시지나 신호 등을 전송하는 알림 작동 방식
3. ```recv``` 함수를 호출할 때, 데이터 수신 처리를 담당하는 함수를 콜백 함수에 담아 매개변수를 전달<br>

## 2.7.4 피자 주문에 비유

- 블로킹 호출: 피자 가게에 직접 가서 피자를 주문
- 논블로킹 호출: 전화로 피자를 주문
    - 배달이 도착해 전화가 오기 전까지 할 일을 하고 있음 - 알림 작동 방식
    - 5분마다 전화를 걸어서 피자 완성 여부를 물어봄 - 폴링 함수 호출
    - 논블로깅 ≠ 비동기

## 2.7.5 동기와 블로킹

동기 호출은 반드시 블로킹이 아닌 반면, 블로킹 호출은 모두 확실한 동기 호출이다.<br>

## 2.7.6 비동기와 논블로킹

네트워크 데이터 수신을 예로 들어보자.
- ```recv```: 데이터 수신 함수
- ```handler```: 네트워크 데이터 처리 함수
- ```NON_BLOCKING_FLAG```: ```recv`` 함수를 논블로킹 호출로 설정하기 위한 flag<br>

이떼 ```handler``` 함수를 ```recv``` 함수에 콜백으로 전달하는 경우에는 **비동기이자 논블로킹**이다.<br>
그러나 시스템이 네트워크 데이터의 도착을 감지하는 전용 함수인 ```check``` 함수를 이용해 끊임없이 감지를 시도하여 데이터가 도착하기 전까지 ```handler``` 함수를 사용할 수 없는 경우에는 **동기이자 논블로킹**이다.<br>
논블로킹이더라도 전체적으로 반드시 비동기는 앙니며, 코드 구현 방식에 따라 달라진다.<br>

## 전체 정리

![동기화와 블로킹 총정리](https://blog.kakaocdn.net/dn/bhKwtf/btsCRhQ0yQR/bsAykF0xBP7uo4685FcgKk/img.png)<br>