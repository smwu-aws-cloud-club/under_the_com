# 5. 작은 것으로 큰 성과 이루기, 캐시

## 5.1 캐시, 어디에나 존재하는 것

일반적인 시스템에서 메모리의 속도는 CPU의 100분의 1에 불과하다.<br>
CPU와 메모리 사이의 불일치 문제를 해결하기 위해 캐시 계층을 추가한다.<br>
캐시 안에는 최근에 메모리에서 얻은 데이터가 저장되며, CPU는 메모리에서 명령어와 데이터를 꺼내야 할 때도 무조건 먼저 캐시에서 해당 내용을 찾는다.<br>
캐시가 적중하면 메모리에 접근할 필요가 없어 CPU가 명령어를 실행하는 속도를 크게 끌어올리는 목적을 달성할 수 있고, CPU와 메모리 사이의 속도 차이를 보완할 수 있다.

CPU와 메모리 사이에는 L1, L2, L3 세 단계의 캐시가 추가되어 있다.<br>
L1 캐시, L2 캐시, L3 캐시, CPU 코어는 레지스터 칩 내에 묶여 패키징되어 있다.<br>
CPU는 메모리에 접근할 필요가 있을 때 L1 캐시 → L2 캐시 → L3 캐시 → 메모리 순서로 접근한다.

캐시가 있기 때문에 메모리는 더 이상 메모리에 접근하지 않으며, CPU는 캐시에 직접 기록한다.<br>
이때 캐시의 데이터는 갱신되었지만 메모리의 데이터는 예전 데이터가 남아 있는 **불일치** 문제가 발생할 수 있다.<br>
이 문제를 해결하는 가장 간단한 방법은 캐시를 갱신할 때 메모리도 함께 갱신하는 **연속 기입** 방법이다.<br>
이 방식으로 캐시를 업데이트하면 CPU는 메모리가 갱신될 때까지 대기하고 있어야 하는 동기실 설계 방법에 해당한다.<br>
CPU가 메모리에 기록할 때는 캐시를 직접 갱신하지만, 메모리 갱신 완료를 기다릴 필요 없이 CPU는 다음 명령어를 실행할 수 있다.<br>
캐시 용량에 한계가 있어 용량이 부족하면 자주 사용되지 않는 데이터를 제거하는데, 이때 캐시에서 제거된 데이터가 수정된 적이 있다면 메모리에 갱신하는 비동기 방식의 **후기입** 방법을 사용할 수 있다. 이 방법은 연속 기입보다 훨씬 복잡하지만 성능은 더 낫다.

CPU는 다중 코어 시대에 진입했다. 다중 코어를 최대한 활용하는 다중 스레드 또는 다중 프로세스가 없다면 다중 코어의 위력을 충분히 활용할 수 없다.<br>
CPU가 코어 여러 개를 가지고 있다면 각 코어에서는 다른 스레드가 실행된다. 이 스레드들이 모두 메모리 내 변수 X에 접근하고 이 내용은 캐시에 저장된다.<br>
CPU는 각각 캐시를 갖기 때문에 메모리의 X 변수에 대해 각 캐시에 복사본을 가지고 있다. 이때 캐시에 저장된 변수에 대해 캐시들이 연결되어 있지 않으므로 값의 불일치 문제가 발생할 수 있다.<br>
이 문제를 해결하기 위해 캐시 한 개에서 갱신된 변수가 다른 CPU 코어의 캐시에도 함께 갱신되어야 하므로 다중 코어 캐시의 일관성을 유지하면 성능 문제가 발생한다.

파일을 읽을 때 먼저 데이터를 디스크에서 메모리로 옮겨야 CPU가 메모리에서 파일의 데이터를 읽을 수 있다.<br>
메모리와 디스크의 속도 차이를 해결하기 위해 메모리를 디스크의 캐시로 사용할 수 있다.<br>
컴퓨터 시스템의 여유 메모리 공간을 디스크의 캐시로 활용하여 디스크에서 데이터를 읽어 오는 일을 최소화한다.<br>
이것은 리눅스 운영 체제에서 페이지 캐시의 기본 원리에 해당한다.<br>
최근 메모리가 점점 저렴해지면서 RAM과 같은 메모리가 디스크를 대체하는 추세이다. Spark를 사용하는 등 일부 상황에서는 데이터베이스를 전부 메모리에 직접 설치하여 디스크 입출력이 필요 없는 경우도 있다.<br>
하지만 메모리는 데이터를 영구적으로 저장할 수 있는 기능이 없기 때문에 메모리가 디스크를 완전히 대체할 수는 없다.

프로세스 주소 공간의 데이터는 디스크로 대체될 수 있으므로 프로그램이 디스크 입출력을 포함하고 있지 않더라도 메모리 사용률이 매우 높을 경우에는 CPU가 디스크에 접근해야 할 수 있다.

CPU가 메모리를 사용할 때 실행하는 읽기와 쓰기 명령어가 사용하는 것은 가상 메모리 주소이므로 이 주소를 실제 물리 메모리 주소로 변환해야 한다.<br>
변환이 완료되면 캐시를 검색해 캐시에서 데이터를 찾는다면 직접 반환하며, 찾을 수 없을 때는 메모리에 접근한다.<br>
가상 메모리의 존재로 프로세스의 데이터는 디스크에 임시로 보관되어 있을 수 있는데, 해당 데이터를 메모리에서도 찾을 수 없다면 디스크의 프로세스 데이터를 다시 메모리에 적재한 후 메모리를 읽어야 한다. 

대용량의 데이터 저장 문제를 해결하기 위해 여러 대의 저장 장치를 사용하는 것을 분산 파일 시스템이라고 한다.<br>
사용자 장치는 분산 파일 시스템을 직접 장착(mount)할 수 있고, 로컬 디스크는 원격의 분산 파일 시스템에서 전송된 파일을 저장한다.<br>
분산 파일 시스템은 네트워크를 통하지 않고 로컬 디스크에 직접 접근하므로 로컬 디스크를 원격 분산 파일 시스템의 캐시로 간주할 수 있다.<br>
응답 속도를 더 높이기 위해 원격 분산 파일 시스템의 데이터를 data stream 형태로 직접 로컬 컴퓨터 시스템의 메모리로 끌어올 수도 있다.<br>
메시지 미들웨어인 apache kafka 시스템의 경우 대용량 메시지는 원격 분산 파일 시스템에 저장되어 있지만 실시간으로 해당 데이터의 소비자에게 전달하는데, 이 경우 메모리를 원격 분산 파일 시스템의 캐시로 간주할 수 있다.

![최신 컴퓨터 시스템의 저장 체계](/esc/CH5/images/cs_storage_system.png)<br>
컴퓨터 저장 체계의 각 계층이 다음 계층에 대한 캐시 역할을 한다.<br>
각 계층의 저장 용량은 반드시 다음 계층보다 작아야 한다.<br>
이에 근거하여 전체 저장 체계가 최대 성능을 발휘하려면 프로그램이 매우 캐시 친화적이어야 한다.
