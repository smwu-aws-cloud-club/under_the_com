## 4.1 이 작은 장난감을 CPU라고 부른다. 
### 4.1.1 위대한 발명
트랜지스터
- 단자 한 쪽에 전류를 

### 4.1.2 논리곱, 논리합, 논리부정
트랜지스터(스위치) 로 만들 수 있는 세 가지 회로
1. 스위치 두 개가 동시에 켜질 때만 전류가 흐르고 등이 켜짐 -> 논리곱
2. 두 스위치 중 하나라도 켜져 있으면 전류가 흐를 수 있고, 등이 켜짐 -> 논리합
3. 스위치를 닫으면 전류가 흐르고, 등이 켜짐 + 스위치를 열면 전류가 흐르지 않고 등이 꺼짐 -> 논리부정
<br>

논리곱, 논리합, 논리부정을 통해 모든 논리 함수를 표현할 수 있다. 
-> **논리적 완전성**

### 4.1.4 연산 능력은 어디에서 나올까?
CPU는 0과 1만 알고 있다. CPU에서 덧셈을 처리할 때 2진법으로 처리되고, 2진법의 덧셈은 논리곱 게이트 + 배타 논리합 게이트로 표현할 수 있다.
- 자리 올림수 -> 논리곱 게이트
- 결과 -> 배타 논리합 게이트
  
다른 연산도 위와 같이 논리곱, 논리합, 논리 부정 게이트를 조합해 구현할 수 있다. 

### 4.1.5 신기한 기억 능력
연산까지는 완료! 이 연산 결과는 어떻게 저장해야 할까?
- 부정 논리곱 게이트 두 개를 조합하면 저장 회로를 만들 수 있다!
    **부정 논리곱**
    - 논리곱의 결과를 뒤집은 게이트
- 두 논리곱 게이트는 서로의 출력이 입력으로 연결되어 있다.
- 외부에서 두 개의 입력 S, Q를 받는다.
- S는 단자 a를 1로 만드는 역할, R은 단자 a를 0으로 만드는 역할
- a와 b는 항상 서로 반대값 
  
1번 부정 논리곱의 입력 : S와 b
2번 부정 논리곱의 입력 : R과 a

- 이런 회로는 1비트를 저장할 수 있다.

### 4.1.6 레지스터와 메모리의 탄생
위에서 만든 회로를 복제해 붙여 넣기만 하면 더 많은 비트를 저장할 수 있다.
- 이렇게 조합한 회로가 레지스터가 된다.
- 더 많은 정보를 저장할 수 있는 메모리도 이렇게 탄생했다.
- 전원이 끊기면 저장된 정보는 모두 사라진다. -> 휘발성

### 4.1.7 하드웨어 아니면 소프트웨어? 범용 장치
회로는 하드웨어지만, 모든 연산 논리를 하드웨어로 구현하는 것은 비효율적이다.
- 하드웨어는 가장 기본적인 기능만 제공하고, 모든 연산 논리는 소프트웨어로 표현하자.
- 서로 다른 소프트웨어가 설치된 하드웨어는 서로 다른 기능을 가질 수 있다. 

### 4.1.8 하드웨어의 기본 기술 : 기계 명령
CPU에게 덧셈 연산을 해야 한다는 것을 알려주려면?
- 기계 명령어로 직접 알려줘야 한다. 
- 이 기계 명령어는 이전에 다룬 조합 회로를 이용해 실행된다. 

### 4.1.9 소프트웨어와 하드웨어 간 인터페이스 : 명령어 집합
명령어 집합
- CPU가 실행할 수 있는 명령어 (opcode) + 각 명령어에 필요한 피연산자 (operand)
- 시스템 계층 관점에서, 소프트웨어와 하드웨어가 만나는 곳
  
### 4.1.10 회로에는 지휘자가 필요하다
회로는 데이터를 계산하고 저장하는 여러 부분으로 구성된다. 
- 각 부분의 회로를 전체적으로 관리하는 역할 -> **클럭 신호**

**클럭 신호**
- 이 신호가 전압을 변경할 때마다 전체 회로 상태가 갱신된다.

**클럭 주파수**
- CPU의 클럭 주파수는 1초 동안 몇번 회로 상태를 갱신하는지 나타낸다.
- 클럭 주파수가 높을 수록 CPU는 1초에 더 많은 작업을 할 수 있다.

### 4.1.11 큰일을 해냈다, CPU가 탄생했다!
- 산술 논리 장치 : 각종 계산 가능
- 레지스터 : 정보를 저장
- 클럭 신호 : 여러 회로가 작업을 함께 할 수 있도록 제어

이 모든 것을 묶은 것이 바로 CPU (또는 프로세서)