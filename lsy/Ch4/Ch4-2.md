## 4.2 CPU는 유휴 상태일 때 무엇을 할까?

### 4.2.1 컴퓨터의 CPU 사용량은 얼마인가?
대부분의 CPU 사용률은 7-8%

### 4.2.2 프로세스 관리와 스케줄링
작업 관리자 > 세부정보 탭을 확인해보면 `System Idle Process` 라는 프로세스가 90% 이상의 CPU 사용률을 보인다.

**리마인드!**
프로그램이 실행될 때..
- 프로그램이 메모리에서 실행되면 프로세스 형태로 존재한다.
- 이 프로세스는 운영체제에서 관리, 스케줄링한다.
- 운영체제는 프로세스에 우선순위를 할당한다.
- 대기열에 프로세스를 넣으면 스케줄러가 우선순위에 따라 스케줄링을 진행한다.

### 4.2.3 대기열 상태 확인 : 더 나은 설계
대기열에 프로세스가 하나도 없다면?
- 운영체제가 스케줄링할 프로세스 X
- CPU 유휴 상태

실행해야 할 프로세스가 없을 때 무언가를 하도록 하고 싶다면?
1. if문으로 대기열에 프로세스가 없을 경우, 원하는 동작을 하도록 구현한다.
2. 프로세스가 없을 때 할 동작을 프로세스로 만들어 대기열에 항상 존재하도록 한다.
    - 1번에서 발생할 수 있는 코드 오류 가능성을 줄이고 구조를 깔끔하게 유지하는 방법
    - 이 유휴 작업 프로세스가 바로 `System Idle Process`

### 4.2.4 모든 것은 프로세스로 돌아온다
어쨌든 컴퓨터 시스템의 모든 것은 최종적으로 CPU를 통해 동작한다.

- 시스템에 유휴 상태가 있을 때를 고려한 기계 명령어 : `halt`
  - CPU 내부의 일부 모듈을 절전 상태로 전환
  - 특권 명령어이므로 커널 상태에서 CPU로만 실행 가능
  - CPU 낭비를 줄이기 위해 이 명령어도 순환에 배치

### 4.2.5 유휴 프로세스와 CPU의 저전력 상태
스케줄링 가능한 프로세스가 존재하지 않으면, 
- 유휴 프로세스가 실행되고 이때 순환 구조 안에서 계속 halt 명령어가 실행된다.
- halt 명령어를 통해 CPU는 저전력 상태로 진입한다.

### 4.2.6 무한 순환 탈출 : 인터럽트
앞서 halt 명령어는 순환 구조 안에서 실행된다는 것을 확인했는데, 이 순환 구조 내부에는 break, return문처럼 순환을 빠져나올 수 있는 코드가 없다. 그럼 어떻게 다른 프로세스를 스케줄링할 수 있을까? 

-> **운영체제의 타이머 인터럽트**

- 운영체제는 일정 시간마다 타이머 인터럽트를 생성한다. 
- CPU에서는 인터럽트를 감지하고, 운영체제 내부의 인터럽트 처리 프로그램을 실행한다. 
- 인터럽트 처리 함수에서는 시스템에 준비가 완료된 프로세스가 있는지 확인한다.
- 준비 완료 프로세스가 있다면 유휴 프로세스를 일시 중지 시키고 해당 프로세스를 스케줄링한다.
- 프로세스가 없다면 유휴 프로세스를 계속 실행한다.

