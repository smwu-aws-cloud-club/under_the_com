## 4.3 CPU는 숫자를 어떻게 인식할까?
컴퓨터 시스템이 2진법인 이유
- 컴퓨터 저수준 계층이 트랜지스터로 구성되어 있기 때문이다.
  - 트랜지스터 : on/off

### 4.3.1 숫자 0과 양의 정수
비트 k개를 사용하면 부호 없는 양의 정수 2^k개를 나타낼 수 있다.
- `0 ~ 2^k - 1`

### 4.3.2 부호 있는 정수
부호 있는 정수의 경우 2^k개 중 절반은 양의 정수, 나머지 절반은 음의 정수를 나타내는 데 사용된다.
- **최상위 비트로 부호를 나타낸다.**
  - 0이면 양수, 1이면 음수


### 4.3.3 양수에 음수 기호를 붙이면 바로 대응하는 음수 : 부호-크기 표현
**부호-크기 표현** : 첫 번째 비트로 부호를 표현하고, 나머지 비트로 숫자를 표현한다.
- 0010 (2진수) = 2 (10진수)
- 1010 (2진수) = -2 (10진수)

그렇다면 2진수로 1000은? -> -0? 0에는 부호가 없는데... 

### 4.3.4 부호-크기 표현의 반전 : 1의 보수
**1의 보수** : 음수는 양수 표현과 완전히 반대로 해보자! 
- 0010 = 2
- 1101 = -2 

하지만 여기서도 -0 문제는 발생한다. 

### 4.3.5 간단하지 않은 두 수 더하기
A + (-A) = 0 을 만족하는 표현 방식을 찾아야 한다!

**1. 부호-크기 표현** 
- `0010 + 1010 = 1100`
- 결과 : 4 (모순!)

**2. 1의 보수**
- `0010 + 1101 = 1111`
- 결과 : -0

### 4.3.6 컴퓨터 친화적 표현 방식 : 2의 보수
양수 2 = 0010
- 최상위 비트가 1이면서, 0010과 더해서 0000이 나오는 값이 무엇일까?
-> `1110` 
- 위와 같은 원리로 다른 음수를 표현할 수 있다. -> 2의 보수

![image](https://blog.kakaocdn.net/dn/bcFlUE/btsznDJgjgM/vFjB7erk1YeP4QS3E6NEP0/img.jpg)

- 2의 보수를 사용하면, 가산기가 계산을 수행할 때 부호에 신경쓸 필요가 없다. 

### 4.3.7 CPU는 정말 숫자를 알 수 있을까?
CPU는 인간 개념을 이해하지 못한다.
- CPU는 근본적으로 어떤 프로그래밍 언어도 이해하지 못한다. 프로그래밍 언어를 이해하는 것은 컴파일러의 역할
- CPU는 자신의 입력과 출력을 전혀 이해하지 못한다. 값을 해석하는 것은 소프트웨어의 역할
