## 2.7 아 맞다! 블로킹과 논블로킹도 있다
### 2.7.1 블로킹과 논블로킹
프로그래밍에서 함수를 호출할 때 주로 사용 
- 함수 A가 함수 B를 호출할 때, 실행 중인 스레드나 프로세스가 **운영체제에 의해** 일시 중지 된다면..
  - **함수 B를 호출하는 방식은 블로킹 방식** 
  - 일시 중지되지 않는다면 **논블로킹 방식**

### 2.7.2 블로킹의 핵심 문제 : 입출력
블로킹은 대부분 입출력과 관련
- 디스크에서 하나의 입출력 요청을 처리하는 데 걸리는 시간 = CPU에서 대량의 기계 명령어를 실행하는 시간 -> **디스크는 느리고, CPU는 빠르다.** 
- 입출력 작업은 시간이 오래 걸리기 때문에, 입출력 작업이 실행되면 호출 스레드는 블로킹되어 일시중지되고, 운영체제는 다른 스레드를 CPU에 할당한다. 
- 입출력이 끝나면, 운영체제는 다시 호출 스레드를 CPU에 할당한다. 
> 호출 스레드가 중지되지 않고, 입출력작업을 시작하려면? -> **논블로킹 호출 사용** 

### 2.7.3 논블로킹과 비동기 입출력
논블로킹 호출을 사용하면, 운영체제는 스레드를 일시 중지시키지 않고 함수를 즉시 반환한다. 이때 호출 스레드는 자신의 할 일을 계속 진행할 수 있다.
> 예시) 네트워크 데이터 수신 
> - 데이터를 수신하는 함수 <code>recv</code>가 논블로킹이라면?
> - <code>recv</code>를 호출할 때 운영체제는 <code>recv</code> 함수를 즉시 반환
> - <code>recv</code>호출 스레드는 자신의 작업을 계속 진행, 데이터 수신 작업은 커널이 처리 
> <br>
> <br>
>**함수 실행이 언제 완료되었는지 확인하려면?**
>  1. 결과를 확인하는 함수를 <code>recv</code>와 함께 제공해, 해당 함수를 호출하는 방식으로 수신된 데이터를 확인한다. 
>     - 이때 결과를 확인하는 함수는 호출 스레드 쪽에 존재하는 건지..? 
>  2. 데이터가 수신되면 호출 스레드에 알림을 보낸다.
>  3. <code>recv</code>를 호출할 때 수신 처리를 담당하는 함수를 콜백 함수로 전달한다.

### 2.7.4 피자 주문에 비유하기
**블로킹**
- 매장에서 피자를 주문하고, 완성될 때까지 기다린다.

**논블로킹**
- 전화로 피자를 주문하고, 내 할 일을 한다. 
- 피자가 완성되었는지 확인하는 방법
  - 피자가 올 때까지 인내심 있게 기다린다. -> **비동기**
  - 피자가 올 때까지 아무것도 하지 않고, 5분에 한 번씩 전화를 걸어 확인한다. -> **동기**

> **비동기와 논블로킹은 같은 개념이 아니다!**
- 잘 안 와닿는다... 

### 2.7.5 동기와 블로킹
동기 호출은 블로킹이 아닐 수 있지만, 블로킹 호출은 반드시 동기 호출이다!

### 2.7.6 비동기와 논블로킹
<code>2.7.3</code>절의 예시
> 예시) 네트워크 데이터 수신
> - 데이터를 수신하는 함수 <code>recv</code>가 논블로킹이라면?
> - <code>recv</code>를 호출할 때 운영체제는 <code>recv</code> 함수를 즉시 반환
> - <code>recv</code>호출 스레드는 자신의 작업을 계속 진행, 데이터 수신 작업은 커널이 처리
> <br>
> <br>
>**함수 실행이 언제 완료되었는지 확인하려면?**
>   1. 결과를 확인하는 함수를 <code>recv</code>와 함께 제공해, 해당 함수를 호출하는 방식으로 수신된 데이터를 확인한다.
   >      - 이때 결과를 확인하는 함수는 호출 스레드 쪽에 존재하는 건지..?
>   2. 데이터가 수신되면 호출 스레드에 알림을 보낸다.
>   3. <code>recv</code>를 호출할 때 수신 처리를 담당하는 함수를 콜백 함수로 전달한다.


**함수 실행을 확인하는 방법 -> 세 번째 방법** 

```c
void handler(void *buf)
{
  ...
}

while(true)
{
  fd = accept();
  recv(fd, buf, NON_BLOCKING_FLAG, handler); // 논블로킹 -> 호출 후 바로 반환
}
```
- <code>handler</code>데이터 처리 함수를 콜백함수로 넘겨준다. 

---

```c
void handler(void *buf)
{
  ...
}

while(true)
{
  fd = accept();
  recv(fd, buf, NON_BLOCKING_FLAG, handler); // 논블로킹 -> 호출 후 바로 반환
  
  while (!check(fd))
  {
    // 순환 감지
    ;
  }
  
  handler(buf);
}
```
- 위처럼 네트워크 데이터 수신 여부를 확인하는<code>check</code> 함수를 사용한다면... 
- 데이터 도착 전까지는 handler 함수를 실행할 수 없다. -> **동기** 
  - 5분에 한 번씩 전화로 확인하는 상황과 동일

> **즉, 동기이면서 논블로킹일 수 있다!**