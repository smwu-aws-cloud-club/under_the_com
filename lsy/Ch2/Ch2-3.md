## 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?
### 2.3.1 자유와 제약
- 스레드가 자신만의 전용 리소스를 사용한다면? -> **스레드 안전** 
- 공유 리소스를 사용하는 스레드라면? 다른 스레드에 영향을 주지 않도록 하는 대기 제약 조건에 맞게 공유 리소스 사용 -> **스레드 안전**

### 2.3.2 스레드 안전이란 무엇일까?
- **스레드 안전** : 어떤 코드가 스레드 몇 개에서 호출되든, 어떤 순서로 호출되든 상관없이 올바른 결과가 나오는 것 
- 스레드에 안전한 코드를 작성하려면..
  - 스레드의 전용 리소스와 공유 리소스를 파악해야 한다.

### 2.3.3 스레드 전용 리소스와 공유 리소스
> **스레드 전용 리소스** : 함수 지역 변수, 스레드 스택 영역, 스레드 전용 저장소
> 
> **공유 리소스** : 힙 영역, 데이터 영역, 코드 영역

- 공유 리소스를 사용하는 스레드는 반드시 **순서**를 따라야 한다.

### 2.3.4 스레드 전용 리소스만 사용하기 
```
int func()
{
    int a = 1; 
    int b = 1;
    return a + b;
}
```
- 지역 변수(스레드 전용 리소스)만 사용하기 때문에 스레드 안전한 코드


### 2.3.5 스레드 전용 리소스와 함수 매개변수
```
int func(int num)
{
    num++;
    return num;
}
```
- call by value -> 스레드 안전

```
int func(int* num)
{
    ++(*num);
    return *num;
}
```
- 위처럼 포인터가 매개변수인 상황에서, 전역 변수의 포인터가 매개변수로 전달된다면.. -> **스레드 안전 X**
  - 해당 전역변수는 모든 스레드가 공유하는 리소스이기 때문
- 포인터가 해당 리소스 전용 리소스를 가리키는 경우에는 스레드 안전 

### 2.3.6 전역 변수 사용
반드시 전역 변수를 사용해야 하는 경우라면? 
- 전역 변수를 읽기만 한다면 스레드 안전
- 변경 작업이 필요하다면, 작업을 (원자성 작업)으로 설정해 보호 필요!!

### 2.3.7 스레드 전용 저장소
- 스레드 전용 저장소에 배치되는 변수를 사용하는 경우 스레드 안전 (__thread 수식어)

### 2.3.8 함수 반환값
- return by value 인 경우 -> 스레드 안전
- 포인터를 반환하는 경우
  <pre><code>
  int* func()
  {
    static int a = 100;
    return &a;
  }
  </code></pre>
    - 정적 지역 변수를 사용하고, 이 주소를 반환하면 스레드 공유 리소스가 된다.

### 2.3.9 스레드 안전이 아닌 코드 호출하기
- 스레드 안전이 아닌 코드를 호출하는 함수는 스레드 안전일까?
    <pre><code>
    int global_num = 0;
    int func()
    {
        ++global_num;
        return global_num; 
    } 
      </code></pre>
    <pre><code>
    int funcA()
    {
        mutex l;
  
        l.lock();
        func();
        l.unlock();
    } 
      </code></pre>
    - 스레드 안전이 아닌 func 함수를 위와 같이 잠금으로 보호해 호출하면 funcA 함수는 스레드 안전 
  
### 2.3.10 스레드 안전 코드는 어떻게 구현할까?
스레드 안전을 구현하려면 어떤 것이 스레드 전용 리소스, 스레드 공유 리소스인지 파악하고, 알맞은 방법을 사용한다.
- 스레드 전용 저장소
  - 전역 리소스를 사용해야 한다면, 스레드 전용 저장소로 선언할 수 있는지 점검한다.
- 읽기 전용
  - 전역 리소스를 읽기 전용으로 사용해도 되는지 확인해본다.
- 원자성 연산
- 동기화 시 상호 배제 
