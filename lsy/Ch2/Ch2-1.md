## 2.1 운영체제, 프로세스, 스레드의 근본 이해하기

### 2.1.1 모든 것은 CPU에서 시작된다
- CPU는 멍청하지만 빠르다.
- CPU가 알고 있는 것은 아래 두 가지 뿐이다.
    1. **메모리에서 명령어를 하나 가져온다(dispatch).**
    2. **이 명령어를 실행(execute)한 후 다시 1번으로 돌아간다.**
  
- 1번에서 명령어를 가져올 때, 어떤 기준으로 가져올까?
    - 레지스터 a.k.a PC(Program Counter)

  ### PC 레지스터

    - CPU가 다음에 실행할 명령어의 주소가 저장된다.
    - 레지스터가 저장하는 주소는 기본적으로 1씩 자동 증가한다.
    - if, else 등의 명령어를 만나면 올바른 위치로 레지스터 값을 동적 변경한다.
    - 일단 프로그램 시작 이후에는 **1씩 증가** 혹은 **동적 변경**을 진행, 그렇다면 프로그램이 시작될 때 최초의 레지스터 값은 어떻게 설정될까?

        
  > 🔥 프로그램이 시작될 때..
    
- 소스파일이 컴파일러에 의해 실행 파일로 변환되면 이 실행 파일은 디스크에 저장된다.
- 프로그램을 실행하게 되면 디스크에 있는 실행 파일을 메모리에 복사한다. (명령어 적재)
- 프로그램에는 반드시 시작 지점이 필요 ⇒ **main 함수**
- main 함수에 대응하는 기계 명령어를 찾고, 해당 명령어의 메모리 주소를 레지스터에 기록한다.
- main 함수를 실행하기 전, 별도의 레지스터 초기화 과정 진행

    
  **⇒ 최초의 레지스터 값은 프로그램의 main 함수에 해당하는 기계 명령어 주소**


### 2.1.2 CPU에서 운영체제까지
> 프로그램을 실행시키는 위 과정을 우리가 일일히 수동으로 해줘야 한다면..?
- 실행 파일을 메모리에 복사하는 '반복 작업'을 대신 해주는 프로그램을 만들자 -> 적재 도구 (Loader)

> 단일 코어 컴퓨터에서 프로그램 여러 개를 동시에 실행하고 싶다면..?
- 프로그램 여러 개를 매우 빠른 속도로 전환하면서 실행하면 동시에 실행되는 것처럼 보인다. 
  - 프로그램 A 실행 -> A 중지 후 B 실행 -> B 중지 후 다시 A 실행
- 중지 후 재시작을 위해, 프로그램이 어디까지 실행되었는지 '상태' 정보가 필요 
  - 실행 상태를 저장하기 위한 구조체를 코드로 정의 -> 프로세스
  - 모든 프로그램은 실행 후 프로세스 형태로 관리된다. (프로세스 관리 도구)

적재 도구, 프로세스 관리 도구 등 여러 가지 프로그램을 모아 둔 도구 -> 운영체제 (Operating system)
- 실행 파일 적재, 프로그램 관리를 운영체제가 알아서!

### 2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다
![img.png](img.png)

- **프로세스 주소 공간** (프로그램이 실행 중일 때의 메모리 내 프로세스 상황)
  - **코드 영역** (사진에서의 텍스트 영역) : 코드를 컴파일해 생성된 기계 명령어
  - **데이터 영역** : 전역 변수 등
  - **힙 영역** : malloc 함수가 요청을 반환한 메모리
  - **스택 영역** : 함수의 실행 시간 스택 
  - 스택과 힙 사이 빈 공간은 여유 공간
  
```c
int main() 
{
    int resA = funcA();
    int resB = funcB();
    
    print(resA + resB);
    
    return 0;
}
```
위 프로그램을 실행하는 상황을 떠올려보자.
- 위 코드가 변환된 기계 명령어가 코드 영역에 할당된다. 
- funcA 실행 -> funcB 실행 -> 두 결과를 더하기
- 사실 funcA와 funcB는 독립적인 함수.. 순차적으로 실행하는 것보다 시간을 절약할 수 있는 방법은 없을까?
-> funcA와 funcB를 두 개의 프로세스로 나누어 실행한 뒤 결과를 합치자! => **다중 프로세스 프로그래밍**

> 다중 프로세스 프로그래밍의 단점
- 각 프로세스를 생성할 때마다 오버헤드 
- 프로세스마다 개별적인 주소 공간을 가지므로 프로세스 간 통신이 복잡 

### 2.1.4 프로세스에서 스레드로 진화
- 기존에는 프로그램의 진입점이 main 함수 하나 -> 이 프로세스의 기계 명령어를 하나의 CPU에서만 실행할 수 있다.
- 사실 main 함수와 다른 함수에는 차이점이 존재하지 않기 때문에, 진입점을 다른 함수로도 설정할 수 있다.
- 즉 PC 레지스터가 다른 함수를 가리키게 해 새로운 실행 흐름을 생성하고, 동시에 여러 CPU가 같은 프로세스의 기계 명령어를 실행할 수 있게 된다.
- 이렇게 생성한 실행 흐름들은 동일한 주소 공간을 공유
-> 프로세스 간 통신을 할 필요 X (다중 프로세스 프로그래밍의 단점 해결)
- '실행 흐름' => **스레드** 
    ### 스레드 정리
    - 스레드는 프로세스 내의 실행 흐름이다.
    - 한 프로세스 당 여러 개의 스레드가 생성될 수 있다.
    - 스레드는 동일한 프로세스 주소 공간을 공유한다. (변수 등)
    - 프로세스보다 훨씬 가볍고, 생성 속도가 빠르다. 
    - 스레드를 실행시키려면, PC 레지스터에 스레드 진입 함수 주소를 지정하면 된다. 

### 2.1.5 다중 스레드와 메모리 구조 
- 함수가 실행될 때 필요한 정보(매개변수, 지역 변수, 반환 주소 등)는 스택 프레임에 저장된다.
- 모든 함수는 실행 시 자신만의 런타임 스택 프레임을 가진다.
- 함수가 호출, 반환될 때마다 LIFO 룰에 따라 스택 프레임 증감이 이루어지고, 프로세스 주소 공간의 스택 영역을 형성한다.
- 스레드의 등장으로, 각 실행 흐름에 대한 정보를 저장하기 위해 스택 영역이 여러 개 필요하게 된다. 
- 스레드가 많아지면 그만큼 프로세스의 메모리 공간이 소모된다. 

### 2.1.7 스레드 풀의 동작 방식
- 스레드 풀 : 스레드 여러 개를 미리 생성해두고, 스레드가 처리할 일이 생기면 이를 할당하는 것
> 스레드에게 어떻게 작업을 할당해줄까?
  - 작업 : 처리할 데이터 + 데이터를 처리하는 함수
    - 작업을 전달하는 것 -> 생산자
    - 작업을 처리하는 스레드 -> 소비자 
  1. 스레드 풀의 스레드는 작업 대기열에서 블로킹 상태로 대기
  2. 생산자가 작업 대기열에 데이터 기록 
  3. 스레드 풀의 스레드가 깨어남
  4. 깨어난 스레드는 대기열에서 작업 구조체를 가져옴
  5. 구조체의 데이터 처리 함수를 실행
- 작업 대기열은 모든 스레드가 공유하기 때문에 상호배제 문제 해결 필요!

### 2.1.8 스레드 풀의 스레드 수 
- 스레드 풀의 스레드 수가 너무 적다면? -> CPU를 최대한 활용할 수 없다
- 스레드 수가 너무 많다면 -> 시스템의 성능 저하, 메모리 과다 점유, 스레드 전환 부담
- 스레드 수를 결정하는 절대 공식은 X, 구체적인 상황 분석 필요 
  - ex. 작업 유형에 따라  적절한 스레드 수가 다르다
    - CPU 집약적 작업 : CPU 코어 수와 동일한 스레드 수
    - 입출력 집약적 작업 (p.93)