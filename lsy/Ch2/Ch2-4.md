## 2.4 프로그래머는 코루틴을 어떻게 이해해야 할까?
- 지금까지 알아본 스레드는 커널 스레드를 의미하고, 커널 스레드는 스레드의 생명주기를 운영체제가 관리한다. 
- 운영체제에 의존하지 않는 상황에서 스레드를 구현할 수 있을까? -> **코루틴**

### 2.4.1 일반 함수
- 일반 함수는 처음부터 시작되어 return 명령어를 만나거나 마지막 줄까지 실행되어야 반환된다. 

### 2.4.2 일반 함수에서 코루틴으로 
- 코루틴에는 **일시 중지**와 **재개 기능**이 존재한다.
- 코루틴에서 함수를 실행한다면, '일시 중지 및 반환을 할 수 있는 코드'를 사용해 코드 중간에 반환이 가능하다. 
  - 기존 return 문 반환은 반환 후 이전 함수로 돌아갈 수 있는 방법이 없다.
  - 코루틴의 경우 자신의 실행 상태를 저장할 수 있어 재호출 시 일시 중지된 시점에서 이어서 실행이 가능하다. 
- 코루틴 코드 예시
  ```python
  def func():
    print("a")
    yield
    print("b")
    yield
    print("c")
  
  def a():
    co = func() # 코루틴 획득
    next(co) # 코루틴 호출 -> 1. print("a") 실행 
    print("in function A") # 2. 실행
    next(co) # 코루틴 재호출 -> 3. print("b") 실행
  ```
### 2.4.4 함수는 그저 코루틴의 특별한 예의 불과하다
- 운영체제의 스레드 스케줄링 
  - 스레드 일시 중지 
  - 스레드의 실행 상태 저장 
  - 다른 스레드 스케줄링
- 코루틴은 사용자 상태 내에서 구현된 것이므로 운영체제는 코루틴에 대해 알지 못하고, 일시 중지 등 예약어로 사용자가 직접 제어해야 한다. 
  -> **사용자 상태 스레드** 
  - 운영체제 -> 프로그래머
  - 스레드 -> 코루틴 

### 2.4.5 코루틴의 역사
- 1958년 : 코루틴 개념 등장 (스레드 개념 존재 이전) 
- 1972년 : 코루틴을 구현한 프로그래밍 언어 등장 -> 시뮬라 67, 스키마 
  - 하지만 거의 사용되지 않음
- 스레드가 등장하면서 코루틴 사용은 점점 축소 
- 최근 서버에서 처리해야 하는 사용자 요청이 폭증하면서, 높은 성능과 동시성을 요구하는 분야에 다시 코루틴이 사용되기 시작했다.

### 2.4.6 코루틴은 어떻게 구현될까?
- 코루틴의 상태 정보 : CPU 레지스터 정보, 함수 실행 시 상태 정보 
  - 함수의 스택 프레임에 저장된다. 
- 프로세스 주소 공간의 스택 영역 -> 스레드를 위한 공간 
- 코루틴의 스택 프레임 정보는 어디에 저장해야 할까? -> **힙 영역** 
- 이론적으로 메모리 공간이 충분하다면 코루틴 개수 제한 X
> **코루틴의 역할은 무엇일까?**
> <br> 프로그래머가 동기 방식으로 비동기 프로그래밍을 가능하게 한다. (2.8절)