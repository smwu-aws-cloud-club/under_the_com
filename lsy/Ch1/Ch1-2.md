## 1.2 컴파일러는 어떻게 작동하는 것일까?

### 1.2.1 컴파일러는 그저 일반적인 프로그램일 뿐, 대단하지 않다

- **컴파일러** : 고수준의 언어 → 저수준의 기계어로 번역
- 인간이 인식할 수 있는 단어로 작성한 코드 → **소스 파일**
- **컴파일러**는 소스 파일을 받아 **실행 파일** 형태로 내보내줌
    - 이 실행 파일에는 CPU가 직접 실행할 수 있는 기계 명령어가 저장되어 있음
- **다시 보는 컴파일 단계**
    1. 어휘 분석 : 문자열을 토큰으로 변환
    2. 구문 분석 : 토큰을 구문 트리로 변환
    3. 의미 분석
    4. 중간 표현 생성
    5. 코드 생성 : 어셈블리어로 변환
    6. 최적화
    7. 어셈블러 : 기계어로 변환

### 1.2.2 각각의 토큰 추출하기

소스코드를 읽으며 모든 토큰을 찾아낸다 → **어휘 분석** (lexical analysis)

```markdown
// 소스 코드
int a = 1;

// 추출된 토큰
// 왼쪽 열은 토큰의 의미, 오른쪽 열은 토큰이 가지는 값
T_Keyword     int
T_identifier  a
T_Assign      =
T_Int         1
T_Semicolon   ;
```

### 1.2.3 토큰이 표현하고자 하는 의미

단순히 토큰을 추출하는 것은 의미가 없다. 프로그래머가 전달하려는 토큰의 의도를 표현해야 한다.

```markdown
while (표현식) {
	반복 내용
}
```

- 위 구문의 경우, 컴파일러가 while 토큰을 만나게 되면 그 다음 토큰으로는 ( 를 기다린다.
    - 다음 토큰이 ( 이 아니라면 문법 오류를 발생시킴
- 컴파일러는 구문에 맞게 토큰을 해석하고, 구조를 그려냄 → **구문 트리**
- 구문 트리 생성 과정 → **구문 분석**

### 1.2.4 생성된 구문 트리에 이상은 없을까?

- 구문 트리에 이상이 없는지 확인하는 과정 → **의미 분석** (semantic analysis)
    - ex) 정수열에 문자를 더하는 경우 등

### 1.2.5 구문 트리를 기반으로 중간 코드 생성하기

구문 트리를 바탕으로 다듬어진 형태인 **중간 코드를 생성**

### 1.2.6 코드 생성

중간 코드를 어셈블리어 코드로 변환 → 어셈블리어를 기계 명령어로 변환

하지만 그저 간단한 것은 아니다..

- GCC 컴파일러의 경우…
    - 소스 코드 `code.c` 파일
    - 변환된 기계 명령어 데이터는 `code.o`라는 대상 파일(Object file)에 저장됨
    - 모든 소스 코드마다 대상 파일이 생성되는데, 우리가 원하는 건 단 하나의 실행 파일
    - 여러 대상 파일을 어떻게 합칠 것인가 → **링커 (Linker)**