## 1.1 여러분이 프로그래밍 언어를 발명한다면?

### 1.1.1 창세기 : CPU는 똑똑한 바보

- CPU는 **기계 명령어**를 실행하는 존재
- 아주 단순한 작업만을 실행할 수 있지만, **아주 빠른 속도를 가짐**
- 빠르게 연산할 수 있는 CPU를 사용하기 위해, 인간은 CPU가 이해할 수 있는 형태로 명령어를 작성
    - ex) 0과 1로 구성된 천공카드
- 하지만 0과 1로 이루어진 명령어는 인간이 직관적으로 이해할 수 없었다. (개발의 어려움)

### 1.1.2 어셈블리어 등장

- 프로그래머들은 이 불편함을 해소하기 위해 CPU가 실행할 수 있는 몇 가지 기계 명령어를 인간이 이해할 수 있는 단어로 대응시킴 → 어셈블리어
- 익숙한 단어의 기계 명령어 (어셈블리어) → 바이너리로 변환해 CPU에서 연산
- 이제는 직관적으로 이해할 수 있는 단어만 기억하고 있으면 개발이 가능
- 하지만 여전히 일상적으로 사용하는 인간 언어 형식과 많은 차이가 있었다.

### 1.1.3 저수준 계층의 세부 사항 vs 고수준 계층의 추상화

- 인간이 사용하는 언어는 고수준으로 추상화되어 있는데, CPU는 이런 추상적인 표현을 이해할 수 없다.
    - **‘나에게 물을 달라’**라는 일상적인 표현도 추상화된 표현인데, 이 간단한 한 문장 속에 여러 가지 세부적인 사항들이 내포되어 있다.
    - 물컵을 찾는다, 물컵을 잡는다, 음수대로 간다, 수도꼭지를 연다, 컵이 아직 가득 차지 않았다면, 계속 기다린다, …. 등
    - **인간** : ‘나에게 물을 달라’
    - **CPU** : ‘나에게 물을 달라’ ⇒ 이해 불가능
      ’물컵을 찾는다’ ⇒  더 세부적인 표현은 이해 가능 (실제로는 물컵을 찾는다도 추상화된 표현이겠지만,,)
- 즉, 우리가 개발을 편하게 하기 위해서는(CPU를 더 쉽게 컨트롤하기 위해) **인간이 쓰는 추상화된 표현**을 **CPU가 이해할 수 있는 구체적 표현**으로 변환해야 한다.

### 1.1.4 고급 프로그래밍 언어의 시작

우리가 요청하는 명령들을 살펴봤을 때….

- CPU가 실행하는 단도직입적인 간단한 명령어 → **문(Statement)**
    - 명령 최소 단위 같은 느낌..?
- 이런 문들을 반복해야 하는 경우 → **순환**
- 조건에 따라 다른 문을 수행해야 하는 경우 → **조건**
- 비슷한 명령어들인데 개별적인 세부 사항만 다른 경우 → **함수 with 매개변수**

### 1.1.5 <인셉션>과 재귀 : 코드 본질

- 명령어들은 재귀적으로 구성될 수 있다.
    - if문 내부의 statement(문) → 그 statement 내부에 또 if문 → ……

```markdown
if : if exprt statement else statement
for : while expr statement
statement : if | for | statement
```

- 위 표현을 구문이라고 부르며, 모든 코드는 구문으로 귀결된다.

### 1.1.6 컴퓨터가 재귀를 이해하도록 만들기

- 재귀 형태의 프로그래밍 언어를 어떻게 기계어로 변환할 수 있을까?
- 재귀 구문에 따라 작성된 코드를 **트리 형태**로 표현하자!
    - 이렇게 생성된 트리를 **구문 트리**라고 부른다.
- 트리 구조로 표현하면서 리프 노드의 내용이 간단해지고, 쉽게 기계어로 변환이 가능해졌다.

### 1.1.7 우수한 번역가 컴파일러

- **컴파일러** : 구문 트리를 만들고 기계어로 변환하는 작업을 담당
- **컴파일 단계**
    1. 어휘 분석 : 문자열을 토큰으로 변환
    2. 구문 분석 : 토큰을 구문 트리로 변환
    3. 의미 분석
    4. 중간 표현 생성
    5. 코드 생성 : 어셈블리어로 변환
    6. 최적화
    7. 어셈블러 : 기계어로 변환

### 1.1.8 해석형 언어의 탄생

- 이제 프로그래밍 언어를 기계어로 바꿔주는 것까지는 OK
- 새로운 문제 → 각 CPU마다 고유의 언어를 가짐
    - 코드를 작성함 → 컴파일러를 통해 실행 파일이 생성됨
    - 각 CPU마다 다른 실행 파일이 필요한 것..
- 모든 CPU에 통용될 수 있는 표준 명령어 집합을 정의하자.
    - 코드는 하나, 이 코드가 표준 명령어 집합으로 변환되면 각 CPU에 맞는 시뮬레이션 프로그램(인터프리터)을 통해 서로 다른 플랫폼에서 코드를 실행할 수 있게 됨