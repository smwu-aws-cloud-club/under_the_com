**## 3.1 메모리의 본질, 포인터와 참조
### 3.1.1 메모리의 본질은 무엇일까? 사물함, 비트, 바이트, 객체
메모리 셀 -> 보관이 가능한 단위 
- 오직 0과 1만 보관 가능
  - 0, 1을 가리켜 **1비트**라고 한다.
- 더 많은 정보를 표현하기 위해 8비트를 묶은 **1바이트** 단위 사용

1비트를 저장할 수 있는 메모리 셀에 주소 번호를 붙이는데, 이 주소를 **메모리 주소**라고 한다.
- 충분한 숫자 정수값을 표현하기 위해서 4바이트를 묶어 사용한다. 
  - int -> 4바이트
- 구조체, 객체 정보 -> 12바이트

### 3.1.2 메모리에서 변수로 : 변수의 의미

1 + 2 값을 계산하려고 할 때...
- 숫자 1과 2를 메모리에 적재해야 한다.
- 숫자 1을 6번 메모리 주소에 넣으려면...
  - <code>store $1 6</code>
  - <code>store ${저장할 숫자값} {메모리 주소}</code>
- CPU 레지스터에 값을 읽어오려면...
  - <code>load r1 6</code>
  - <code>load {레지스터 정보} {메모리 주소}</code>
- 앞에 $이 붙으면 일반 값, $ 기호가 없다면 메모리 주소 
- 6번 주소에 사람이 이해하기 쉬운 이름 'a'를 붙여준다면? -> **변수**
- 변수 'a'
    - 값 1을 나타낸다.
    - 이 값은 메모리 주소 6에 저장된다.
- 만약 새로운 변수 b를 a에 할당한다면?
  - b = a
  - a에 저장된 값이 b에 그대로 복제된다.
### 3.1.3 변수에서 포인터로 : 포인터 이해하기
만약 a 변수가 구조체 같은 여러 바이트의 데이터를 나타낸다면? b에 복제될 때 메모리 낭비가 발생! 

-> 이를 해결하기 위해 데이터를 복제하는 것이 아니라, b에 데이터의 메모리 주소를 저장한다!

변수에 값이 아닌 메모리 주소를 저장할 수 있는 **포인터** 개념 등장
- 포인터는 메모리 주소를 더 높은 수준으로 추상화한 것

> 예시
>1. 변수 a가 메모리 주소 3번에 할당된다.
>2. a에는 6이라는 숫자값이 저장되어 있다.
>3. b에는 a의 주소값이 저장된다.
>4. 변수 b는 메모리 주소 1번에 할당된다.
- <code>load r1 1</code>
  - 메모리 주소 1에 있는 값을 또 다른 메모리 주소로 해석해야 하므로 0과 같은 식별자를 추가해야 한다.
- <code>load r1 01</code>
  - 1에 저장된 값 : 3 (메모리 주소)
  - 3에 저장된 값 : 6 (데이터)
  - **주소 1 -> 주소 3 -> 데이터** (어셈블리어)
  - 고급 언어에는 변수 개념이 있기 때문에 

### 3.1.4 포인터의 힘과 파괴력 : 능력과 책임**
C언어는 포인터 개념이 있어, 메모리 같은 하드웨어를 프로그래머가 직접 조작할 수 있다. 
- 해당 변수가 어느 메모리 위치에 저장되어 있는지 확인 가능
- 자바, 파이썬 같은 언어에서는 포인터를 한 번 더 추상화한 **참조**라는 개념 존재

### 3.1.5 포인터에서 참조로 : 메모리 주소 감추기
- 포인터 : 메모리 주소를 추상화한 것
- 참조 : 포인터를 추상화한 것
  - 참조를 사용할 때는 변수의 구체적인 메모리 주소를 얻을 수는 없다 
