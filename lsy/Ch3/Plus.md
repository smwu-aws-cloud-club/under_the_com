## 메모리 단편화란?

* **외부 단편화 (External Fragmentation)**: 사용할 수 있는 총 메모리는 충분하지만, 연속된 공간이 부족해서 할당이 실패하는 경우
* **내부 단편화 (Internal Fragmentation)**: 할당된 블록 내부에 실제 사용하지 않는 공간이 남는 경우

---

## 사용자 모드에서 단편화 대응 방법

사용자 모드에서는 `malloc()` / `free()`로 힙 메모리를 할당하고 해제한다. 

### 1. 메모리 할당 알고리즘

* **First Fit**: 가장 먼저 맞는 크기의 공간에 할당
* **Best Fit**: 가장 적절하게 작은 빈 공간에 할당 → 외부 단편화 줄이지만 속도 느림
* **Buddy System**: 2^n 크기로 분할하여 관리 (효율적이나 내부 단편화 발생 가능)

### 2. Free List + Coalescing (병합)

* 할당이 해제되면 `free list`에 등록
* 인접한 free block끼리 **병합(coalescing)** 해서 큰 공간을 확보 → 외부 단편화 완화

### 3. 메모리 Pool (Object Pool)

* 고정된 크기의 오브젝트를 자주 할당/해제할 경우, 미리 메모리를 풀로 만들어 둠
* 오브젝트 재사용 → 할당 속도 빠르고 단편화 방지

---

## 커널 모드에서 단편화 대응 방법

### 1. Buddy System (페이지 단위 관리)

* 리눅스의 기본 페이지 할당 시스템
* 2의 제곱 크기 단위로 메모리를 할당
* 인접한 buddy 블록이 비면 합쳐서 더 큰 블록 생성 → 외부 단편화 해결

```plaintext
ex) 4KB → 8KB → 16KB ...
```

* 단점: 내부 단편화 발생 가능

### 2. Slab Allocator (슬랩 할당자)

* 오브젝트 풀 개념 사용: 구조체 단위로 슬랩 캐시를 만들어 할당/해제
* 페이지를 작은 캐시로 관리하면서 **단편화 감소 + 빠른 할당/해제**

```plaintext
[Slab Cache] → 여러 Slab → 여러 Object
```

* 커널은 슬랩을 사용해서 `kmalloc()` 등의 동작을 최적화함

### 3. vmalloc()

* 커널 가상 메모리 할당 방식
* 연속된 가상 주소 제공, 물리 메모리는 불연속 허용
* 큰 메모리 요청에 유용하지만 느림
* 단편화는 가상 주소 공간 내에서만 문제 → 해결이 쉬움

### 4. 페이지 재배치 또는 Reclaim

* 메모리 부족 시 LRU 페이지 교체, reclaim 등으로 자원을 회수
* 슬랩 할당자에서도 오래된 슬랩을 reclaim 함

---

## ✅ 정리 비교표

| 항목    | 사용자 모드                    | 커널 모드                       |
|-------|---------------------------|-----------------------------|
| 주요 문제 | 내부 + 외부 단편화               | 주로 외부 단편화                   |
| 대응 방식 | malloc/free 최적화, GC, 풀 할당 | Buddy system, Slab, vmalloc |
| 접근 권한 | 제한적 (가상 메모리)              | 시스템 전역 메모리                  |




