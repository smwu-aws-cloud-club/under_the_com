## 3.3 스택 영역 : 함수 호출은 어떻게 구현될까?
### 3.3.1 프로그래머를 위한 도우미 : 함수
함수 : 가장 간단한 코드 재사용 방식
- 함수를 호출할 때 구현부는 신경쓸 필요 없이 함수 이름, 매개변수, 반환값만 알고 있으면 된다.

### 3.3.2 함수 호출 활동 추적하기 : 스택
함수의 진행 상황을 후입 선출 순서로 관리하기 때문에, 스택 같은 데이터 구조가 처리하기에 적합하다.
1. A에서 B 호출
2. B에서 D 호출 
3. D 실행 완료 
4. B 실행 완료 
5. A에서 C 호출 
6. C 실행 완료 
7. A 실행 완료

### 3.3.3 스택 프레임 및 스택 영역 : 거시적 관점
위와 같은 정보를 저장하기 위해 함수 실행 시에 스택 프레임이라는 공간을 사용하고, 이 스택 프레임은 프로세스 영역 중 스택 영역에 생성된다.
- 스택 영역이 차지하는 메모리는 함수 호출 깊이가 깊어질수록 증가
- 함수 호출이 완료될수록 감소

### 3.3.4 함수 점프와 반환은 어떻게 구현될까?
만약 함수 A가 B를 호출하면 제어권이 B로 옮겨진다.

- CPU가 함수 B에 속하는 기계 명령어를 실행하고 있다면.. → 제어권이 B에 있는 것!

이렇게 제어권이 이전될 때 필요한 정보

- 반환 : 어디에서 왔는지 (되돌아가야 하기 때문에 필요)
    - 기존 함수가 어디까지 실행되었는지
- 점프 : 어디로 가야 하는지
    - 실행해야 하는 다른 함수의 기계 명령어가 위치한 주소

이런 정보를 얻기 위해 스택 프레임을 이용한다.

`call 0x400540`
- 함수 A의 기계 명령어를 실행하다가 위 명령어를 만난다. 이때 0x400540은 B의 주소!
- CPU에서 위 기계 명령어가 실행될 때, 1) 0x400540 주소로 이동하고, 2) 다음으로 실행할 A 명령어의 주소 (0x40056a)를 기존 함수 A의 스택 프레임에 넣는다.
- B가 새롭게 실행되므로 B의 스택 프레임이 추가된다. 
- 만약 B에서 다른 함수가 호출되면 또 새로운 스택 프레임이 생성된다. 

`ret` : 함수의 마지막 기계 명령어 
- 함수 A의 스택 프레임에 저장된 반환 주소로 점프하도록 하는 역할
- A 스택 프레임에 저장되었던 다음 주소를 실행할 수 있다.

### 3.3.5 매개변수 전달과 반환값은 어떻게 구현될까?
함수 호출에 필요한 매개변수, 반환값 전달은 어떻게 구현될까?
- 함수 A가 B를 호출하면 함수 A는 넘겨줄 매개변수를 레지스터에 저장하고 CPU는 레지스터를 통해 매개변수 정보를 가져와 B를 실행한다. 
- B도 반환값을 레지스터에 저장한다. 

레지스터 수는 제한되어 있는데, 매개변수의 개수가 사용 가능한 레지스터 수보다 많다면?
- 나머지 매개변수를 스택 프레임에 넣는다.
- 새로 호출된 함수는 기존 함수의 스택 프레임에서 매개변수를 가져와 사용한다.

### 3.3.6 지역 변수는 어디에 있을까?
**전역 변수**
- 함수 외부에 정의된 변수
- 실행 파일의 데이터 영역에 저장
- 프로그램 실행 시 프로세스 주소 공간의 데이터 영역에 적재

**지역 변수**
- 함수 내부에 정의된 변수
- 해당 함수 외부에서는 접근 불가능
- 함수가 실행될 때 매개변수, 반환값과 마찬가지로 레지스터, 스택 프레임에 저장될 수 있다. 

레지스터를 여러 함수가 공유하면서, 레지스터에 기록된 지역 변수 정보를 다른 함수가 덮어쓸 수 있지 않을까?

### 3.3.7 레지스터의 저장과 복원
레지스터에 저장된 기존 값을 유지하기 위해, 원래 저장되어 있던 기존 값을 꺼냈다가 레지스터 사용 후 다시 그 기존 값을 복원해둬야 한다.
- 레지스터에서 꺼낸 기존 값 (레지스터 초깃값)은 역시 **스택 프레임**에 저장된다. 
- 만약 함수 A에서 지역 변수를 사용한다면, 이 지역 변수 값은 레지스터에 적재되고 기존에 레지스터에 존재하던 값은 함수 A의 스택 프레임에 저장된다. 
- 함수 실행 완료 후에 스택 프레임에 저장되어 있는 레지스터 초깃값을 복원한다. 


### 정리 : 스택 프레임
**스택 프레임**
- 프로세스 주소 공간 중 스택 영역에 위치
- 각 함수가 호출될 때마다 그에 상응하는 개별 스택 프레임 생성

**스택 프레임에 담기는 값**
- **레지스터 초깃값** : 함수가 실행되기 전 레지스터에 저장되어 있던 값
- **함수의 지역변수** : 레지스터에 저장하지 못한 지역변수
- **매개변수** : 레지스터에 저장하지 못한 매개변수
- **반환 주소** : 호출된 함수 실행 완료 후 그 다음에 실행해야 할 기계 명령어 주소

### 3.3.8 큰 그림을 그려 보자, 우리는 지금 어디에 있을까?
```
void func(int a)
{
  if(a > 100000000)
  {
    return;
  }
  
  int arr[100] = {0};
  func(a + 1);
}

void main()
{
  func(0);
}
```
위 코드는 자기 자신을 100000000번 반복해 호출하는데, 함수 호출에 따라 엄청난 양의 스택 프레임이 생성된다. 하지만 스택 영역의 크기에는 제한이 있고 이 제한을 초과하면 stack overflow 오류가 발생한다. 
- 이런 오류를 방지하기 위해 프로그래머가 신경 써야 할 것..
  1. 너무 큰 지역 변수를 만들면 안 된다. 
  2. 함수의 호출 단계가 많으면 안 된다.

