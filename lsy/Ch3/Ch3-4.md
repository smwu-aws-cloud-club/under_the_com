## 3.4 힙 영역 : 메모리의 동적 할당은 어떻게 구현될까?
> 프로그래머가 기억해야 할 것!
> 1. 함수 A에서 B를 호출했다. 이때 B의 스택 프레임이 생성되는데, 함수 B의 호출이 완료된 후에는 해당 스택 프레임에 있던 내용은 완전히 무효화된다. 
>    ```c
>    int * B()
>    {
>       int a = 10;
>       return &a;
>    } 
>   ```
>    - 위 함수는 지역 변수의 주소값을 반환하고 있다.
>    - return문과 동시에 지역 변수 a가 저장되어 있던 스택 프레임이 무효화된다. 이미 무효화된 메모리 주소를 반환하므로 기대하지 않은 동작이 발생할 수 있다.
> 
> <br>
> 2. 지역 변수는 함수가 호출될 때 메모리에 할당되고, 함수 호출이 완료되면 메모리가 반환되기 때문에 프로그래머가 메모리 문제에 대해 신경 쓸 필요가 없다. 
> 

### 3.4.1 힙 영역이 필요한 이유
여러 함수에 걸쳐 동일한 데이터를 사용하고 싶다면 전역 변수를 사용하는 방법밖에 없을까?
- 프로그래머가 직접 메모리 할당과 해제를 관리할 수 있는 메모리 영역이 있다면, 전역 변수가 아니더라도 원하는 만큼 데이터를 유지하고 다른 함수에서 공유할 수 있다!
- 이런 메모리 영역이 바로 **힙 영역**

**C/C++에서 힙 영역을 제어하는 방법**
  - 메모리 요청 : `malloc` 함수, `new` 예약어
  - 메모리 반환 : `free` 함수, `delete` 예약어

### 3.4.2 malloc 메모리 할당자 직접 구현하기
malloc 함수는 C 표준 라이브러리에 포함되어 있다. 

실행 파일을 생성할 때 링커가 이 라이브러리를 자동으로 링크하기 때문에 프로그래머는 malloc 함수 사용을 통해 직접 복잡한 구현을 할 필요 없이 메모리를 할당할 수 있다. 

- 힙 영역은 커다란 배열 형태
  - `malloc` 함수 : 힙 영역에서 비어 있는 메모리 영역을 찾아 사용자에게 반환하는 기능 구현
  - `free` 함수 : 메모리 영역 사용이 완료되었을 때 힙 영역에 이 영역을 반환하는 기능 구현

### 3.4.3 주차장에서 메모리 관리까지
**메모리 관리의 핵심**
1. 요청한 메모리 크기를 만족하는 여유 메모리 공간을 빨리 찾아야 한다.
2. 가능한 많은 메모리 요청을 만족해야 한다. 

**메모리 관리에서 고려해야 할 것**
1. 힙 영역의 메모리 할당 여부를 어떻게 알 수 있을까? 
   - 메모리 조각을 조직화해서 관리해야 한다. -> `3.4.4` 
2. 여러 여유 메모리 조각 중 어떤 메모리를 반환해줘야 할까? -> `3.4.5`
3. 특정 메모리 조각에 메모리를 할당한 후 남은 메모리는 어떻게 처리해야 할까?
4. 사용자가 반환한 메모리는 어떻게 처리해야 할까? 

### 3.4.4 여유 메모리 관리하기
사용 가능한 메모리 조각인지 판단하기 위해서는 할당 여부를 관리해야 한다. 
- 각 메모리 조각은 해당 조각의 크기와 할당 여부 정보(1비트)를 헤더에 함께 저장한다. 
- 헤더의 주소만 알고 있다면 `헤더의 주소 + 해당 조각의 크기` 로 다음 메모리 조각의 시작 주소를 알 수 있다. 
- 힙 영역의 일부는 메모리 조각에 대한 정보(헤더)를 저장하는데 사용된다.

### 3.4.5 메모리 할당 상태 추적하기
![img_1.png](image/3.4.5%20힙%20영역.png)
- 한 조각당 4바이트가 할당된다.
- `8/0` : 8바이트의 여유 메모리 조각이 있다.
- `16/1` : 16바이트 메모리 조각이 할당되어 있다.
- `0/1` : 힙 영역의 마지막을 나타내는 마지막 4바이트

### 3.4.6 어떻게 여유 메모리 조각을 선택할 것인가 : 할당 전략

**1. 최초 적합 방식**

힙 영역의 처음부터 탐색하다가 메모리 영역이 충분하면 바로 반환
- 장점 : 단순하고 빠르다.
- 단점 : 힙 영역의 앞부분에 작은 메모리 조각이 많이 남는다.

**2. 다음 적합 방식**

마지막으로 메모리를 할당해준 부분부터 탐색하다가 메모리 영역이 충분하면 바로 반환
- 장점 : 이론적으로 최초 적합보다 더 빠른 탐색 가능
- 단점 : 메모리 사용률이 최초 적합 방식에 미치지 못한다.


**3. 최적 적합 방식**

사용 가능한 메모리 조각을 모두 찾은 후, 메모리가 충분하면서 크기가 가장 작은 조각을 반환
- 장점 : 남는 메모리 영역이 가장 적은 방법 -> 메모리 활용률 굿!
- 단점 : 시간이 비교적 오래 걸린다.


### 3.4.7 메모리 할당하기
여유 메모리 조각을 찾고 이를 할당하려고 할 때 필요한 동작
1. 해당 조각을 할당되었다고 표시한다.
2. 헤더 정보 뒤에 따라오는 메모리 조각의 주소를 요청자에게 반환한다.

만약 여유 메모리 조각에서 남는 공간이 발생한다면?
- 여유 메모리 조각을 분할해 할당한다. 

### 3.4.8 메모리 해제하기
요청자는 할당 시에 얻은 메모리 조각의 주소를 통해 헤더의 주소 정보를 얻을 수 있고, 헤더의 할당 여부 비트를 변경한다. 
- 반환된 메모리의 다음 부분도 여유 메모리 조각인 경우, 이 조각을 바로 병합해야 할까?
  - 바로 병합하는 방식이 간단하지만, 메모리가 해제될 때마다 병합할 경우 부담이 발생한다. 
  - 하지만 가장 간단하기 때문에 이 전략을 많이 사용한다.

### 3.4.9 여유 메모리 조각을 효율적으로 병합하기
만약 해제된 메모리의 앞 부분도 비어있다면? 
- 뒷 부분이 비어있는 것은 해제된 메모리의 크기만큼 이동해 쉽게 파악이 가능하지만 앞 부분이 비어있는 것은 어떻게 알 수 있을까?

헤더 정보뿐만 아니라 꼬리 정보까지 저장!
- 꼬리 정보(footer)를 통해 앞·뒤 조각의 상태를 쉽게 확인할 수 있다.
- 머리 정보와 꼬리 정보는 메모리 조각을 일종의 양방향 연결 리스트로 만들어 병합을 빠르게 한다.
