## 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

### 3.6.1 메모리 풀 대 범용 메모리 할당자
- malloc은 표준 라이브러리 계층에 속하지만, 메모리 풀은 응용 프로그램 내부에 구현된다.
- 특정 상황에서는 메모리 풀이 최적의 성능을 내지만, 다른 상황에서는 범용성이 떨어질 수 있다.
- 메모리 풀 기술은 상황에 따라 사용 여부와 효과가 달라진다.

### 3.6.2 메모리 풀 기술의 원리
- 메모리 풀은 한 번에 큰 메모리 조각을 요청해 풀을 만들고, 그 안에서 할당과 해제를 자체적으로 관리한다.
- 필요에 따라 추가로 메모리 조각을 요청할 수 있고, 사용이 끝난 메모리는 풀에 반환한다.
- 메모리 풀은 운영 체제나 표준 라이브러리를 거치지 않고 프로세스 내부에서 동작한다.

### 3.6.3 초간단 메모리 풀 구현하기
- 매우 단순한 메모리 풀은 미리 큰 메모리 영역을 할당해 두고, 요청이 들어올 때마다 하나씩 꺼내 쓰는 방식이다.
- 사용이 끝나면 다시 풀에 반환하며, 구조가 단순해 구현이 쉽다.

### 3.6.4 약간 더 복잡한 메모리 풀 구현하기
- 다양한 크기의 메모리 조각을 관리하려면 여유 조각의 위치를 연결 리스트 등으로 기록해야 한다.
- 포인터를 사용해 현재 여유 메모리 조각의 위치를 관리하며, 더 복잡한 상황에 대응할 수 있다.

### 3.6.5 메모리 풀의 스레드 안전 문제
- 메모리 풀을 여러 스레드가 동시에 사용할 때 직접 잠금(lock) 보호를 적용하면 스레드 간 안전하게 사용할 수 있다. 
  - But 성능 저하와 잠금 경합 문제를 일으킬 수 있다.
- 각 스레드에 대해 전용 메모리 풀을 두면 잠금 문제를 근본적으로 해결할 수 있다. 이때 스레드 전용 저장소(thread local storage)를 활용해 각 스레드가 자신만의 메모리 풀을 갖도록 한다.
- 스레드 전용 저장소를 사용하면 스레드가 종료된 후에도 메모리가 계속 남아있는 문제가 발생할 수 있다. 이 메모리가 다른 스레드에 의해 사용되지 않도록 주의해야 한다.
