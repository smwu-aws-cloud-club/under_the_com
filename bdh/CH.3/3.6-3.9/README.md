
# 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

지금까지 살펴본 `malloc` 함수는 **범용 메모리 할당자**이다.  
어떠한 상황에서도 사용할 수 있도록 설계되었지만, 특정 상황에 최적화되어 있지는 않다.

반면 **메모리 풀(memory pool)** 은 특정 사용 패턴을 전제로  
애플리케이션이 직접 메모리 할당 전략을 설계·구현하는 기술이다.

---

## 3.6.1 메모리 풀 vs 범용 메모리 할당자

첫 번째 차이는 **소속 계층**이다.  
`malloc`은 표준 라이브러리의 일부로, 시스템 전반을 고려해 설계된 반면  
메모리 풀은 **응용 프로그램 내부 구현**이다.

두 번째 차이는 **사용 대상과 목적**이다.  
범용 메모리 할당자는 복잡하지만 다양한 상황을 지원하고,  
메모리 풀은 특정 상황에서만 사용되지만 성능을 극대화할 수 있다.

### malloc과 메모리 풀 비교

| 구분 | malloc | 메모리 풀 |
| --- | --- | --- |
| 메모리 확보 시점 | 필요할 때마다 요청 | 미리 한 번에 확보 |
| 메모리 관리 주체 | 힙 메모리 관리자 | 애플리케이션 |
| 할당 방식 | 요청 시 동적 할당 | 준비된 블록 재사용 |
| 할당·해제 속도 | 상대적으로 느림 | 매우 빠름 |
| 실행 시간 예측성 | 낮음 | 높음 |
| 메모리 단편화 | 발생 가능 | 거의 없음 |
| 유연성 | 매우 높음 | 낮음 |
| 초기 설계 부담 | 적음 | 큼 |
| 메모리 낭비 가능성 | 비교적 적음 | 발생 가능 |
| 주 사용 분야 | 일반 애플리케이션 | 게임, 서버, 실시간 시스템 |

---

## 3.6.2 메모리 풀 기술의 원리

메모리 풀은 **한 번에 큰 메모리 덩어리를 확보**한 뒤,   그 위에서 자체적으로 메모리 할당과 해제를 관리하는 방식이다.

이를 통해 표준 라이브러리와 운영체제를 우회하고 특정 사용 패턴에 맞는 최적화를 수행할 수 있다.

예를 들어 서버 프로그램에서 요청마다 반복적으로 생성되는 객체가 있다면, 미리 객체를 생성해 둔 뒤 필요할 때 꺼내 쓰고  
사용이 끝나면 다시 풀에 반환하는 방식이 가능하다.

---

## 3.6.3 초간단 메모리 풀 구현 아이디어

아주 단순한 서버를 가정해 보자.

- 요청 처리 시 항상 동일한 구조체만 사용
- 미리 정해진 개수만큼 메모리를 확보
- 요청 처리 시 하나를 꺼내 사용 후 반환

이 경우 `malloc`/`free` 호출을 완전히 제거할 수 있다.

조금 더 복잡한 경우에는 요청 처리 도중에는 할당만 허용하고요청이 끝날 때 한 번에 모든 메모리를 해제하는 전략도 가능하다.

이처럼 **해제 시점을 통제**하는 것이 범용 할당자와의 핵심 차이다.

---

## 3.6.4 조금 더 복잡한 메모리 풀

여러 크기의 메모리를 지원하려면 여유 메모리 조각을 관리해야 한다.

- 모든 메모리 조각을 연결 리스트로 관리
- `free_ptr` 포인터로 현재 사용 가능한 메모리 위치 추적
- 메모리가 부족하면 `malloc`으로 새 블록 확보
- 새 블록 크기는 이전 블록의 2배로 확장

이 방식은 확장 비용을 줄이고 성능 예측성을 높인다.

---

## 3.6.5 메모리 풀과 스레드 안전성

메모리 풀에 단순히 락을 걸면 스레드 안전성은 보장되지만, 다수의 스레드가 동시에 접근하면 **락 경쟁**이 심해진다.

이를 해결하기 위해 일반적으로 **스레드마다 독립적인 메모리 풀**을 유지한다.

- 스레드 전용 저장소(TLS)에 메모리 풀 보관
- 스레드 간 경쟁 자체를 제거
- 고성능 서버에서 자주 사용되는 방식

---

## **3.7 대표적인 메모리 버그**

### **3.7.1 지역 변수의 포인터 반환하기**

지역 변수는 함수가 호출될 때 생성되는 스택 프레임에 저장된다. 함수 실행이 종료되면 해당 스택 프레임은 함께 제거되며, 그 안에 존재하던 지역 변수 또한 더 이상 유효하지 않게 된다. 이러한 지역 변수의 주소를 반환할 경우 반환된 포인터는 이미 사라진 메모리 영역을 가리키게 된다. 이를 **댕글링 포인터(dangling pointer)** 라고 하며, 이러한 포인터를 역참조할 경우 프로그램의 동작은 정의되지 않는다.

---

### **3.7.2 포인터 연산의 잘못된 이해**

포인터 연산에서 정수를 더하거나 빼는 동작은 바이트 단위 이동이 아니라 **포인터가 가리키는 자료형 단위 이동**이다. 즉, 포인터에 1을 더하면 해당 자료형 하나의 크기만큼 이동하게 된다. 따라서 포인터 연산 시 자료형의 크기를 직접 곱해서 이동시키는 방식은 의도하지 않은 메모리 접근을 유발할 수 있다.

---

### **3.7.3 문제 있는 포인터 역참조하기**

입력 함수와 같은 표준 라이브러리는 값을 저장할 메모리의 **주소**를 인자로 요구한다. 그러나 변수 자체를 전달하면 해당 값이 주소로 해석되어 예기치 않은 메모리 영역이 수정될 수 있다. 이러한 오류는 즉시 드러나지 않는 경우도 많아 프로그램의 안정성을 심각하게 해칠 수 있다.

---

### **3.7.4 초기화되지 않은 메모리 읽기**

동적 메모리 할당 함수는 메모리를 확보할 뿐 내부 값을 초기화하지 않는다. 초기화되지 않은 메모리를 읽거나 연산에 사용하면 이전에 사용되던 임의의 값이 포함될 수 있으며, 그 결과 프로그램의 동작은 예측할 수 없게 된다. 따라서 동적 메모리를 사용할 때는 반드시 명시적인 초기화 과정이 필요하다.

---

### **3.7.5 이미 해제된 메모리 참조하기**

한 번 해제된 메모리는 더 이상 해당 포인터를 통해 접근해서는 안 된다. 해제된 메모리 영역은 이후 다른 용도로 재사용될 수 있으며, 이 상태에서의 접근은 정의되지 않은 동작을 일으킨다. 이러한 오류는 간헐적으로 발생하는 경우가 많아 디버깅이 매우 어렵다.

---

### **3.7.6 배열 첨자는 0부터 시작한다**

배열의 인덱스는 0부터 시작하며, 크기가 n인 배열의 유효 인덱스 범위는 0부터 n-1까지이다. 이 범위를 벗어난 접근은 배열 뒤쪽의 메모리를 덮어쓰게 되며, 경우에 따라 메모리 할당자의 내부 관리 정보를 손상시킬 수 있다. 이는 프로그램의 비정상 종료나 예측 불가능한 오류로 이어질 수 있다.

---

### **3.7.7 스택 넘침**

버퍼의 크기를 검사하지 않는 입력은 스택 버퍼 오버플로우를 유발할 수 있다. 스택 프레임에는 함수의 반환 주소와 같은 중요한 정보가 저장되어 있으므로, 이러한 오버플로우는 단순한 오류를 넘어 심각한 보안 취약점으로 이어질 수 있다. 공격자는 이를 이용해 반환 주소를 조작하고 악성 코드를 실행시킬 수 있다.

---

### **3.7.8 메모리 누수**

메모리 누수는 동적으로 할당한 메모리를 더 이상 사용하지 않음에도 해제하지 않아 메모리가 계속 점유되는 현상을 의미한다. 이러한 누수가 반복되면 프로세스의 힙 영역은 점점 증가하게 되고, 결국 운영체제가 해당 프로세스를 메모리 부족 상태로 판단하여 강제 종료하게 된다.
특히 장시간 실행되는 서버 프로그램에서는  메모리 누수가 치명적인 문제로 작용한다.

---
## 📝Full Notes
https://delicate-dish-b60.notion.site/CH-3-3-6-3-9-2f5a4c0c4272803b8116ecf0aaed6038?source=copy_link
