# CPU 정리 노트 (README)

오늘날 프로그래머들은 추상화의 위력 덕분에 CPU를 몰라도 개발할 수 있다. 하지만 CPU의 동작 원리를 이해하는 것은 그 자체로 흥미롭고, 컴퓨터 시스템 전반에 대한 이해를 깊게 만든다.

---

# 4.1 이 작은 장난감을 CPU라고 부른다

## 4.1.1 위대한 발명

### 트랜지스터
- 전류의 크기를 조절하는 장치이다.
- 한 단자에 전류를 흘리면 나머지 두 단자에 전류가 흐르게 할 수도 있고, 흐르지 못하게 할 수도 있다.
- 본질은 스위치이며, 소프트웨어의 복잡한 기능도 결국 트랜지스터의 단순한 개폐 동작으로 구현된다.

---

## 4.1.2 논리곱, 논리합, 논리부정

### 1) 논리곱(AND)
- 두 조건이 **모두 참일 때만 참**이다.
- 하나라도 거짓이면 결과는 거짓이다.

| A | B | A ∧ B |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

### 2) 논리합(OR)
- 두 조건 중 **하나라도 참이면 참**이다.
- 둘 다 거짓일 때만 거짓이다.

| A | B | A ∨ B |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

### 3) 논리부정(NOT)
- 조건의 **참/거짓을 반대로 바꾼다.**

| A | ¬A |
| --- | --- |
| 0 | 1 |
| 1 | 0 |

AND, OR, NOT 세 가지 게이트만으로 모든 논리 함수를 표현할 수 있으며, 이를 **논리적 완전성**이라고 한다.

---

## 4.1.4 연산 능력은 어디에서 나올까?
논리 게이트를 조합하면 CPU의 핵심 능력인 연산을 설계할 수 있다. 가장 단순한 덧셈 회로는 XOR 및 OR 등을 조합해 2진 덧셈을 구현한다. CPU에서는 이러한 산술·논리 연산을 담당하는 모듈을 **ALU(Arithmetic Logic Unit)** 라고 한다.

---

## 4.1.5 신기한 기억 능력
연산만으로는 부족하며 회로는 정보를 기억할 수 있어야 한다. NAND 게이트를 조합하면 정보를 유지하는 기억 회로를 만들 수 있다. 다만 S, R 단자를 동시에 설정해야 하는 불편함이 있어, 입력 단자를 1개로 줄이고 **WE(Write Enable)** 단자를 추가하여 저장 여부를 제어할 수 있도록 개선할 수 있다.

---

## 4.1.6 레지스터와 메모리의 탄생
회로는 1비트를 저장할 수 있으며, 더 많은 비트를 저장하려면 동일한 회로를 복제해 붙이면 된다. 이러한 조합 회로를 **레지스터(register)** 라고 부른다. 더 많은 정보를 저장하고 주소를 통해 접근할 수 있도록 확장되며, 8비트를 1바이트로 규정하고 바이트마다 번호(주소)를 부여하면서 **메모리(memory)** 개념이 등장한다.

---

## 4.1.7 하드웨어 아니면 소프트웨어? 범용 장치
하드웨어는 요리사, 소프트웨어는 레시피에 비유할 수 있다. 하드웨어는 기본 기능만 제공하고, 다양한 기능은 소프트웨어가 조합하여 구현한다. 동일한 하드웨어라도 소프트웨어가 달라지면 완전히 다른 기능을 수행할 수 있다.

---

## 4.1.9 명령어 집합(Instruction Set)
- CPU가 이해하고 실행할 수 있는 명령어들의 규칙과 목록이다.
- 명령어 집합은 소프트웨어와 하드웨어가 만나는 인터페이스이며, 위에는 소프트웨어가 있고 아래에는 하드웨어가 있다.

---

## 4.1.10 회로에는 지휘자가 필요하다
CPU에서 지휘자 역할을 맡는 것은 **클럭 신호(clock)** 이다. 클럭이 변할 때마다 레지스터 상태(회로의 상태)가 갱신된다.  
클럭 주파수(clock rate)는 1초 동안 클럭이 몇 번 변하는지를 의미하며, 높을수록 CPU는 1초에 더 많은 작업을 수행할 수 있다.  
ALU, 레지스터, 클럭 신호를 갖춘 중앙 장치를 **CPU**라고 부른다.

---

# 4.2 CPU는 유휴 상태일 때 무엇을 할까?

작업 관리자에서 **System Idle Process**가 대부분 90~99%를 차지하는 경우가 있다. 이는 CPU가 “놀고 있는 시간”을 표현하기 위한 설계 결과이다. 운영체제는 우선순위 기반으로 프로세스를 대기열에 넣고 스케줄링한다.

---

## 4.2.3 대기열 상태 확인: 더 나은 설계
운영체제는 **대기열(queue)** 로 실행 가능한 프로세스를 관리한다. 준비 완료 큐가 비어 있다면 실행할 프로세스가 없어 CPU가 유휴 상태임을 의미한다. 하지만 매번 큐가 비었는지 검사하는 방식은 커널 코드에 예외 처리가 늘어나 복잡도가 증가한다. 이를 개선하기 위해 **감시자(sentinel) 노드**를 사용해 큐가 비는 상황 자체를 없애는 설계를 선택한다.

### System Idle Process(유휴 프로세스)
커널은 “할 일이 없을 때 수행할 작업”을 별도의 프로세스로 정의한다. 이것이 System Idle Process이며, 실행 가능한 프로세스가 없을 때 실행된다. 항상 준비 완료 상태이고 우선순위는 가장 낮으며, CPU를 쉬게 하거나 전력 절감과 관련된 처리를 수행한다.

---

## 4.2.4 모든 것은 CPU로 돌아온다
시스템에서 일어나는 모든 동작은 최종적으로 CPU가 수행한다. CPU는 실행할 작업이 전혀 없는 상황도 고려해야 하며, 이를 위해 **halt** 명령을 제공한다. `halt`는 CPU를 정지에 가까운 절전 상태로 두어 전력 소비를 줄이기 위한 명령이다.

### halt의 특징
- CPU를 절전 상태로 전환한다.
- 특권 명령어이므로 커널 모드에서만 실행 가능하다.
- `sleep` 등 프로세스 단위 중지와 달리, `halt`는 시스템에 실행 가능한 프로세스가 전혀 없을 때 CPU가 유휴 상태로 들어간다는 의미이다.

---

## 4.2.5 유휴 프로세스와 CPU의 저전력 상태
실행 가능한 프로세스가 없으면 스케줄러는 유휴 프로세스를 실행하며, 유휴 프로세스는 본질적으로 `halt`를 반복 실행하여 CPU를 저전력 상태로 만든다. 인터럽트가 발생하면 CPU는 깨어나고, 블로킹 상태 프로세스가 준비 완료 큐로 이동하면 정상 스케줄링이 재개된다.

---

## 4.2.6 무한 순환 탈출: 인터럽트
운영체제는 일정 시간마다 타이머 인터럽트를 발생시키며 CPU는 이를 감지해 인터럽트 처리 루틴을 실행한다. 특정 프로그램이 무한 루프에 빠져도 타이머 인터럽트로 인해 스케줄러는 실행 흐름을 제어할 수 있으며, 운영체제가 멈추는 문제는 발생하지 않는다.

---

# 4.3 CPU는 숫자를 어떻게 인식할까?

컴퓨터가 2진수를 사용하는 이유는 저수준 계층이 스위치 역할을 하는 트랜지스터로 구성되어 있기 때문이다.

## 1의 보수(One’s Complement)
1의 보수는 이진수의 모든 비트를 반전하여 음수를 표현하는 방식이다. 다만 +0과 -0이 동시에 존재하고, 덧셈에서 end-around carry 처리가 필요해 설계가 복잡해진다. 이러한 문제로 현대 시스템에서는 거의 사용되지 않는다.

## 2의 보수(Two’s Complement)
2의 보수는 1의 보수를 취한 뒤 1을 더해 음수를 표현하는 방식이다. 0이 하나만 존재하고, 덧셈/뺄셈을 동일한 회로로 처리할 수 있어 현대 CPU에서 표준적으로 사용된다. n비트에서 표현 범위는 `-2^(n-1)`부터 `2^(n-1)-1`까지이다.

---

# 4.4 CPU가 IF문을 만났을 때

CPU는 성능을 높이기 위해 **파이프라인** 구조를 사용한다. 하지만 if문은 분기 명령으로 변환되고, 분기 결과를 실행 전까지 알 수 없어 파이프라인에 공백이 생길 수 있다. 이를 해결하기 위해 CPU는 **분기 예측(branch prediction)** 을 수행하며, 예측이 맞으면 성능이 유지되지만 틀리면 파이프라인 플러시로 성능 손실이 발생한다.

정렬된 배열처럼 조건 결과가 규칙적이면 예측 성공률이 높지만, 정렬되지 않아 조건 결과가 불규칙하면 예측 실패가 잦아져 성능이 크게 저하된다. 이러한 이유로 컴파일러는 `likely/unlikely` 같은 힌트를 제공하여 자주 실행되는 분기 경로를 최적화할 수 있도록 돕는다.

---

# 4.5 CPU 코어 수와 스레드 수 사이의 관계는 무엇일까?

CPU 성능을 이야기할 때 **코어 수**와 **스레드 수**는 자주 언급된다. 하지만 둘은 같은 개념이 아니며 역할이 다르다. 이를 이해하기 위해 “요리사와 요리” 비유를 사용할 수 있다.

## 4.5.1 레시피와 코드, 볶음 요리와 스레드
CPU는 기계 명령어(코드)에 따라 작업을 수행하며, 실제 실행 단위는 프로세스가 아니라 **스레드**이다. 운영체제 관점에서 CPU가 사용자 상태에서 실행하는 모든 명령은 항상 어떤 스레드에 속해 있다.

## 4.5.2 작업 분할과 멀티스레딩
작업을 여러 스레드로 나누면 GUI가 멈추지 않게 하거나, I/O로 블로킹되는 상황에서도 다른 스레드를 실행할 수 있어 전체 응답성을 유지할 수 있다. 특히 I/O가 많은 프로그램에서는 멀티스레딩이 중요하다.

## 4.5.3 다중 코어와 다중 스레드
다중 코어는 동시에 실행할 수 있는 스레드 수를 늘리지만, 코어 수만 늘린다고 성능이 자동으로 개선되지는 않는다. 계산 위주 작업은 대체로 코어 수와 유사한 스레드 수가 효율적이며, I/O나 동기화가 많은 작업은 코어 수보다 많은 스레드가 유리할 수 있다. 반대로 스레드가 지나치게 많으면 문맥 교환 비용(레지스터 저장/복원, 캐시 효율 저하, 스케줄링 오버헤드 증가)으로 인해 성능이 감소할 수 있다. 따라서 “적당한 스레드 수”는 환경과 작업 특성에 따라 달라지며, 측정과 테스트를 통해 결정해야 한다.

---
## Full Notes
https://delicate-dish-b60.notion.site/CH-4-CPU-4-1-4-5-2f6a4c0c42728017af16d1abff884f75?source=copy_link
