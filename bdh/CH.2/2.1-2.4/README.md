
# 2.1 운영체제, 프로세스, 스레드의 근본 이해하기

---

## CPU의 관점

CPU는 스레드, 프로세스, 운영체제와 같은 개념을 전혀 알지 못한다.  
CPU는 단지 **PC(Program Counter)가 가리키는 주소의 명령어를 실행**할 뿐이다.

---

## CPU 명령어 실행 과정

CPU가 알고 있는 동작은 다음 두 가지뿐이다.

1. **메모리에서 명령어를 하나 가져온다 (Fetch)**
   - CPU는 PC 레지스터를 통해 다음에 실행할 명령어의 *가상 주소*를 가져온다.
   - PC 레지스터는 CPU가 다음에 실행할 명령어의 주소를 저장한다.
   - 프로그램의 시작 지점은 일반적으로 `main()` 함수이다.
2. **명령어를 실행한 후 다시 1번으로 돌아간다**

---

### 세부적인 CPU 명령어 실행 사이클

![Instruction Cycle](https://www.learncomputerscienceonline.com/wp-content/uploads/2020/08/Instruction-Cycle-.jpg)

1. Fetch : 명령어 가져오기  
2. Decode : 명령어 해석  
3. Execute : 명령어 실행  
4. PC 증가  
   - PC는 기본적으로 순차적으로 증가한다.
   - 하지만 분기(if/else), 함수 호출과 같은 명령어를 만나면 실행 흐름이 동적으로 변경된다.
   - 최초 PC 값은 프로그램의 시작 지점(`main`)이다.

---

## 멀티태스킹 (Multitasking)

> **하나의 CPU가 여러 작업을 동시에 실행하는 것처럼 보이게 하는 기술**

CPU는 한 순간에 하나의 작업만 수행할 수 있다.  
하지만 프로그램 A를 실행했다가 잠시 중단하고, 프로그램 B를 실행하는 과정을 매우 빠르게 반복하면  
여러 프로그램이 동시에 실행되는 것처럼 보이게 된다.

이때 핵심 문제는 **어떻게 프로그램을 중단했다가 다시 이어서 실행하느냐**이다.

농구 경기에서 타임아웃 이후 다시 경기를 재개하려면  
선수들의 위치와 상황을 모두 기억해야 하듯,  
컴퓨터에서도 실행 상태를 저장해야 한다.

이때 저장되는 실행 상태를 **상황 정보(Context)** 라고 한다.

---

## 프로세스 (Process)

> **실행 중인 프로그램 + 그 실행을 유지하기 위한 모든 상태 정보**

<img width="423" height="383" alt="image" src="https://github.com/user-attachments/assets/5de941ca-22d4-455a-b93d-78f4723513a8" />


실행 중인 모든 프로그램은 실행 상태를 저장하기 위한 구조체를 가지며,  
이를 **프로세스(Process)** 라고 한다.

- 프로세스 덕분에 프로그램은 일시 중지와 재개가 가능하다.
- 모든 프로그램은 실행되면 프로세스 형태로 관리된다.

운영체제가 프로세스를 빠르게 전환해 주기 때문에,  
CPU가 하나뿐인 시스템에서도 여러 프로그램이 동시에 실행되는 것처럼 보인다.

---

## 운영체제 (Operating System)

> **하드웨어를 직접 다루지 않고도 프로그램을 실행하게 해주는 중간 관리자**

운영체제는 CPU–프로세스–스레드를 모두 연결하는 핵심 개념이다.

- 실행 파일을 메모리에 적재
- 프로세스를 생성·관리
- 멀티태스킹 구현

CPU 관점에서 보면:

- **CPU가 하는 일**  
  - PC가 가리키는 주소의 명령어 실행
- **운영체제가 하는 일**  
  - 실행 중인 프로세스의 PC, 레지스터, 스택 포인터를 저장
  - 다른 프로세스의 상태로 교체

> CPU는 계속 실행할 뿐이고,  
> **여러 프로그램이 동시에 실행되는 것처럼 “속이는 역할”을 운영체제가 담당한다.**

---

## 프로세스 주소 공간 (Process Address Space)

<img width="376" height="646" alt="image" src="https://github.com/user-attachments/assets/ed849651-c684-4ab9-9156-6002329ef820" />


- **코드(텍스트) 영역**
  - 컴파일된 기계 명령어 저장
  - 보통 읽기 전용
  - CPU가 실제로 명령어를 fetch하는 대상
- **데이터 영역**
  - 전역 변수, static 변수
- **힙 영역**
  - `malloc`, `new`로 할당된 동적 메모리
  - 낮은 주소 → 높은 주소 방향으로 성장
- **스택 영역**
  - 함수 실행 시 필요한 정보 저장
  - 매개변수, 지역 변수, 반환 주소, 레지스터 값
  - 높은 주소 → 낮은 주소 방향으로 성장

---

## 다중 프로세스 프로그래밍

> 하나의 프로그램을 여러 개의 프로세스로 나누어 실행하는 방식

- 프로세스는 서로 완전히 독립된 주소 공간을 가진다.
- 프로세스 간 통신은 IPC를 통해 이루어진다.

### 단점
1. 프로세스 생성 비용이 큼
2. 주소 공간이 분리되어 있어 통신이 복잡함

---

# 스레드 (Thread)

> **하나의 프로세스 안에서 실행되는 독립적인 실행 흐름**

프로세스는 진입 함수가 `main` 하나뿐이기 때문에 실행 흐름이 하나다.  
이 한계를 해결하기 위해 등장한 것이 **스레드**이다.

- 하나의 프로세스 안에 여러 실행 흐름 존재 가능
- 같은 주소 공간을 공유
- 통신 개념이 필요 없음

이 때문에 스레드를 **경량 프로세스**라고 부르기도 한다.

---

## 다중 스레드 (Multi-Threading)

- 단일 코어 환경에서도 가능
- 운영체제 계층에서 관리됨
- 각 스레드는 **자신만의 스택**을 가진다

---

## 스레드 풀 (Thread Pool)
<img width="520" height="198" alt="image" src="https://github.com/user-attachments/assets/d99e7725-b039-4d63-8b0f-974acd8d17c8" />


> 스레드를 매번 생성하지 않고, 미리 만들어 재사용하는 구조

- 작업은 큐(Queue)에 저장
- 스레드는 작업을 가져와 처리
- 작업 완료 후 종료되지 않고 대기 상태로 복귀

> **스레드는 한정된 개수만 유지하고, 작업은 큐에 쌓는다**

---

## 스레드 풀의 스레드 수

작업 유형에 따라 적절한 스레드 수가 다르다.

### CPU 집약 작업
- 연산 중심 작업
- 스레드 수 ≈ CPU 코어 수

### 입출력 집약 작업
- 대부분의 시간이 I/O 대기
- 적절한 스레드 수 공식: ```스레드 수 = N × (1 + WT / CT)```

  
---

# 2.2 스레드 간 공유되는 프로세스 리소스

## 스레드 전용 리소스
- PC
- 레지스터
- 스택
- 스택 포인터

## 스레드 공용 리소스
- 코드 영역
- 데이터 영역
- 힙 영역
- 열린 파일 정보

---

# 2.3 스레드 안전 (Thread Safety)

> 여러 스레드가 동시에 실행되어도 결과가 항상 올바른 상태를 유지하는 성질

핵심은 **스레드 전용 리소스와 공유 리소스를 구분**하는 것이다.

- 전용 리소스 → 안전
- 공유 리소스 → 동기화 필요

---

# 2.4 코루틴 (Coroutine)
<img width="1238" height="664" alt="image" src="https://github.com/user-attachments/assets/a21bd41a-5ecb-4c55-a4d4-3edb00c494c0" />

> 실행을 멈췄다가 다시 이어서 실행할 수 있는 가벼운 작업 단위

- suspend / resume 가능
- 실행 상태를 저장
- 비동기·동시성 처리에 적합

코루틴이 저장하는 정보:
1. CPU 레지스터 상태
2. 함수 실행 상태 (스택 프레임)

---

## 요약

- CPU는 명령어만 실행한다.
- 운영체제는 실행 흐름을 관리한다.
- 스레드는 성능을, 프로세스는 안정성을 제공한다.
- 스레드 안전의 핵심은 **공유를 통제하는 것**이다.
---
## 📝Full Notes
https://delicate-dish-b60.notion.site/CH-2-2e1a4c0c427280c09388e5de9aab8e6e?source=copy_link



