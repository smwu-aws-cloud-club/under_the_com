# 2.5 콜백 함수를 철저하게 이해한다.

## 콜백 함수(call back function)

: 내가 직접 실행하는 것이 아니라, 다른 함수에 맡겨두었다가 특정 시점에 다시 불리는 함수

- 함수 전체를 전달하는 것이다. 콜백함수는 실행 가능한 코드인 함수로서 일반적인 다른 함수와 다르지 않다.
- <img width="600" height="259" alt="image" src="https://github.com/user-attachments/assets/6b3a3421-241e-4673-becc-3c19115bebff" />


프로그래머는 `int a=10;` 과 같은 변수를 사용해 코드의 재사용성을 높인다. 이와 같이 함수도 변수로 사용할 수 있는데 이 함수를 ‘콜백 함수’라고 부른다. 일반적으로 콜백함수는 내가 직접 구현을 하지만 호출하는 것은 내가 아니다. 보통은 내가 참조하는 외부 모듈(OS, 라이브러리, 프레임워크)에서 해당 함수를 호출하게 된다.

예를 들어 서드 파티 라이브러리를 예로 들면, 내가 서드 파티 라이브러리의 함수를 호출할 때, 콜백 함수를 같이 전달하면 서드 파티 라이브러리의 함수는 내가 작성한 콜백 함수를 호출해준다. 서드 파티 라이브러리에 콜백 함수를 지정해야하는 이유는 서드 파티 라이브러리의 작성자가 특정 시기에 어떤 작업을 수행해야하는지 모르기 때문이다. 여기서 주의할 점은 콜백 함수와 주 프로그램은 같은 계층에 있지만, 우리는 해당 콜백 함수를 작성할 책임만 있을 뿐 직접 호출은 하지 않는다는 점이다.

콜백 함수가 호출되는 시점은 이벤트를 처리할 때 유용하다. 일반적으로 시스템에서 네트워크 데이터 수신이나 파일 전송 완료와 같은 이벤트가 발생할 때, 이에 대응하는 콜백 함수를 등록할 수 있다. 이 관점에서 보면 콜백함수는 event handler이기에 이벤트 중심 프로그래밍(event-driven programming)에 적합하다.

---
<img width="760" height="491" alt="image" src="https://github.com/user-attachments/assets/d58a02de-ac38-447c-a36f-a88662a7abce" />

## 동기 콜백 (synchronization callback)

가장 익숙한 콜백으로 블로킹 콜백(blockinig callback)이라고도 한다.

함수 A를 호출할 때 콜백 함수를 매개변수에 전달한다고 가정하면, 함수 A가 반환되기 전에 콜백 함수가 실행된다.

동기 콜백은 코드가 단순성과 가독성이 높아지지만, 효율성의 문제는 떨어지게 된다.

## 비동기 콜백 (asynchronization callback)

호출자와 피호출자가 각자의 스레드에서 병렬적으로 실행되는 것을 말한다. 즉, 호출 스레드가 콜백 함수 실행에 의존하지 않는다.

이번에도 함수 A를 호출할 때 콜백 함수를 매개변수에 전달한다고 가정하면, 함수 A의 호출이 즉시 완료되고 일정 시간이 지나면 콜백 함수가 실행된다. 이때, 주 프로그램은 다른 일로 바쁠 수 있으므로 콜백함수와 주 프로그램이 동시에 진행될 수 있다. 그래서 보통 콜백함수와 주 프로그램은 다른 스레드 또는 프로세스에서 실행된다.

비동기 콜백은 동기 콜백에 비해 다중 코어 리소스를 매우 잘 활용하는 편이다. 비동기 콜백은 입출력 작업에서 자주 볼 수 있으며, 웹서비스처럼 동시성이 높은 시나리오에 적합하다.

### 비동기 콜백의 문제 : 콜백 지옥
<img width="1400" height="653" alt="image" src="https://github.com/user-attachments/assets/c523ed3f-9a88-4197-b645-e3d7a41f5839" />


서버에서는 작업을 처리할 때, 사용자에게 전달되는 데이터 서비스는 하나씩 호출되는 것이 아니라 수십개 또는 수백개 호출될 때가 대부분이다. 비즈니스 구성이 복잡한 경우 비동기 콜백으로 처리하면 콜백 지옥에 빠질 가능성이 높다.

다음 사진과 같이 끝도 없는 콜백에 빠지게 된다.

비동기 콜백의 효율성, 동기 콜백의 단순성과 가독성를 모두 함께 누리기 위해서는 어떤걸 해야할까? 정답은 코루틴이다. 이는 추후에 더 보겠다.

---

# 2.6 동기와 비동기를 철저하게 이해한다.

## 동기 호출

동기 호출 방식은 프로그래머에게는 굉장히 익숙한 방식이다.

동기호출은 호출자와 피호출자는 동일한 스레드에서 실행이 된다. 하지만 비교적 특수한 상황이 있는데 바로 입출력 작업이다.

입출력 작업을 할 때, read 함수를 호출하여 파일을 읽는다고 가정해보자. 최하단 계층은 system call로 OS에 호출을 보내게 된다. 이 때, OS는 파일 읽기 작업을 위해서 호출 스레드를 일시 정지시키며, 커널이 디스크 내용을 읽어오면 일시 중지되었던 스레드가 다시 깨어난다. 이를 **블로킹 입출력**이라고 한다.

여기서 많이 헷가리는 지점이 동기호출과 블로킹 입출력이 같다고 생각하는 것이다. *동기호출은 반드시 블로킹 입출력이 아니고, 블로킹 입출력은 반드시 동기 호출이다. 동기 호출의 종류 중에 블로킹 입출력이 있는 것이다.* 블로킹 입출력은 단지 호출자와 파일을 읽는 코드가 다른 스레드에서 실행되고 있을 뿐이다.

따라서 동기 호출은 호출자와 수신자가 같은 스레드에서 실행 중인지 여부와는 관련이 없다.

> **동기 ≠ 블로킹**
>
> - 동기/비동기 → **논리적 흐름**
> - 블로킹/논블로킹 → **스레드 상태**

| 구분 | **동기 호출 (Synchronous Call)** | **블로킹 I/O (Blocking I/O)** |
| --- | --- | --- |
| 핵심 개념 | **호출 순서의 문제** | **대기 방식의 문제** |
| 초점 | 함수 호출과 **응답 타이밍** | I/O 요청 후 **스레드의 상태** |
| 기준 질문 | “호출한 쪽이 결과를 **기다리나**?” | “요청 중에 스레드가 **멈추나**?” |
| 호출 결과 | 호출이 끝나야 다음 코드 실행 | I/O 완료 전까지 스레드가 정지 |
| 실행 흐름 | 순차적 | 정지 후 재개 |
| 스레드 상태 | 실행 중 (RUNNING) | 대기 상태 (BLOCKED / WAITING) |
| CPU 사용 | CPU는 계속 점유 가능 | CPU 사용 ❌ |
| 운영체제 관점 | 제어 흐름(컨트롤 플로우) | 스케줄링 / 스레드 관리 |
| 주 사용 예 | 일반 함수 호출, RPC | 파일 읽기, 소켓 read |
| 대표 예시 | `result = func()` | `read()`, `accept()` |

## 비동기 호출

일반적으로 디스크의 파일 읽고 쓰기, 네트워크 데이터 송수신, DB 작업 등 시간이 많이 걸리는 입출력 작업을 백그라운드 형태로 실행한다. 이 경우 호출자가 블로킹 되지 않고 피호출자는 즉시 반환되기 때문에 호출자는 즉시 다음 작업을 실행할 수 있다.

비동기 호출일 때, 작업 완료 시점 처리 방식에는 2가지 상황이 있다.

- 호출자가 실행 결과를 전혀 신경쓰지 않을 때 : 콜백 함수를 사용할 수 있다.
- 호출자가 실행 결과를 반드시 알아야할 때: 알림 작동 방식을 사용한다. 이 경우 결과처리는 호출 스레드에서 한다.

## 동기 호출 · 비동기 호출 · 콜백 비교표

| 구분 | **동기 호출 (Synchronous Call)** | **비동기 호출 (Asynchronous Call)** | **콜백 (Callback)** |
| --- | --- | --- | --- |
| 본질 | **호출 방식** | **호출 방식** | **응답 전달 방식** |
| 핵심 질문 | “결과를 **기다리나**?” | “결과를 **나중에 받나**?” | “결과를 **누가 호출해주나**?” |
| 호출 후 흐름 | 호출 지점에서 멈춤 | 즉시 반환 후 다음 코드 실행 | 이벤트 발생 시 실행 |
| 제어권 | 호출한 쪽이 유지 | 시스템/이벤트 루프 | 호출 대상이 실행 |
| 응답 처리 | 반환값으로 직접 받음 | 이벤트/콜백/Promise 등 | 함수로 전달받음 |
| 실행 순서 | **순차적** | **비순차적** | 사전 등록 → 나중 실행 |
| 스레드 점유 | 보통 유지 | 점유하지 않음 | 점유하지 않음 |
| 블로킹 가능성 | ⭕ 가능 | ❌ 불가 | ❌ 불가 |
| 주요 사용 | 일반 함수, RPC | I/O, 네트워크 | 비동기 결과 처리 |
| 대표 언어 예 | C, Java 기본 호출 | JS, async API | C 함수 포인터, JS 함수 |

> 동기/비동기 = “언제 결과를 받느냐”
>
> **콜백 = “결과를 어떻게 받느냐”**
>
> 콜백은 **동기/비동기의 대체 개념이 아니라 비동기 호출에서 결과를 받는 방법 중 하나이다.**

---

# 2.7 아 맞다! 블로킹과 논블로킹도 있다
<img width="804" height="412" alt="image" src="https://github.com/user-attachments/assets/34d87077-5090-4083-af12-47dd2cd8a86d" />

블로킹과 논블로킹은 **프로그래밍에서 함수를 호출할 때 주로 사용된다.**

함수 A가 함수 B를 호출할 때, 함수 B를 호출함과 동시에 OS가 함수 A가 실행 중인 스레드나 프로세스를 일시 중지시킨다면 함수 B에 대한 호출방식은 블로킹 방식이며, 그렇지 않다면 논블로킹 방식이다. 블로킹 호출 핵심은 스레드 또는 프로세스가 일시 중지되는 것이다.

## 블로킹

일반적으로 블로킹은 **입출력 작업과 밀접한 관련이 있다**. 디스크 입출력을 예로 들 수 있다. 일반적으로 디스크가 하나의 트랙 탐색 입출력 요청을 완료하는 데에는 밀리초(ms) 단위의 시간이 소요된다. 반면 CPU의 클럭 주파수는 이미 기가헤르츠(GHz) 단위에 도달해 있기 때문에, CPU가 단순히 하나의 입출력 작업을 기다리는 것은 자원 낭비가 된다.

운영체제는 CPU 자원을 최대한 효율적으로 활용하기 위해 각 스레드 간에 CPU 사용 시간을 적절히 분배해야 한다. 이것이 바로 **블로킹 입출력 방식이 필요한 핵심적인 이유이다**. 그 결과, 시간이 오래 걸리는 입출력 작업이 포함된 경우 호출 스레드는 블로킹되며 일시 중지된다.

이를 비유하면, 피자 가게에 직접 방문하여 피자를 주문한 뒤 가게 안에서 기다리는 상황에 해당한다.

이때 호출 스레드가 일시 중지되지 않은 상태로 입출력 작업을 시작할 수 있는 방식이 바로 **논블로킹 호출**이다.

## 논블로킹

논블로킹 호출의 예시로 네트워크 데이터 수신 함수인 `recv`를 들 수 있다. 이 함수를 호출할 때 운영체제는 스레드를 일시 중지시키지 않고, 함수 호출을 즉시 반환한다. 이후 호출 스레드는 자신의 작업을 계속 수행하며, 데이터 수신 작업은 커널이 처리하게 된다. 즉, **스레드의 작업과 운영체제의 입출력 처리가 병행되어 수행된다**.

이러한 방식이 바로 논블로킹 호출이며, 이와 같은 입출력 처리 방식을 **비동기 입출력이라고도 부른다**.

이를 비유하면, 전화로 피자를 주문한 뒤 집에서 다른 일을 하는 상황에 해당한다.

이 상황에는 두 가지 경우가 존재한다.

- **인내심이 강한 경우**  
  피자가 언제 도착할지에 집착하지 않고, 집에서 다른 일을 수행하는 경우이다. 이때 사용자의 작업과 피자를 굽는 행위는 서로 독립적으로 진행되므로 비동기에 해당한다. → **논블로킹 + 비동기**

- **인내심이 부족한 경우**  
  5분마다 전화를 걸어 피자가 언제 오는지 확인하는 경우이다. 이 경우 호출은 즉시 반환되므로 논블로킹이지만, 결과를 계속해서 확인하므로 논리적으로는 동기에 해당한다. → **논블로킹 + 동기**

**즉, 논블로킹 방식이라고 해서 반드시 비동기 방식인 것은 아니다.**

---

# 2.8 높은 동시성과 고성능을 갖춘 서버 구현

## 다중 프로세스

하나의 프로그램이 실행될 때, 여러 개의 **독립된 프로세스**를 생성하여 작업을 병렬로 처리하는 방식이다. 각 프로세스는 **자기만의 메모리 공간**을 가지며, 서로 직접 메모리를 공유하지 않는다. 리눅스 환경에서의 fork 방식을 예시로 들 수 있다.

**장점**
- 매우 간단하다.
- 하나의 프로세스에 문제가 생겨도 다른 프로세스에 영향을 미치지 않는다.
- 다중 코어 리소스를 최대한 활용가능하다.

**단점**
- 프로세스 간의 통신이 필요할 때, 난이도가 높다.
- 프로세스를 생성과 종료를 반복할 때, 시스템 부담을 증가시킨다.

## 다중 스레드

하나의 프로세스 안에서 여러 개의 **스레드**가 생성되어 작업을 나누어 처리하는 방식이다. 스레드들은 **코드, 힙, 전역 변수**를 공유한다.

**장점**
- 매우 가볍고, 시스템 부담이 적다.
- 파일 I/O 작업에도 스레드 중 일부가 블로킹되어 일시 중지되더라도 스레드 서로간의 영향이 적다.

**단점**
- 서로 같은 주소 공간을 공유하기 때문에 하나의 스레드에 문제가 발생하여 강제종료 되면 같은 프로세스 내에 있는 모든 스레드와 프로세스가 한번에 다 강제 종료된다.
- 여러 스레드가 동시에 공유 리소스의 데이터를 읽고 쓸 수 없다.

다중 프로세스와 비교했을 경우 스레드가 훨씬 유리하지만 동시 요청 수가 많은 경우에는 다중 스레드만으로 감당이 안된다.

---

## 이벤트 기반 프로그래밍(Event-Driven Programming)
<img width="800" height="600" alt="image" src="https://github.com/user-attachments/assets/29f72ca7-dce0-4d26-aef2-cbefd5b7d9f6" />


이벤트 기반 프로그래밍(Event-Driven Programming)이란 **프로그램이 미리 정해진 순서대로 실행되는 것이 아니라, 이벤트(Event)가 발생했을 때 그에 대응하는 코드가 실행되는 방식**이다.

### 이벤트(Event)

: 프로그램 외부 또는 내부에서 발생하는 **상태 변화나 신호**이다.

대표적인 이벤트는 다음과 같다.
- 사용자가 버튼을 클릭함
- 키보드를 입력함
- 네트워크 데이터가 도착함
- 타이머 시간이 만료됨
- 파일 입출력이 완료됨

이벤트는 “**무언가 발생했다**”라는 사실만을 알리는 신호이다.

### 이벤트 기반 프로그래밍의 핵심 구조

이벤트 기반 프로그래밍은 다음 3가지 요소로 구성된다.
1. **이벤트(Event)**: 발생한 사건 자체이다.
2. **이벤트 리스너 또는 핸들러(Event Handler)**: 특정 이벤트가 발생했을 때 실행될 함수이다.
3. **이벤트 순환(Event Loop)**: 이벤트를 감시하다가, 발생한 이벤트를 적절한 핸들러에 전달하는 역할을 한다.

즉, “이벤트가 발생하면 → 등록된 핸들러를 실행한다”라는 구조이다.

---

여기서 두가지의 문제가 존재한다.
1. 이벤트 소스에 관한 문제이다. 하나의 함수로 어떻게 여러 이벤트를 가져올 수 있을까?
2. 이벤트를 처리하는 handler 함수가 반드시 동일한 스레드에서 실행되어야할까?

첫번째 문제에 대한 해결책이 바로 입출력 다중화이다.

## 입출력 다중화(I/O Multiplexing)

**하나의 스레드(또는 소수의 스레드)가 여러 입출력 대상(I/O 소스)을 동시에 감시하고 처리하는 기술**이다.

입출력 다중화란 다음 질문에 대한 해답이다.
> “여러 소켓(파일, 파이프 등)을 동시에 기다려야 할 때 스레드를 여러 개 만들어야 하는가?”

입출력 다중화의 답은 **아니다**이다.
- 하나의 스레드가 여러 I/O 대상 중 **준비된 것만 골라서 처리**한다.

입출력 다중화는 다음 구조를 가진다.
1. 여러 파일 디스크립터(socket 포함)를 등록한다.
2. OS에게 “이 중에서 준비된 것이 있으면 알려달라”고 요청한다.
3. 준비된 I/O만 처리한다.
4. 다시 감시 상태로 돌아간다.

이 구조는 **이벤트 기반 프로그래밍**의 핵심이다. 이러한 방식으로 고성능, 고확장성을 가진다.

이와 같은 작동 방식 중 리눅스에서 가장 유명한 매커니즘은 `epoll`이다. `epoll`은 수천~수만 개의 소켓을 **효율적으로 감시**할 수 있도록 설계되었다.

`epoll`의 핵심 목표는 다음과 같다.
> “관심 있는 이벤트만, 준비되었을 때만, 빠르게 알려준다”

---

다음으로 두번째 문제에 대한 이야기이다.

이벤트 핸들러가 만약 입출력 작업이 없고, 처리 함수가 간단해서 소요 시간이 매우 짧다면 이벤트 순환과 이벤트 핸들러를 동일한 스레드에서 실행할 수 있다.

하지만 사용자 요청을 처리하는데 CPU 시간이 많이 소모된다면 다중 스레드의 도움이 필요하다. 이 때, 이벤트 핸들러는 독립적인 스레드에 배치된다. 이 때, 작업자 스레드를 스레드 풀로 구현하는 것도 가능하다.

지금까지는 요청 처리 과정에 입출력 작업이 포함되어있지 않았다. 이제 업그레이드시켜 입출력 작업을 포함시켜보자. 이때도 동일하게 2가지 경우가 있다.

1. 입출력 작업에 대응하는 논블로킹 인터페이스가 있는 경우: 이때는 논블로킹 인터페이스를 직접 호출해도 스레드가 일시 중지되지 않으며, 인터페이스가 즉시 반환되어 이벤트 순환에서 직접 호출이 가능하다.
2. 입출력 작업에 블로킹 인터페이스만 있는 경우: 이때는 어떤 블로킹 인터페이스도 호출하면 안된다. 호출한다면 이벤트 순환 스레드 자체가 멈추게 되고, 시스템이 중지된다. 따라서 블로킹 입출력 호출이 포함된 작업은 작업자 스레드에 전달해야한다.

## 코루틴: 동기 방식의 비동기 프로그래밍

이러한 과정들을 통해서 코루틴에서 handler가 실행되도록 할 수 있다. handler 함수의 코드 구현은 여전히 동기로 작성된다. 하지만 yield로 CPU 제어권을 반환하는 등 RPC 통신이 시작된 후 바로 반환된다는 점은 다르다.

여기서 중요한 점은 코루틴이 일시 중지되더라도 작업자 스레드가 블로킹 되지 않는다는 것이다. 코루틴이 일시 중지되면 작업자 스레드는 준비완료된 다른 코루틴을 실행하기 위해 전환되며, 일시 중지된 코루틴에 할당된 사용자 서비스가 응답한 후 그 처리 결과를 반환하면 다시 준비 상태가 되어 스케줄링 차례가 돌아오길 기다린다.

코루틴의 도움으로 동기 방식으로 프로그래밍하더라도 비동기 실행과 같은 효과를 얻을 수 있다.

---

# 2.9 컴퓨터 시스템 여행: 데이터, 코드, 콜백, 클로저에서 컨테이너, 가상머신까지

## 클로저(Closure)

**클로저(Closure)**는 **함수가 자신이 선언될 당시의 외부 변수(환경)를 기억하고, 함수가 끝난 뒤에도 그 변수에 접근할 수 있는 개념이다.**

일반적으로 함수가 실행을 마치면 그 함수 내부에서 사용하던 지역 변수들은 사라진다. 하지만 어떤 경우에는 함수 실행이 끝난 뒤에도 그 함수 내부 상태를 계속 유지하고 싶을 때가 있다. 이때 등장하는 개념이 **클로저**이다.

### 일반적인 경우
```js
function foo() {
  let x = 10;
}
foo();
// x는 여기서 접근 불가
```
### 클로저가 있는 경우
```js
function outer() {
  let x = 10;

  return function inner() {
    console.log(x);
  };
}

const f = outer();
f(); // 10
```
- `outer()`는 실행을 끝냈다.
- 하지만 `inner()`는 여전히 `x`에 접근한다.
- `x`는 **사라지지 않고 유지된다.**

---

## 컨테이너(Container)
<img width="1509" height="729" alt="image" src="https://github.com/user-attachments/assets/be719b4f-31b7-4180-90bd-314af674edd9" />


**애플리케이션과 그 실행에 필요한 모든 것을 하나의 실행 단위로 묶어,어디서나 동일하게 실행할 수 있게 만든 기술적 개념**이다. 컨테이너는 일종의 가상화 기술로 운영체제를 가상화한다.

한 문장으로 정리하면 다음과 같다.

> 컨테이너란, 애플리케이션을 OS 수준에서 격리해 실행하는 경량 실행 환경이다.

기존 애플리케이션 배포 방식에는 다음과 같은 문제가 있었다.

- 개발 환경에서는 정상 동작
- 서버 환경에서는 오류 발생
- 라이브러리 버전, OS 차이로 인한 문제
- 배포 환경마다 설정 불일치

이 문제를 한 문장으로 요약하면 다음과 같다.

> “내 컴퓨터에서는 되는데요?”

컨테이너는 이 문제를 해결하기 위해 등장했다.

컨테이너는 다음을 하나로 묶는다.

- 애플리케이션 코드
- 라이브러리
- 런타임
- 환경 변수
- 설정 파일

그리고 이를 **OS 커널을 공유한 채 격리된 공간**에서 실행한다.

---

## 가상머신(Virtual Machine,VM)

**하나의 물리적 컴퓨터 자원 위에, 완전히 독립된 ‘가상의 컴퓨터’를 소프트웨어로 만들어 실행하는 기술**이다.

한 문장으로 정리하면 다음과 같다.

> 가상 머신이란, 하드웨어를 가상화하여 여러 개의 독립된 운영체제를 동시에 실행하는 기술이다.

물리 서버를 그대로 사용하는 방식에는 다음과 같은 문제가 있었다.

- 서버 자원 활용률이 낮음
- OS마다 서버를 따로 운영해야 함
- 장애 격리가 어려움
- 테스트 환경 구성 비용이 큼

가상 머신은 이러한 문제를 해결하기 위해 등장했다.

가상 머신은 다음과 같은 구조로 동작한다.

```text
물리 하드웨어
   ↓
하이퍼바이저 (Hypervisor)
   ↓
가상 머신 (VM)
   ├─ Guest OS
   ├─ 라이브러리
   └─ 애플리케이션
```
핵심은 **하이퍼바이저(Hypervisor)**이다.

**하이퍼바이저(Hypervisor)**는 물리 하드웨어 자원을 분할하고, 각 가상 머신에 할당하는 소프트웨어이다.

하이퍼바이저는 다음을 수행한다.

- CPU 가상화
- 메모리 가상화
- 디스크 가상화
- 네트워크 가상화
- 가상 머신 간 완전한 격리 제공

---

### 가상 머신 vs 컨테이너 비교

| 구분 | 가상 머신 | 컨테이너 |
| --- | --- | --- |
| 가상화 대상 | 하드웨어 | OS 커널 |
| OS 포함 | ⭕ (Guest OS 포함) | ❌ |
| 실행 속도 | 느림 | 빠름 |
| 이미지 크기 | GB 단위 | MB 단위 |
| 격리 수준 | 매우 높음 | 상대적으로 낮음 |
| 사용 목적 | 안정성, 보안 | 배포, 확장성 |

---
## 📝 Full Notes
https://delicate-dish-b60.notion.site/CH-2-2-5-2-10-2e8a4c0c427280088d89d77911909156?source=copy_link
