# 2.1 운영체제, 프로세스, 스레드의 근본 이해하기

## CPU의 관점

CPU는 **운영체제, 프로세스, 스레드** 같은 개념을 전혀 알지 못한다.  
CPU가 아는 것은 단 두 가지뿐이다.

1. **메모리에서 명령어 하나를 가져온다 (dispatch)**
   - CPU는 **PC(Program Counter) 레지스터**를 사용해 다음에 실행할 명령어의 *가상 주소*를 가져온다.
   - 프로그램의 시작 지점은 보통 `main()` 함수이다.
2. **명령어를 실행한 뒤 다시 1번으로 돌아간다**

즉, CPU는 다음 루프만 수행한다.

``fetch → execute → fetch → execute → …``

---

## 멀티태스킹 (Multitasking)

CPU는 **한 번에 단 하나의 일만 실행**할 수 있다.  
그럼에도 여러 프로그램이 동시에 실행되는 것처럼 보이는 이유는,  
작업을 아주 빠르게 **번갈아 실행**하기 때문이다.

> 📌 **멀티태스킹**
>
> 하나의 CPU가 여러 작업을 동시에 하는 것처럼 보이게 만드는 기술

<img width="423" height="383" alt="image" src="https://github.com/user-attachments/assets/e99675be-a983-4016-9689-fbba8a544d13" />


---

## 프로세스 (Process)

프로그램을 중단했다가 다시 실행하려면 **실행 상태 저장**이 필요하다.  
이를 위해 실행 중인 모든 프로그램은 다음 정보를 담는 구조체를 가진다.

- 레지스터 상태
- 프로그램 카운터
- 메모리 정보 등

이 구조체를 **프로세스**라고 한다.

-> 프로세스 덕분에 프로그램은 **중단 / 재개 / 전환**이 가능하다.

---

## 운영체제 (Operating System)

운영체제는 다음 역할을 수행한다.

- 실행 파일을 메모리에 적재
- 프로세스를 생성·관리
- 멀티태스킹 구현

운영체제의 등장으로 프로그래머는 실행 파일을 수동으로 관리할 필요가 없어졌다.

---

## 프로세스 주소 공간

프로세스는 다음과 같은 메모리 구조를 가진다.

- **코드(텍스트) 영역**: 컴파일된 기계 명령어 (읽기 전용)
- **데이터 영역**: 전역 변수, static 변수
- **힙(Heap) 영역**: 동적 할당 메모리 (`malloc`, `new`)
- **스택(Stack) 영역**: 함수 호출 스택

<img width="376" height="646" alt="image" src="https://github.com/user-attachments/assets/1cef0ae2-88b5-4443-9717-3142b2c0d935" />


---

## 다중 프로세스 프로그래밍

> 하나의 프로그램을 여러 개의 **프로세스**로 나누어 실행하는 방식

- 각 프로세스는 **완전히 독립된 주소 공간**
- 프로세스 간 직접 메모리 접근 불가
- **IPC(프로세스 간 통신)** 필요

---

# 스레드 (Thread)

프로세스는 진입 함수가 `main()` 하나뿐이므로 실행 흐름이 하나다.  
이를 확장해 **여러 실행 흐름**을 허용한 것이 **스레드**다.

> **스레드**
>
> 하나의 프로세스 내부에서 실행되는 독립적인 실행 흐름

---

## 스레드의 특징

- 하나의 프로세스 안에 여러 스레드 가능
- 스레드 간 **주소 공간 공유**
- 별도의 IPC 없이 데이터 공유 가능
- 그래서 스레드를 **경량 프로세스**라고 부르기도 한다

스레드를 생성할 때는 반드시 **진입 함수(start routine)**를 지정해야 한다.

---

## 다중 스레드와 스택

함수 실행 시 다음 정보가 **스택 프레임**에 저장된다.

- 매개변수
- 지역 변수
- 반환 주소

따라서:
- **각 스레드는 자신만의 스택 영역**을 가진다
- 하나의 프로세스 안에 스레드 수만큼 스택이 존재한다

---

# 스레드 활용

## 1. 긴 작업 (Long Task)

- 처리 시간이 긴 작업
- 전용 스레드 생성
- 구조가 단순

## 2. 짧은 작업 (Short Task)

- 네트워크 요청
- DB 쿼리
- 처리 시간이 매우 짧음

### 문제점
1. 스레드 생성/종료 비용 큼
2. 스택 메모리 과다 사용
3. 스레드 전환 비용 증가

-> 해결책: **스레드 풀(Thread Pool)**

---

# 스레드 풀 (Thread Pool)

> 스레드를 필요할 때마다 생성하지 않고,  
> **미리 만들어 두고 재사용하는 구조**

<img width="520" height="198" alt="image" src="https://github.com/user-attachments/assets/4585fe7f-b209-4cb2-939b-81a4c86ff69e" />


## 핵심 아이디어

> 스레드는 **한정된 개수만 유지**하고  
> 해야 할 일은 **큐에 넣어 처리한다**

---

## 구조

- **작업 큐(Queue)**: 처리 대기 작업
- **생산자(Producer)**: 작업 제출
- **소비자(Consumer)**: 작업 처리 스레드

---

## 동작 흐름

1. 프로그램 시작 → 스레드 N개 생성
2. 작업 요청 발생 → 큐에 추가
3. 대기 스레드가 작업 획득
4. 작업 완료 → 스레드는 종료되지 않고 대기

-> **스레드는 계속 재사용된다**

---

## 동기화와 상호배제

작업 큐는 **공유 자원**이므로 동기화가 필요하다.

- **동기화(Synchronization)**  
  여러 스레드의 실행 순서와 타이밍을 맞추는 것
- **상호배제(Mutual Exclusion)**  
  공유 자원을 한 순간에 하나의 스레드만 사용하게 하는 것

---

# 2.2 스레드 간 공유되는 프로세스 리소스

## 스레드 전용 리소스
- 스택 영역
- PC 레지스터
- 스택 포인터
- 레지스터 정보

## 스레드 공유 리소스

### 1. 코드 영역
- 기계 명령어 저장
- 모든 스레드 공유
- 읽기 전용

### 2. 데이터 영역
- 전역 변수 단일 인스턴스
- 한 스레드의 변경이 전체에 영향

### 3. 힙 영역
- 포인터만 알면 모든 스레드 접근 가능

### 4. 스택 영역 (주의 ⚠️)
- 논리적으로는 스레드 전용
- 구현상 완전 격리는 아님
- 포인터 획득 시 다른 스레드 스택 접근 가능

---

# 링크(Linking)

## 정적 링크
- 모든 라이브러리가 실행 파일에 포함
- 실행 시 추가 작업 없음

## 동적 링크
- 실행 파일에 라이브러리 미포함
- 실행 시 라이브러리 적재
- 힙과 스택 사이의 공유 영역에 배치
- 모든 스레드가 공유

---

# 2.3 스레드 안전(Thread Safety)

> 여러 스레드가 동시에 실행돼도  
> 결과가 항상 올바른 상태를 유지하는 성질

### 문제 원인
- Race Condition
- Data Corruption
- 재현 불가 버그

---

## 스레드 안전 구현 시나리오

1. **스레드 전용 리소스만 사용**
2. **공유 리소스 접근 시 동기화 적용**

공유 리소스:
- 힙
- 데이터 영역
- 코드 영역

->  Lock, Semaphore 등으로 보호

---

# 2.4 코루틴(Coroutine)

> 실행을 멈췄다가 다시 이어서 실행할 수 있는  
> 가벼운 작업 단위

<img width="1238" height="664" alt="image" src="https://github.com/user-attachments/assets/633a4b1b-875c-4e70-a8d3-173b1b94667f" />


## 특징

- 실행 상태 저장 가능
- 반환 이후 재개 가능
- 마지막 중단 지점부터 실행
- 비동기·동시성 처리에 강함

### 저장되는 상태
1. CPU 레지스터 정보
2. 함수 실행 상태 정보

-> 주로 **스택 프레임**에 저장됨

---

## 요약

> 📌 스레드 안전 구현의 핵심은  
> **스레드 전용 리소스와 공유 리소스를 구분하는 것**이다.
>
---
## 📝 Full Notes
https://delicate-dish-b60.notion.site/CH-2-2e1a4c0c427280c09388e5de9aab8e6e?source=copy_link

