## 3.1. 메모리의 본질, 포인터와 참조

<aside>

- ⭐‘값 복사’의 구현 방식 차이로 포인터 개념이 생겼다고 볼 수 있음.

- ⭐포인터의 위력은 주소를 조작(주소 연산;Pointer Arithmetic)하여 다른 주소의 데이터로까지 접근이 가능한 것에서 나온다.

</aside>

- 가장 작은 단위: 메모리 셀 - 0과 1만을 보관함.
    - 더 큰 숫자 등을 표현하기 위해 이를 8개씩 묶어 1byte로 지정.
- 포인터 = 메모리주소의 추상화
    - b=a와 같이 값이 동일한 것을 가리킨다면 직접 메모리 할당하는 대신 주소를 저장하는 것으로 대체함.
    
    ⇒ `변수 = 값 | 메모리 주소` 할당 가능함.
    
- 포인터와 참조
    - 공통점: 데이터 복사와 동일한 효과.
    - 차이점: 포인터는 값을 조작해서 다른 주소의 데이터로까지 접근을 허용하지만, 참조는 아니다.
    
    → 파이썬과 자바와 같은 언어는 포인터 대신 참조를 사용해 변수가 값을 저장하는 것처럼 보임.
    

## 3.2. 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?

<aside>
- ⭐가상메모리란 논리적 표현이며, 실제 메모리상으로는 조각나 중구난방으로 존재한다. 인터페이스 개념과 비슷한 것 같다.

</aside>

- 가상메모리
    
    ![image.png](attachment:7bd37b1d-e720-48df-a329-e37b5ea06e35:image.png)
    
    - 논리적 구분으로 스택/힙/데이터/코드 영역으로 나누어둔 것.
    - 실제 물리 메모리 내에서는 여러 chunk로 나뉘어 중구난방으로 존재. → 페이지 테이블로 가상메모리와 물리메모리를 사상시킨다.
        
        따라서 가상메모리는 페이지 테이블로 구현이 가능하다고 할 수 있다.
        

## 3.3. 스택 영역: 함수 호출은 어떻게 구현될까?

<aside>
- ⭐함수마다 자신의 정보를 저장한 스택 프레임을 가진다.

</aside>

- 함수 호출 단계는 stack의 선입후출 꼴이다.
- 프로세스의 스택 영역에는 함수의 stack frame이 쌓이는데, 이는 일반적인 stack과 달리 아래로 쌓인다. 함수 호출 깊이에 따라 메모리가 증가하는 방식이다.
- 함수 전환의 구현
    
    실행중이던 함수 = A; 다음에 실행할 함수=B
    
    1. 어디로 갈지 - [함수 점프] : 그다음 함수 B의 첫번째 명령어 주소
    2. 어디로 돌아올지 - [함수 반환] : 지금까지 실행한 함수 A의 그다음 명령어 주소
- stack frame에 담기는 것들
    - 매개변수는 실행 중이던 함수 A의 stack frame에 저장되고, B가 사용함.
        
        다만 CPU 내부 레지스터 수 < 전달 매개변수 수인 경우에 stack frame에 저장된다. 보통은 레지스터에 저장됨.
        
    - 반환값 및 지역변수
    - 레지스터 초기값; 실행하면서 CPU 레지스터에 담긴 정보
