# chap 03_3 정리 
26.01.21 update

## 03_3_1~3
* 스택 프레임(stack frame) (=호출 스택 call stack) : 프로세스의 스택 영역에 생성됨 
    * 프로세스 스택 영역의 높은 주소가 맨 위 -> 아래로 갈수록 낮은 방향으로 커짐 (위->아래로 쌓임)
        * 스택 영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가하고 호출이 완료될수록 감소함 
    * LIFO(last in first out)의 순서로 처리 

## 03_3_4~7
* 제어권이 이전될때 (함수 A->함수 B 호출시) 필요한 정보 2가지 -> 스택 프레임에 저장 
    1. 반환(return): 어디에서 왔는지에 대한 정보 
    2. 점프(jump): 어디로 가는지에 대한 정보
* 3.3.4 예시 참고: 
    * call 명령어 후 지정한 함수로 jump + call 명령어 다음에 위치한 주소를 스택 프레임에 넣음 
    * ret은 함수 A의 스택 프레임에 저장된 반환 주소로 점프하도록 전달하는 역할 => 함수 B의 실행 완료되면 바로 함수 A로 점프하여 계속 실행 가능 
* 매개변수 전달, 반환값도 스택프레임에 저장 (레지스터 부족시)
    * 함수 A가 함수 B 호출시: 함수 A는 매개변수를 상응하는 레지스터에 저장 -> 레지스터 수가 부족하면 나머지 매개변수는 스택 프레임에 넣음 (함수 A의 스택프레임에)
* 지역 변수도 레지스터 저장 가능하나, 부족하면 스택 프레임에 
    * 레지스터에 지역 변수 저장하기 전에 먼저 레지스터에 원래 저장되었던 초깃값을 꺼냈다 레지스터 사용 후 다시 그 초깃값 저장해야함 -> 이걸 스택 프레임에 저장함 

## 03_3_8 
* 스택 영역의 크기에는 제한이 있음 -> stack overflow 발생 가능 
    * 너무 큰 지역 변수 만들면 안됨
    * 함수 호출 단계가 너무 많으면 안됨 

### 추가로 찾아본 내용
* 매개변수가 너무 많아 레지스터에 저장되지 못한다는 정보는 어떻게 알 수 있는가? 
    * cpu 아키텍처, 호출 규약에 따라 달라질 수 있음 
        * 호출 규약?: 함수 호출 시 매개변수를 어디에 둘지, 반환값을 어디에 둘지 정해놓은 룰
    * 디버거, 어셈블리 코드, 컴파일러의 어셈블리 출력으로 알 수 있다 
        * 어셈블리 코드: 레지스터가 인자에 저장되는지(`mov %rdi`), 스택에 푸시되는지(`push`, `mov [rbp-XX]`,..).. 확인 가능 