# chap 03_7 정리 
25.05.08 update

## 03_7_1
* 지역 변수의 포인터 반환하기 
* 함수 실행 끝나면 해당 스택 프레임도 사라지기 때문에 -> 함수 호출 후 가리키는 포인터는 이미 없는 변수를 가리키게 됨 

## 03_7_2
* 포인터 연산의 잘못된 이해 
* 포인터 연산에서 1을 더하는 것은거 1바이트만큼 이동하는 것이 아니라, 단위 1개만큼 이동하는 것 
    * 데이터 형식이 int형이면 1을 더하는 것은 ==  4 바이트만큼 이동하는 것 
    * 포인터가 1024바이트 크기의 구조체를 가리킬때 1 더하는 것 == 1024바이트만큼 이동하는 것을 의미 

## 03_7_3
* 문제 있는 포인터 역참조하기 
* 서로 다른 메모리 영역 파괴할 수 있음 

## 03_7_4
* 초기화 되지 않은 메모리 읽기
* 힙 영역에서 동적으로 할당된 메모리가 항상 0으로 초기화한다고 잘못 가정되고 있음 
    * 실제로는.. 2가지 가능성이 존재 
    * 운영체제에서 반환한 메모리는 이전에 다른 프로세스에서 사용했을 수 있고, 비밀번호와 같은 민감한 정보가 포함되어있을 수 있음 
    * 보안을 위해 다른 프로세스에서 정보를 읽지 못하도록 운영체제가 메모리 반환하기 전에 0으로 초기화함 -> 수동으로 메모리 초기화해야함 (미리 0이라고 가정하면 안됨)

## 03_7_5
* 이미 해제된 메모리 참조하기
* malloc의 작업 상태에 따라 달라질 수 있음 -> 예측하기 어려움 

## 03_7_6
* 배열 첨자는 0부터 시작한다
* arr 배열 뒤 메모리를 i로 덮어쓰게 되어버림 
    * 배열 접근이 범위를 벗어나면 malloc 작업이 손상될 수 있음 

## 03_7_7
* 스택 오버플로우 
* 사용자 입력이 32바이트를 초과하지 않는다고 가정하는 상황에서, 초과하게 되면 스택 프레임 내에서 인접한 데이터를 파괴함 
* 스택 프레임에는 함수의 반환 주소처럼 중요한 정보가 들어 있어서 스택 버퍼 넘침은 문제를 일으킬 가능성이 높음 
    * 해커에 의해 넘치는 부분이 스택 프레임의 반환 주소를 덮어쓰게 됨 -> 해커가 심어둔 악성 코드를 실행하게 됨 


## 03_7_8
* 메모리 누수 
    * 자동 쓰레기 수집을 지원하지 않는 언어에서 흔히 발생함 
    * 프로그램이 메모리를 계속 요청하기만 하고 해제를 하지 않으면 프로세스의 힙영역이 계속 늘어남 -> 강제로 프로세스 종료됨 => `메모리 부족 강제 종료(out of memory killer) 기능`
* 문제를 특별히 분석할 수 있는 도구 
    * tcmalloc 
    * 2가지 구현 방식
        1. malloc, free의 사용상황을 추적하는 방법
        2. perf와 같은 도구 활용 -> 시스템 이벤트를 일으킨 함수의 호출 스택 정보 직접 추적 가능 