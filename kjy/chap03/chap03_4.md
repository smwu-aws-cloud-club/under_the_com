# chap 03_4 정리 
25.05.08 update

## 03_4_1
* 동적 메모리 할당과 해제: 직접 관리하는 특정 메모리 영역을 언제 요청, 얼마나 많은 영역을 요청할지 결정 후 할당하는 것
    * 함수의 호출 횟수와 상관없이 프로그래머가 해당 메모리 영역의 사용이 완료되었다고 확신할때까지 유효하게 유지됨 -> 이후 무효화됨 
    * => 프로그래머가 직접 제어할 수 있는 매우 큰 메모리 영역 필요 -> `heap 영역`   
* malloc() or new 예약어 사용하여 메모리 요청함 (c/c++)
* free() or delete 예약어 사용하여 해당 메모리 반환함 (c/c++)
* 프로그래머가 수명 주기를 결정할 수 있음 

## 03_4_2~5
* malloc 메모리 할당자 
* 메모리 할당자는 메모리 영역에 무엇을 저장할지까지 신경 쓰지 x 
* 사용 가능한 메모리 조각을 관리 -> 어떤 영역이 사용 가능한 메모리인지, 어떤 영역이 이미 할당된 메모리인지 구분할 필요 있음 => `linked list` 활용하여 구현 
    * 연결리스트, 메모리 사용 정보를 메모리 조각 그 자체와 함께 저장해야함 
* payload: 할당 가능한 메모리 조각
    * malloc() 호출 시 반환되는 메모리 주소가 여기서 시작됨
* header 정보 때문에 -> 힙 영역의 모든 메모리를 남김없이 할당하는 것은 불가능함 (일부분은 헤더 정보를 저장해야함)
    * 헤더 정보 추가에 따라 -> 전체 힙 영역을 쉽게 추적할 수 있음 (메모리 조각이 여유상태인지, 할당되었는지 확인..)
    * 마지막 비트: 0/1 
        * 메모리 할당자에서도 tail node를 알려주는 특수한 표시(sentinel) (마지막 4바이트 사용함)

## 03_4_6
### 할당 전략
1. 최초 적합 방식(First fit): 매번 처음부터 탐색하다가 가장 먼저 발견된 요구사항을 만족하는 항목을 반환 
    * 장점
        * 단순함 
    * 단점
        * 항상 제일 처음부터 탐색하므로 할당 과정에서 앞부분에 작은 메모리 조각이 많이 남을 가능성 높음 -> 다음 메모리 할당할때 더 많은 여유 메모리 조각을 탐색해야하는 문제 발생 
2. 다음 적합 방식(Next fit): 메모리를 요청할때 처음부터 검색하는 대신 적합한 여유 메모리 조각이 마지막으로 발견된 위치에서 시작됨 
    * 장점
        * 이론적으로 최초적합방식보다 더 빠르게 여유 메모리 조각 탐색 가능
    * 단점
        * 메모리 사용률은 최초 적합 방식에 미치지 못함 
3. 최적 적합 방식(Best fit): 사용 가능한 메모리 조각을 모두 찾은 후, 그 중 요구사항을 만족하면서 크기가 가장 작은 조각을 반환함 
    * 장점
        * 최초 적합 방식, 다음 적합 방식보다 메모리를 더 잘 활용함 
    * 단점
        * 메모리를 할당할 때 사용 가능한 모든 메모리 조각을 탐색해야하므로 최초 적합 방식, 다음 적합 방식보다는 느림 

## 03_4_7~9
* 필요한 메모리 조각보다 큰 메모리 조각이 반환되면 -> `fragmenatation(내부 단편화)` 발생 
    * 해결 방법: 분할하여 반환 후, 남은 뒷부분은 작은 크기의 새로운 여유 메모리 조각으로 만듦 
* 메모리를 free()로 해제 
    * 같이 인접한 메모리 조각이 비어있을때는 더 큰 메모리 조각으로 서로 `병합`해야함 
    * 메모리가 해제될 때 즉시 병합하는 방법
        * 간단함 
        * But 해제될때마다 병합하면 부담이 발생 
        * 실제 메모리 할당자는 거의 대부분 여유 메모리 조각 병합을 연기하는 전략 세우고 있음 
* 빠르게 이전 메모리 조각 정보를 얻는 방법: 메모리 조각 끝에 `footer`를 추가 
    * 메모리 조각을 일종의 암시적 양방향 연결리스트로 만듬(doubly linked list) 