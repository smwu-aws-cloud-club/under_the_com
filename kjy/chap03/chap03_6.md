# chap 03_6 정리 
25.05.08 update

## 03_6_1~2
* malloc()은 특정 상황에 맞게 최적화되어 있지 않기 때문에 자주 사용시 시스템 성능에 영향 미칠 수 있음 -> 메모리 풀 기술 대신 사용 
* 메모리 풀
    * 응용 프로그램의 일부
    * 특정 상황에서만 적용 가능
    * 특정 상황에서만 메모리 할당 성능을 최적화하기에 범용성이 매우 떨어짐 -> 특정상황에서만 높은 성능 발휘 
    * 한 번에 큰 메모리 조각을 요청하고 그 위에 자체적으로 메모리 할당/해제 관리 (표준 라이브러리, 운영체제 우회)
    * 특정 사용 패턴에 따라 추가 최적화도 가능 

## 03_6_3~4
* 모든 메모리 조각을 연결 리스트로 연결하고 포인터를 사용하여 현재 여유 메모리 조각의 위치 기록 가능 
* 메모리 부족 시, malloc에 새로운 메모리 조각 요청해야함 -> 새로운 메모리 조각은 항상 이전 메모리 조각의 2배여야함 (malloc에 메모리를 너무 빈번하게 요청하지 않기 위함)
* Free_ptr: 메모리 풀의 요유 메모리 조각의 시작 위치를 가리키는 포인터 
    * 빠르게 여유 메모리 조각 찾을 수 잇게 함 
* 요청 처리가 완료되면 그때 한번에 전체 메모리 풀을 해제함 

## 03_6_5
* 스레드 저장소를 사용하여 스레드 풀을 전용 저장소에 넣음 -> 각 스레드가 자신에게 속한 스레드 풀만 사용 가능해짐
* 문제 발생: 스레드 A의 실행이 완료된 후에도 다른 스레드에서 해당 메모리를 계속 사용한다면 해당 메모리는 스레드 A에 속해있음에도 스레드 B에서 해제해야함 -> 어떻게 해결? 

