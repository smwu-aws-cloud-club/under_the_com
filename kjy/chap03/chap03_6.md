# chap 03_6 정리 
26.01.27 update

## 03_6_1~2
* malloc()은 특정 상황에 맞게 최적화되어 있지 않기 때문에 자주 사용시 시스템 성능에 영향 미칠 수 있음 -> 메모리 풀 기술 대신 사용 
* 메모리 풀
    * 응용 프로그램의 일부
    * 특정 상황에서만 적용 가능
        * 특정 상황에서만 메모리 할당 성능을 최적화하기에 범용성이 매우 떨어짐 -> 특정상황에서만 높은 성능 발휘 
    * 한 번에 큰 메모리 조각을 요청하고 그 위에 자체적으로 메모리 할당/해제 관리 (표준 라이브러리, 운영체제 우회)
    * 특정 사용 패턴에 따라 추가 최적화도 가능 
        * 예시) 서버에서 사용자 요청 처리할 때마다 여러 종류의 객체를 생성해야 할 시 -> 자체 메모리 풀에 미리 객체를 생성해두는 것이 가능

## 03_6_3~4
* 초간단 메모리 풀 구현: 서버 프로그램에서 사용자 요청 처리 시 단 한종류의 객체(데이터 구조)만 사용 시, 미리 커다란 영역을 할당해두고 실제 사용할 때마다 하나씩 꺼내어 사용, 끝나면 반환 (수량은 실제 상황에 따라 직접 설정 가능)
    * but 특정 객체나 데이터 구조만 할당이 가능하다는 단점 => 간단한 예시이므로 
* 모든 메모리 조각을 연결 리스트로 연결하고 포인터를 사용하여 현재 여유 메모리 조각의 위치 기록 가능 
* 메모리 부족 시, malloc에 새로운 메모리 조각 요청해야함 -> 새로운 메모리 조각은 항상 이전 메모리 조각의 2배여야함 (malloc에 메모리를 너무 빈번하게 요청하지 않기 위함)
    * c++의 vector 컨테이너 확장 전략과 유사 
* Free_ptr: 메모리 풀의 요유 메모리 조각의 시작 위치를 가리키는 포인터 
    * 빠르게 여유 메모리 조각 찾을 수 잇게 함 
* 요청 처리가 완료되면 그때 한번에 전체 메모리 풀을 해제함 
    * free() 처럼 메모리 조각을 해제하는 기능 제공 x => 메모리 해제의 부담을 줄임 

## 03_6_5
* 멀티 스레드에서 스레드 안전을 어떻게 달성? 
    * 만약 잠금을 사용한다면 잠금 경쟁이 심화됨 -> 성능 저하 
    * 대신, **각 스레드 마다 메모리 풀을 유지**하여 스레드 간 경쟁 문제를 해소하자 
* 스레드 저장소를 사용하여 스레드 풀을 전용 저장소에 넣음 -> 각 스레드가 자신에게 속한 스레드 풀만 사용 가능해짐
* 문제 발생: 스레드 A의 실행이 완료된 후에도 다른 스레드에서 해당 메모리를 계속 사용한다면 해당 메모리는 스레드 A에 속해있음에도 스레드 B에서 해제해야함 -> 어떻게 해결? 

