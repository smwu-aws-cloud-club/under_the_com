# chap 05_4 정리 
26.02.11 update

## 05_4_1
* 명령어의 비순차적 실행 : 코드 작성한 순대로 기계 명령어가 실행되지 x 
    1. 기계 명령어 생성 단계: 컴파일 중에 명령어 재정렬
    2. CPU가 명령어 실행하는 단계: 실행 중에 명령어가 비순차적으로 정렬됨 
* -O2 gcc 컴파일러 옵션으로 붙이면 컴파일러가 코드 최적화함 
```c
asm volatile ("" ::: "memory");
```
* 위 코드를 추가하여 컴파일러에 명령어 재정렬하지 않도록 지시 가능 -> but 이것만으로는 비순차적 실행을 방지할 순 없음 (CPU가 명령어 실행 시에도 비순차적으로 실행될 수 있음)
<br>

* 필요한 피연산자가 아직 준비되지 않은 경우 CPU 대기 시간이 생기므로 비효율적 
    * 개선 방법: `비순차적 명령어 처리 (Out of Order Execution, OoOE)`
        * 기계 명령어 가져옴 
        * 명령어를 대기열에 넣고 명령어에 필요한 피연산자 읽음 
        * 명령어는 대기열에서 피연산자의 준비가 완료될때까지 대기. 이미 준비가 완료된 명령어가 먼저 실행 단계에 들어갈 수 있음 
        * 기계명령어 실행 시 실행 결과 대기열에 넣음 
        * 이전 명령어의 실행 결과가 기록될 때까지 기다렸다가 현재 명령어의 실행 결과를 기록 (명령어의 원래 실행 순서에 따라 유효한 결과 얻기 위함)
    * CPU, 메모리 사이 속도 차이 크기 떄문에 파이프라인에 slot 빈공간이 생겨버리므로 -> 이 빈공간을 미리 준비된 명령어로 메꾸어서 효율적으로 실행 속도 높이자 
    * 유의할점: 이 경우 CPU가 뒤의 명령어를 미리 실행할 수 있다는 점, 모든 CPU가 이 기능을 가지고 있진 않음 

## 05_4_2~3
* L1, L2 cache는 CPU의 코어마다 별도로 존재 + L3 cache, memory는 모든 코어가 공유 
* 캐시 갱신 & 일관성 유지 문제: 시간 많이 소모되고, 이 작업 전에 CPU는 반드시 대기 상태를 중지해야함 
    * 과정 최적화 위해 일부 시스템은 `store buffer` 등 대기열을 추가함 
    * 기록 작업이 있을 때 대기열에 직접 기록 (캐시 즉시 갱신 x)
    * cpu는 캐시가 갱신되기를 기다리지 않고 다음 명령어 계속 실행 가능 
* 비순차적 실행은 자기 자신 이외의 또 다른 코어가 해당 코어를 바라볼 떄만 나타나는 현상 
* 단일 스레드 환경에서 프로그래밍 시, 근본적으로 이 문제 신경 쓸 필요 x 
<br>

* 잠금 없는 프로그래밍(lock-free programming): 잠금을 통한 보호를 사용하지 않는 상태에서 다중 스레드의 공유 리소스를 처리하는 것 => 비순차적 실행을 신경 써야함 
* 다중 스레드의 공유 리소스 처리 시 무조건 lock 필요? -> no, CAS(Compare-And-Swap) 알고리즘 사용으로 해결 가능 (원자성 작업)
    * 실행되거나 되지 않는 2가지 상태만 존재, 중간 상태는 존재 x 
<br>

* `memory barrier`: 명령어는 비순차적으로 실행 가능하나, Memory barrier 기계 명령어를 통해 해당 스레드의 CPU 코어에 언행 일치하도록 (특정 코어를 다른 코어가 보았을때 순차적으로 보이도록, 비순차적으로 보이지 않도록) 명령을 내릴 수 있음 
    * LoadLoad, StoreStore, LoadStore, StoreLoad의 4가지 유형 존재 
1. LoadLoad 
    * Load 명령어가 부정 출발 상태로 먼저 실행되는 것을 방지 
2. StoreStore 
    * Store 명령어 실행 시 다음에 오는 Store 명령어가 부정 출발 형태로 먼저 실행되는 것 방지 
3. LoadStore 
    * 장벽 이전의 읽기(load) 작업이 완료되기 전에는 장벽 이후의 쓰기(store) 작업을 먼저 하지 말라 
4. StoreLoad
    * 쓰기 명령어 실행할때 cpu가 부정출발 형식으로 읽기 명령어 먼저 실행하는 것을 방지 (동기 작업)
    * storestore은 장벽이 실행된 후 다른 코어가 메모리 장벽 이전의 변수를 읽었을 떄 곧바로 최신 값 보장 x -> 갱신 순서와 코드 순서가 일치하는 것만 보장하므로 
* x86에서는 mfence 명령어를 storeload 메모리 장벽으로 사용 가능 

## 05_4_4~5
* 다중 스레드 프로그래밍 시 문제
    1. 공유 데이터에 대한 상호 배타적인 접근
    2. 스레드 간 동기화 문제
* `획득-해제 의미론(acquire-release semantics)`
    * 획득 의미론(acquire): 메모리 읽기 작업에 대한 것 -> Load 뒤에 있는 모든 메모리 작업은 Load 작업 이전에는 실행 불가능 
    * 해제 의미론(release): 메모리 쓰기 작업에 대한 것 -> store 앞에 있는 모든 메모리 작업은 이 store 작업 이후에는 실행 불가능 
* 이식성 높은 잠금 없는 프로그래밍 하고 싶을 때는: 언어 수준에서 제공하는 획득-해제론을 사용해야함 
    * 서로 다른 유형의 cpu에서 오는 명령어 집합의 차이를 메꾸는 데 도움을 줌 
    * p415 코드들 참고할 것 

## 05_4_6~9
* `weak memory model`: 거의 모든 유형의 명령어 재정렬 볼 수 있음 (ARM, Alpha..)
* `strong memory model`: x86 플랫폼은 StoreLoad 재정렬 하나만 있음 (자체적은 획득-해제 의미론이 있음)
* 잠금 없는 프로그래밍을 할때만 명령어 재정렬에 신경 쓰면 됨 
    * 잠금은 명령어 재정렬 문제를 자동으로 처리함 
    * 잠금을 요청하는 다른 스레드는 반드시 그 자리에서 대기해야함 
* spinlock: 해당 잠금이 사용된 후 잠금을 요청하는 스레드는 계속 잠금이 해제되었는지 여부를 반복적으로 확인 
* 잠금 없는 프로그래밍은 복잡한 리소스 경쟁 문제, ABA 문제를 처리해야하므로 코드 구현이 복잡함 
    * 잠금으로 보호하는 임계 영역이 너무 커서는 안됨
    * 경쟁 치열할 떄 상호 배제(mutex)로 상황 정보 전환 부담 증가 가능 
