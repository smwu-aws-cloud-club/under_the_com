# chap 02_7 정리 
26.01.14 update

## 02_07_1
* 동기: 의존관계 존재할 때 
* 비동기: 의존 관계가 존재하지 않고, 각자 자신의 작업을 실행할 수 있을 때 

* 블로킹: 함수 A가 B 호출 시, 함수 B가 호출됨과 동시에 운영체제가 함수 A가 실행중인 스레드 or 프로세스를 일시 중지 시키는 방식
* 논블로킹: 위의 경우에서, 중지시키지 않는 방식 

## 02_07_02~03
* 블로킹은 대부분 입출력과 관련이 있음 
    * OS는 CPU의 리소스를 최대한 활용할 수 있도록 각 스레드 간에 CPU 사용 시간을 효율적으로 할당해야함 
    * 호출 스레드가 일시 중지되지 않으면서 입출력 작업을 시작하는 방법은 -> 논블로킹 호출 사용 
* `논블로킹 호출/비동기 입출력(asynchronous input/output)`
    * 예) recv (데이터를 수신하는 함수)
        * 운영체제는 스레드를 일시 중지 시키는 대신 recv 함수를 즉시 반환
        * 이후 호출 스레드는 자신의 작업 계속 진행 
        * 데이터 수신 작업은 커널이 처리 
        * 데이터를 언제 수신했는지 확인하는 법
            1. 논블로킹 방식의 recv 함수 외에 결과를 확인하는 함수를 함께 제공 -> 해당 함수를 호출하여 수신된 데이터가 있는지 확인 가능 
            2. 데이터가 수신됟면 스레드에 메시지나 신호 등을 전송하는 Notification 
            3. recv 함수를 호출 시 데이터 수신 처리를 담당하는 함수를 콜백 함수에 담아 매개변수로 전달 가능(recv 함수는 당연히 콜백 함수 지원해야함)

* 논블로킹이 반드시 비동기를 의미하지 x 
    * 비동기지만 5분마다 확인하는 작업을 한다면.. (확인하는 작업만 하고 아무것도 안한다면)

## 02_07_05~
* 동기이자 논블로킹 상황 가능 (p167 코드 참고)
* => 논블로킹이더라도 전체적으로 반드시 비동기는 x (코드 구현 방식에 따라 달라질 수 있음)