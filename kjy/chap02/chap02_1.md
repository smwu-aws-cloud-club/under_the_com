# chap 02_1 정리 
25.03.25 update

## 02_1_1
* CPU는 `PC(Program Counter)`라는 레지스터에서 명령어를 가져와서(dispatch) 실행함
* 최초 PC 레지스터 값은 프로그램이 작성된 코드에 따라 설정됨 
* 소스 코드 -> 컴파일러 -> 실행 파일 -> 디스크 -> 메모리 복사 -> CPU
    * 메모리 복사 후 main함수에 해당하는 첫번째 기계 명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재 

## 02_1_2 
* 과거(1950~1960): 실행 파일을 수동으로 메모리 복사 후, main 함수에 해당하는 첫번재 기계명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재해야했음 
    * 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾아야함 
    * CPU 레지스터를 초기화하고 함수의 entry point를 찾아 PC 레지스터를 설정 
    * 단점
        * `Multi tasking` 불가능
        * 사용할 하드웨어를 직접 특정 드라이버(ex. 사운드 카드 드라이버)와 연결해야함 
        * 라이브러리를 직접 구현해야함 
        * interactive interface 직접 구현해야함 
* process, context 
    * 프로세스: 프로그램 실행 상태를 저장하고 복구할때 사용할 구조체 -> 모든 프로그램은 실행된 후 프로세스 형태로 관리됨 
* 현재: `운영체제(OS)`의 등장으로 수동으로 적재하거나 유지관리할 필요가 없어짐 

## 02_1_3 
* process address space 
    * code segment: 코드를 컴파일하여 생성된 기계 명령어가 저장됨
    * data segment: 전역 변수 등이 저장됨
    * heap segment: malloc 함수가 요청을 반환한 메모리가 여기에 할당됨 
    * stack segment: 함수의 실행 시간 스택 
* `다중 프로세스 프로그래밍(multi-process programming)`
    * 하나의 프로그램을 여러 개의 **프로세스(Process)**로 나누어 동시에 실행하는 병렬 프로그래밍 기법
    * 단점
        * 프로세스를 생성할때의 overhead
        * 프로세스마다 자체적인 주소 공간을 가지고 있음 -> IPC(inter-process communication; 프로세스간 통신) 복잡해짐 


## 02_1_4 
* 스레드: 자신이 속해있는 프로세스의 주소공간을 공유하여, 다중 프로세스 프로그래밍과 달리 훨씬 가볍고, 생성속도가 빠름(프로세스간 통신이 일어나지 않음) 
    * 스레드 == 경량 프로세스(light weight process) 
    * 다중 코어를 사용하여 CPU를 최대한 활용 가능해짐 (그렇다고 해서 무조건 다중 코어일 필욘 없음! 단일 코어도 됨)


## 02_1_5
* 프로세스 주소 공간에 각 스레드를 위한 스택 영역이 별도로 있어야함 

## 02_1_6
* 긴 작업(long task) : 매우 긴 시간동안 활동하는 작업
    * ex) Word
* 짧은 작업(short task) : 처리 시간이 매우 짧은 작업 
    * ex) 네트워크 요청, 데이터베이스 쿼리 등 
* 작업 시간이 필요한 시간이 짧고, 작업수가 엄청나게 많은 경우.. 
    * 요청이 들어올때마다 스레드를 생성한다면? (thread-per-request)
        * 단점: 
            1. 스레드의 생성, 종료에 많은 시간을 허비
            2. 스레드마다 각자 독립적인 스택 영역이 필요한데, 많은 수의 스레드 생성 시 메모리와 기타 시스템 리소스를 많이 낭비함 
            3. 스레드 수가 많으면 스레드간 전환에 따른 오버헤드 증가
    * -> 따라서 스레드 풀이 탄생


## 02_1_7 
* 스레드 풀: 스레드 여러 개를 미리 생성해두고 스레드가 처리할 작업이 생기면 해당 스레드에 처리를 요청 
* producer-consumer pattern
* 스레드풀의 스레드는 jobs queue에서 블로킹 상태로 대기 -> 생산자가 작업 대기열에 데이터를 기록하면 스레드풀의 스레드가 깨어남 -> 깨어난 스레드는 작업 대기열에 앞서 정의한 구조체를 가져온 후 구조체의 handle이 가리키는 handler function을 실행 

## 02_1_8
* 스레드 풀의 스레드 개수는 몇개여야하나? 
    * 너무 적을 시 -> CPU 최대한 활용 x
    * 너무 많을 시 -> 리소스 소비 많음 
    * 스레드 풀에서 처리해야할 작업
        * CPU 집약적인 작업(CPU intensive task) -> 스레드수=코어수 면 충분히 활용 가능
        * 입출력 집약적인 작업(Input/Output intensive task) -> 실제 상황을 기반으로 테스트하여 결정해야함 

