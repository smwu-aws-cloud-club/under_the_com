# chap 02_1 정리 
25.03.24 update

## 02_1_1
* CPU는 `PC(Program Counter)`라는 레지스터에서 명령어를 가져와서(dispatch) 실행함
* 최초 PC 레지스터 값은 프로그램이 작성된 코드에 따라 설정됨 
* 소스 코드 -> 컴파일러 -> 실행 파일 -> 디스크 -> 메모리 복사 -> CPU
    * 메모리 복사 후 main함수에 해당하는 첫번째 기계 명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재 

## 02_1_2 
* 과거(1950~1960): 실행 파일을 수동으로 메모리 복사 후, main 함수에 해당하는 첫번재 기계명령어를 메모리에서 찾아 그 주소를 PC 레지스터에 적재해야했음 
    * 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾아야함 
    * CPU 레지스터를 초기화하고 함수의 entry point를 찾아 PC 레지스터를 설정 
    * 단점
        * `Multi tasking` 불가능
        * 사용할 하드웨어를 직접 특정 드라이버(ex. 사운드 카드 드라이버)와 연결해야함 
        * 라이브러리를 직접 구현해야함 
        * interactive interface 직접 구현해야함 
* process, context 
    * 프로세스: 프로그램 실행 상태를 저장하고 복구할때 사용할 구조체 -> 모든 프로그램은 실행된 후 프로세스 형태로 관리됨 
* 현재: `운영체제(OS)`의 등장으로 수동으로 적재하거나 유지관리할 필요가 없어짐 

## 02_1_3 
* process address space 
    * code segment: 코드를 컴파일하여 생성된 기계 명령어가 저장됨
    * data segment: 전역 변수 등이 저장됨
    * heap segment: malloc 함수가 요청을 반환한 메모리가 여기에 할당됨 
    * stack segment: 함수의 실행 시간 스택 
* `다중 프로세스 프로그래밍(multi-process programming)`
    * 하나의 프로그램을 여러 개의 **프로세스(Process)**로 나누어 동시에 실행하는 병렬 프로그래밍 기법
    * 단점
        * 프로세스를 생성할때의 overhead
        * 프로세스마다 자체적인 주소 공간을 가지고 있음 -> IPC(inter-process communication; 프로세스간 통신) 복잡해짐 