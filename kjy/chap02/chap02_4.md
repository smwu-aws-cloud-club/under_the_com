# chap 02_4 정리 
26.01.07 update

## 02_4_1~5
* 코루틴과 일반함수의 차이 
    * 일반 함수는 반환된 후 프로세스 주소 공간의 스택 영역에 더 이상 어떤 함수 실행시 정보도 저장하지 않음 
    * 코루틴이 반환될 때는 함수의 실행 시 정보를 저장함 -> 실행이 멈추었던 시점에서 다시 실행할때 이 정보가 필요하기 때문 
* 사용자 모드(User mode)에서는 타이머 인터럽트를 위한 작동 방식이 없음 -> yield와 같은 예약어를 사용하여 명시적으로 지정해줘야함 
    * 코루틴은 사용자 상태 내에서 구현된 것이기 떄문에 코루틴을 사용자 상태 스레드로 해석 가능 (운영체제는 코루틴을 얼마나 생성하든 알지 못함)
* p126의 그림 비교 참고 
<br>

* 코루틴의 역사
    * 동시성을 가지는 프로그램을 작성하기 위해 등장 (스레드 없었음)

## 02_4_6
* 상태 정보 -> 스택 프레임에 저장됨 => 코루틴의 스택 프레임들은 힙 영역에 저장 
    1. CPU의 레지스터 정보
    2. 함수 실행 시 상태 정보 
* 스택 영역은 여전히 일반 함수의 스택 프레임을 보관하는데 사용됨 
* 이론적으로 메모리 공간이 충분하다면 코루틴 개수에 제한은 없음 
    * 코루틴 간 전환/스케줄링은 전적으로 사용자 상태에서 일어나기 때문에 OS 개입 필요 x 
    * 코루틴 간 전환 시 저장/복구되는 정보도 더 가볍기 때문에 효율성도 훨씬 높음 
* 코루틴은 프로그래머가 동기 방식으로 비동기 프로그래밍을 가능하게 함 