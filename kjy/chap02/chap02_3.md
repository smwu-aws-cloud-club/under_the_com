# chap 02_3 정리 
25.03.27 update

## 02_3_1 
* 다중 스레드 코드 -> 스레드 안전(thread safety)가 중요 
* 전용 리소스 사용하는 스레드는 스레드 안전 o 
* 공유 리소스-> 다른 스레드에 영향을 주지 않도록 하는 대기 제약 조건에 맞게 사용하면 스레드 안전 o

## 02_3_2
* `스레드 안전(thread safety)` : 코드가 스레드 몇개에서 호출되든 이 스레드들이 어떤 순서로 호출되든 간 상관없이 올바른 결과가 나오는 것 
* 공유 리소스, 전용 리소스 파악 필요 

## 02_3_3
* 스레드 전용 리소스: 함수의 지역 변수, 스레드의 스택 영역, 스레드 전용 저장소 
* 그외는 공유 리소스: 힙영역, 데이터 영역, 코드 영역 
    * 코드 영역은 read 전용이므로 신경x
* 공유 리소스를 사용하는 스레드는 반드시 순서를 따라야함 -> **lock, semaphore**와 같은 장치를 활용 

## 02_3_4~10
* 스레드 전용 리소스만 사용하기 -> 실행된 후 스레드의 스택 영역에서 관리 -> **무상태 함수(stateless function)**
* 함수 매개변수를 call by value인 경우는 스레드 스택 영역에 각 저장되므로 괜찮으나
* 매개변수에 포인터를 전달했을때 그 포인터가 가리키는 것이 전역 변수라면 -> 스레드 전용 리소스가 아니게됨 => lock과 같은 장치 활용하여 순서 부여해야만 스레드 안전 
* 스레드 안전을 달성하기 위해 어떤 것이 스레드 전용 리소스인지, 어떤 것이 스레드 공유 리소스인지 파악 필요 
    1. 스레드 전용 저장소(thread local storage)
    2. Read-only: 전역 리소스를 사용해야한다면 이를 읽기 전용으로 사용해도 되는지 확인 필요 
    3. atomic operation: c++의 `std::atomic` 형식의 변수처럼 원자성 연산은 도중에 중단되지 않음 
    4. mutual exclusion in synchronization: 한 번에 하나의 스레드만 공유 리소스에 접근할 수 있도록 스레드가 접근하는 공유 리소스 순서를 프로그래머가 직접 유지해야함 -> Mutex, spin lock, semaphore etc.. 
* os에 의존하지 않는 상황에서 직접 스레드를 구현하는 방법: 코루틴