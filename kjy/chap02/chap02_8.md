# chap 02_8 정리 
26.01.14 update

## 02_08_1
* `fork`를 통해 여러 자식 프로세스 생성 가능 
* 다중 프로세스 장점
    * 프로그래밍 간단하여 이해하기 쉬움
    * 개별 프로세스의 주소 공간은 서로 격리되어 있기 때문에 하나의 프로세스에 문제가 발생하여 강제 종료되더라도 다른 프로세스에는 영향 미치지 x
    * 다중 코어 리소스를 최대한 활용 가능 
* 다중 프로세스 단점
    * 각 프로세스의 주소 공간이 서로 격리되어있기 때문에 프로세스 간 통신 필요 시 어려움 
    * 프로세스 생성 시 부담이 상대적으로 크고, 프로세스의 빈번한 생성/조욜는 시스템 부담 증가시킴 

## 02_08_2
* 프로세스 생성에 따른 부담, 프로세스 간 통신 문제 -> 다중 스레드로 해결 가능 
    * 스레드는 주소 공간을 공유하므로 별도의 통신 작동 방식 필요 x 
    * 스레드 안전이 보장된다는 전제 하에 메모리 직접 읽어서 데이터 얻을 수 있음 
    * 생성에 따른 부담이 아예 없는게 아님! 높은 동시성을 가져야하는 서버의 경우 요청에 따라 수만 개 이상의 스레드 생성 시 -> 과도한 메모리 소비, 스레드 전환 시의 성능 손실 등의 성능 문제 발생 가능 
* 스레드는 같은 주소 공간을 공유하기 때문에 하나의 스레드에 문제가 발생하여 강제 종료되면 -> 같은 프로세스를 공유하는 모든 스레드, 프로세스가 한번에 강제 종료됨 
    * 여러 스레드가 동시에 공유 리소스의 데이터를 읽고 쓸 수 없음 -> thread safety 문제 발생 (반드시 상호 배제와 같은 작동 방식 필요)
* 사용자 규모가 크지 않은 경우 다중 스레드로도 충분히 처리 가능
    * but, C10K 문제: 동시 요청 수가 매우 많을 때에는 다중 스레드만으로 감당하기 어려움 
        * C10K? : 동시에 클라이언트 연결 1만개를 처리하는 네트워크 소켓 최적화 문제 

## 02_08_3
* 이벤트 기반의 동시성(event-based concurrency)를 이용한 이벤트 기반 프로그래밍(event-driven programming)
* event: 이 책에서 다루는 이벤트는 대부분 I/O에 관련된 것 (e.g., 네트워크 데이터의 수신 여부, 파일의 읽기 및 쓰기 가능 여부 등)
* 이벤트 처리하는 함수: event handler 
<br>

* 이벤트 루프 
    * 이벤트는 계속해서 발생할 수 있음 
    * 이 이벤트들을 계속 수신하고 반복적으로 처리해야함 
```c
while (true){
    event=getEvent(); //이벤트 수신 대기
    handler(event); //이벤트 처리
}
```
* 문제들
    * 이벤트 소스: getEvent()와 같은 함수 하나로 어떻게 여러 이벤트를 가져올지?
    * handler: 이벤트 처리하는 handler 함수가 반드시 이벤트 순환가 동일한 스레드에서 실행되어야 하는지? 
    * => 입출력 다중화(input/output multiplexing)으로 해결 

## 02_08_4
* 위에서 언급한 이벤트 소스 문제를 어떻게 해결할 것인가? -> 입출력 다중화(epoll)로 해결 
* 리눅스/유닉스에서는 모든 것이 파일로 취급됨 
    * 프로그램은 모두 file decriptor 를 사용하여 입출력 작업을 실행 
* 입출력 다중화: '소켓 서술자 10개를 감시하고 있다가, 데이터가 들어오면 알려주세요' -> `epoll` 
```c
//epoll 생성
epoll_fd=epoll_create(); 

//서술자를 epoll이 처리하도록 지정
Epoll_ctl(epoll_fd, fd1, fd2, fd3, fd4...);

while (1){
    int n=epoll_wait(epoll_fd);//getEvent함수와 역할이 동일함 

    for (i=0;i<n;i++){
        //특정 이벤트 처리
    }
}
```

## 02_08_5~6
* 위에서 언급했던 handler 함수가 반드시 동일 스레드에서 진행되어야 하는가? : reactor pattern
* 이벤트 핸들러 가정:
    1. 입출력 작업이 전혀 x
    2. 처리 함수가 간단해서 소요 시간 매우 짧음 
* 단일 스레드를 사용하고 있을때 만약 CPU 시간을 많이 소모하게 된다면 -> 응답 시간이 느려짐 (요청 시간이 늘어나고, 시스템의 다중 코어 활용 못함) => 다중 스레드 필요 
* 그림 2-67(p167) 참고
* 반응자 패턴 (reactor pattern)
    * 이벤트 핸들러는 이벤트 순환과 동일한 스레드에서 실행되지 않고 독립적ㅇ니 스레드에 배치됨 
    * 작업자 스레드(worker thread), 순환 스레드(event loop thread) 
    * 이벤트 순환은 요청을 수신하면 간단한 처리 후 바로 각각의 작업자 스레드에 분배 가능 
    * 다중 스레드를 이용한 병행 실행 -> 시스템의 다중 코어를 최대한 활용하여 요청 처리를 가속화 
    * 작업자 스레드를 thread pool로 구현하는 것도 가능 

## 02_08_7
* 요청 처리 과정에 입출력 작업도 포함된다면 -> 2가지 상황으로 나누어 생각
    1. 입출력 작업에 대응하는 논블로킹 인터페이스가 있는 경우 
        * 직접 논블로킹 인터페이스를 호출해도 스레드가 일시중지되지 않음 
        * 인터페이스가 즉시 반환됨 
        * -> 이벤트 순환에서 직접 호출하는 것이 가능 
    2. 입출력 작업에 블로킹 인터페이스만 있는 경우 
        * 이벤트 순환 내에서 절대로 어떤 블로킹 인터페이스도 호출하면 안됨 
            * 이벤트 순환 스레드가 일시 중지될 수 있음 -> 이벤트 순환 엔진이 멈추는 것 
        * 블로킹 입출력 호출이 포함된 작업은 작업자 스레드에 전달해야함 (다른 작업자 스레드와 독립적)
* p178의 그림 2-68 참고

## 02_08_8
* 서버는 일반적으로 RPC(remote procedure call)로 통신함 
    * 네트워크 설정, 데이터 전송, 데이터 분석 등 작업을 일반 함수를 호출하는 것처럼 네트워크로 통신할 수 있도록 함 
    * 모두 블로킹 호출임 
        * 코드가 이해하기 쉽고 명확함
        * but 블로킹 호출이 여러번 발생하면 스레드가 빈번하게 중단될 수 있고, CPU의 리소스를 최대한 활용하지 못할 가능성이 높음 -> RPC 호출을 **비동기 호출로 수정하자**
    * RPC 호출을 비동기 호출로 수정 시 
        * 호출 스레드를 블로킹하지 않으므로 함수가 즉시 반환됨 (but 사용자 응답에 대한 결과가 없을 수 있음)
            * 처리할 내용을 콜백 함수에 담아 RPC 호출에 포함시켜야함 
* 비동기 프로그래밍은 단순한 상황에서는 관리가 괜찮지만 사용자 서비스가 더 많아지는 등의 복잡한 상황에서는 관리가 어려움 
* => 비동기 프로그래밍의 효율성 + 동기 프로그래밍의 단순성을 결합한 기술은? => `코루틴`으로 해결 가능 

## 02_08_9
* handler 함수의 구현은 여전히 동기 
* `yield`로 CPU 제어권을 반환하는 등 RPC 통신이 시작된 후 적극적으로 바로 호출됨 
* RPC 호출 함수 or 네트워크 전송 함수를 수정해야 yield로 CPU 제어권을 반환할 수 있음 
* **코루틴이 일시 중지되더라도 작업자 스레드가 블로킹되지 않음**
    * 코루틴이 일시 중지 되면 작업자 스레드는 준비 완료된 다른 코루틴을 실행하기 위해 전환됨 
    * 일시 중지된 코루틴에 할당된 사용자 서비스가 응답한 후 그 처리 결과를 반환하면 다시 준비 상태가 되어 스케줄링 차례가 돌아오길 기다림 -> 이후 마지막으로 중지되었던 곳에서 이어서 계속 실행됨 
    * 동기 방식으로 프로그래밍되더라도 비동기 실행과 같은 효과 
* p183's 그림 2-72 참고
    * 이벤트 순환은 요청을 받은 후 구현한 handler 함수를 코루틴에 담아 스케줄링과 실행을 위해 각 작업자 스레드에 배포 
    * 작업자 스레드는 코루틴 획득 후 진입 함수인 handler 실행 시작 
    * 어떤 코루틴이 RPC 요청으로 능동적으로 CPU 제어권을 반환하면 작업자 스레드는 준비 상태인 다른 코루틴을 실행 
    * 코루틴이 블로킹 방식으로 RPC 호출을 하더라도 작업자 스레드는 블로킹되지 않기 때문에 시스템 리소스 효율적 사용 가능 

## 02_08_10 
* 스레드 = `커널 상태 스레드` 
    * 커널로 생성되고 스케줄링을 함 
    * 커널은 스레드 우선순위에 따라 CPU 연산 리소스를 할당함 
* 코루틴은 커널 입장에서는 알 수 없는 요소: `사용자 상태 스레드`
    * 코루틴이 얼마나 많이 생성되었든 커널은 관계없이 스레드에 따라 CPU 시간을 할당함 