# chap 04_2 정리 
26.01.28 update

## 04_2_1~3
* 운영체제는 프로세스에 우선순위를 할당하고, 이에 따라 scheduler가 스케줄링을 할 수 있또록 상응하는 대기열에 프로세스를 넣음 
* `if (queue.empty())` : 커널은 if 같은 예외 처리 구문으로 가득 -> 좀 더 나은 설계 필요 => 대기열을 가득 채워 스케줄러가 대기열에서 항상 실행할 수 있는 프로세스를 찾을 수 있도록 하기 
    * 감시자(sentinel) 노드: 별도의 NULL 판단 로직을 제거하여 코드 오류 가능성을 줄이고 구조를 깔끔하게 유지 가능
* 유휴 작업이라는 프로세스: 
    * 윈도의 'system idle process' 에 해당함
    * 시스템에 스케줄링 가능한 프로세스가 없을 때 스케줄러가 이 유휴 프로세스를 꺼내서 실행함 
    * 유휴 프로세스는 항상 준비 완료 상태에 있고, 우선순위는 가장 낮음 
<br>

* halt 명령어: cpu 내부의 일부 모듈을 절전 상태로 전환하여 전력 소비를 크게 줄임 
    * 일반적으로 이 명령어도 실행을 위해 순환에 배치함 -> 가급적 절전 상태를 유지하는 것이 목적 
    * 커널 상태에서 cpu로만 실행될 수 있음 
    * != suspend 명령어(프로세스 일시 중지 명령어)
* 컴퓨터 시스템이 유휴 상태일 때 halt 명령어를 실행한다 (=시스템 내 더이상 실행할 준비가 완료된 프로세스가 없다는 것)
```c
while (1)
{
    while(!need_resched()){
        cpuidle_idle_call();
    }
}
```
* cpuidle_idle_call은 최종적으로 halt 명령어를 실행 
* 실제로 커널은 유휴 프로세스를 구현할 때 많은 것을 고려 
    * 예시) 커널은 시스템 유휴 시간을 예측하고 어떤 수면 상태로 진입할지 결정해야함 : c3(깊은 수면 상태/deep sleep), c4(deeper sleep).. 


## 04_2_4
* `timer interrupt`: 운영체제는 일정 시간마다 타이머 인터럽트를 생성하고, cpu는 인터럽트 신호를 감지하고, 운영체제 내부의 인터럽트 처리 프로그램을 실행함 
    * 상응하는 인터럽트 처리 함수에서는 프로세스가 실행될 준비가 되었는지 판단하고, 준비가 되었다면 중단되었던 프로세스를 계속 실행함 
    * 준비되지 않았다면 프로세스를 일시 중지시키고, 스케줄러는 준비 완료 상태인 다른 프로세스를 스케줄링함 
    * 프로그램에 무한 루프가 있더라도 운영체제는 timer interrupt 통해 프로세스 스케줄링 제어 가능 
