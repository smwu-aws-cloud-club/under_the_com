# chap 04_7 정리 
25.05.21 update

## 04_7_1~2
* 1980s: 최대 용량이 64KB인 메모리 등장 -> 메모리 용량 대비 가격이 떨어지기 시작
* 80-20 법칙(80-20 rule) -> CPU는 약 80% 시간동안 명령어 집합의 기계 명령어 중 20%를 실행함 
    * 복잡 명령어 집합에서 비교적 복잡한 명령어 중 일부는 자주 사용되지 x 
    * 컴파일러를 설계하는 프로그래머는 고급언어를 더 간단한 기계 명령어의 조합으로 변환하는 경향 있음 
    * 마이크로코드를 제거하면 오히려 프로그램이 더 빠르게 실행됨, 트랜지스터 절약 가능
* 축소 명령어 집합(reduced instruction set): 
    * 명령어 자체의 복잡성
        * 복잡한 명령어 제거하고 대신 간단한 명령어 여러개로 대체 -> CPU 내부 마이크로코드 설계 필요 x -> CPU 제어 능력 향상됨 
    * 컴파일러: 컴파일러가 CPU에 대해 더 강력한 제어권을 가짐 
        * 축소 명령어 집합을 사용하는 CPU는 더 많은 세부사항을 컴파일러에 제공함 -> Relegate Interesting Stuff to Compiler (RISC)
    * LOAD/STORE 구조 
        * 축소 명령어 집합의 명령어는 레지스터 내 데이터만 처리 가능함 -> 메모리 내 데이터 처리 불가능 
        * 축소 명령어 집합에서는 LOAD/STORE 이외의 명령어는 메모리에 접근 불가능 

## 04_7_3
그림 4-33 예시
1. 복잡 명령어의 경우 
    * 가능한 적은 수의 기계 명령어로 가능한 한 많은 작업을 수행하는 것 
    * 복잡 명령어 집합의 CPU에는 MULT라는 기계 명령어가 있을 수 있음 
    * `MULT A B`
        * 메모리 주소 A의 데이터를 읽어 레지스터에 저장 
        * 메모리 주소 B의 데이터를 읽어 레지스터에 저장 
        * ALU가 레지스터 값을 사용하여 곱셈 연산 수행 
        * 곱셈 결과를 다시 메모리에 씀 
2. 축소 명령어 집합의 경우 
    * 일련의 간단한 명령어를 여러개 사용하여 작업을 완료 
    ```plaintext
    LOAD RA, A
    LOAD RB, B
    PROD RA, RB
    STORE A, RA
    ```
    * LOAD: 메모리에서 레지스터로 데이터를 적재 
    * PROD: 두 레지스터에 저장된 숫자의 곱셈 연산을 수행 
    * STORE: 레지스터의 데이터를 다시 메모리에 씀 
    * 축소 명령어 집합은 기계 명령어 4개 필요, 복잡 명령어의 경우 1개 필요 
    * 축소 명령어 집합을 사용하는 프로그램은 복잡 명령어 집합보다 더 많은 저장 공간이 필요하고, 프로그래머를 더 번거롭게 함 -> 이 작업을 컴파일러에 맡기고 컴파일러가 구체적인 기계 명령어를 자동으로 생성하게 함 

## 04_7_4 
* 축소 명령어 집합에서 생성된 기계 명령어들은 매우 간단 -> CPU 내에서 코드를 해석하는데 복잡한 하드웨어 구조 필요 x -> 더 많은 트랜지스터 절약 가능 -> 절약한 트랜지스터들을 CPU의 다른 기능에 활용 가능 
* 각 명령어가 간단 -> 실행 시간이 거의 모두 동일 => 이 경우 기계 명령어의 실행 효율 높이는 방법: 파이프라인 기술 사용 
* 파이프라인 기술
    * 기계 명령어 하나가 실행되는 시간을 단축하지는 x but 처리량을 늘릴 수 있음 
* 복잡 명령어 집합에서는 명령어 사이에 비교적 차이가 큼 -> 실행 시간이 고르지 않음 -> 파이프라인 방식 제대로 활용할 방법 x 
* 1세대 축소 명령어 집합 프로세서: 전체가 파이프라인 기반으로 설계 됨 
    * 일반적으로 5단계 파이프라인 기준으로 명령어 하나가 1~2클럭 주기로 실행됨 
    * but 동시대의 복잡 명령어 집합 프로세서는 명령어 하나 실행하는데 5~10클럭 주기 필요 

## 04_7_5
* x86은 복잡 명령어 집합을 기반으로 함 