# chap 04_6 정리 
25.05.15 update

## 04_6_1~2
* 명령어 집합(intruction set): 여러 가지 명령어가 포함되어 있음 
    * 명령어 집합은 프로그래머가 프로그래밍에 사용함 
    * 최초의 프로그램: cpu에 대응하는 어셈블리어로 직접 작성되었음 
    * 명령어 집합은 Cpu를 설명하는 데만 사용된다 
    * 서로 다른 형태의 CPU는 다른 유형의 명령어 집합을 가지고 있음 -> 명령어 집합의 유형은 프로그래머가 코드를 작성할 때 뿐만 아니라 cpu의 하드웨어 설계에도 영향을 미침 
    * CISC(Complex Instruction Set Computer; 복잡 명령어 집합 컴퓨터): 오늘날 데스크톱 pc와 서버에 공통으로 사용되는 x86 아키텍처는 복잡 명령어 집합에 기초를 두고 있음 

## 04_6_3~
* 의미상 간격(Semantic gap): 당시에는 함수 호출, 순환제어 등 고급언어의 개념과 이에 직접 대응하는 기계 명령어가 있어야한다고 생각했었음 -> 기계 명령어와 고급 언어 개념 간 차이를 줄여야만 한다! 
* 폰 노이만 구조: 오늘날의 컴퓨터는 기본적으로 폰 노이만 구조를 따름 
    * '저장 개념에서 프로그램과 프로그램이 사용하는 데이터에 어떤 차이도 업서야하며, 모두 컴퓨터의 저장 장치 안에 저장될 수 있어야한다' 
* 인텔 1103 메모리 칩의 출시: 컴퓨터 업계에 DRAM 시대의 서막을 알림. 
* 더 많은 프로그램을 적재하려면 기계 명령어를 반드시 매우 세밀하게 설계해서 프로그램이 차지하는 저장 공간을 줄여야함 
    * 만족해야하는 요구 사항 3가지 
        1. 하나의 기계 명령어로 더 많은 작업을 완료할 수 있으므로 프로그래머가 더 효율적으로 코드를 작성할 수 있게 해줌 
        2. 기계 명령어 길이가 고정되어 있지 않음 
        3. 기계 명령어는 밀도를 높여 공간을 절약하려고 고도로 encoding됨 
* 복잡 명령어 집합의 등장: 명령어를 사용한 편리한 프로그램을 작성하고 코드의 저장 공간을 절약해야 했기에 복잡 명령어 집합을 설계해야하는 필요성이 대두됨 
    * 문제 : 이 시기 cpu 명령어 집합은 모두 HARDWIRED 방식이었음 -> 명령어 인출, 명령어 해독, 실행 등 각 단계가 특정 조합회로로 직접 제어됨 
        * 명령어 실행하는데는 매우 효율적이지만, 유연성이 떨어짐 -> 명령어 집합 변경에 대응하기 어려움 
        * 새로운 명령어 추가하면 CPU 설계와 디버깅 복잡도가 높아짐 
        * 복잡 명령어 집합의 명령어는 길이가 고정되어 있지 않아 명령어에 복잡한 연산 등이 포함되면 문제가 더 악화될 수 있음 
* 마이크로 코드 등장: 대부분의 명령어에 포함된 연산을 더 간단한 명령어로 구성된 작은 프로그램으로 정의하고 이를 CPU 에 저장함 -> 모든 기계 명령어에 대응하여 전용 하드웨어 회로를 설계할 필요가 없음 
    * 문제: 마이크로 코드의 버그 수정은 일반 프로그램의 버그를 수정하는 것보다 훨씬 어려움, 마이크로 코드 설계가 트랜지스터를 매우 많이 소모함 