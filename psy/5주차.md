# 5주차 - 3장 마무리, 4.5장까지

날짜: 2026년 1월 28일
완료: No

# 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

## 3.6.1 메모리 풀 대 범용 메모리 할당자

`메모리풀` 특정 상황을 위해 자체적으로 메모리 할당 전략을 구현하는 방법

`malloc` 범용 메모리 할당자

### **차이점**

1. 메모리 풀은 응용 프로그램의, malloc은 표준라이브러리의 일부이다.
2. 사용 대상. 메모리 풀은 특정 상황에 최적화 되어있어서 보편성이 떨어진다.

## 3.6.2 메모리 풀 기술의 원리

한 번에 큰 메모리 조각을 요청받아서 자체적으로 할당, 해제를 관리한다. 프로그래머가 비즈니서 설계에 따라 메모리 풀에 객체를 미리 생성해두는 방식으로 추가적인 최적화가 가능하다.

## 3.6.3 초간단 메모리 풀 구현하기

메모리 풀에 한 종류의 객체만 지원한다면 사용할 땐 할당하고 끝나면 바로 반환한다.

더 확장해서, 크기가 서로 다른 여러 종류의 객체를 지원한다면 사용자 요청을 처리하는 동안에는 할당만 시켜두고 해제는 하지 않는다. 사용자 처리가 완료될 때, 한꺼번에 해제하여 부담을 최소화한다.

## 3.6.4 약간 더 복잡한 메모리 풀 구현하기

여러 종류의 객체를 지원하기 위해 여유 메모리 조각을 관리해야 한다. 모든 메모리 조각을 연결 리스트로 연결하고 마지막 노드에 포인터로 현재 여유 메모리 조각의 위치를 기록한다.

여유 메모리는 Free_ptr이라는 포인터가 있어서 빠르게 찾을 수 있다. 여유 메모리가 부족해지면 malloc으로 항상 이전 노드의 메모리 2배로 할당한다.  즉, malloc이 할당한 메모리 위에서 메모리 풀 구현 방식에 따라 자체 할당해주는 방식이다.

malloc으로 추가할당 하더라도 매번 해제하지 않고 사용자 요청 처리가 완료되면 한꺼번에 해제함으로써 부담을 최대한으로 줄인다.

## 3.6.5 메모리 풀의 스레드 안전 문제

메모리 풀 자체를 잠그면 대량의 스레드가 할당, 해제를 요청할 때 락 경쟁 문제가 심화된다. 경쟁 문제를 해소하기 위해 스레드 전용 저장소(TLS)에 스레드 풀을 저장하여 각 스레다그 자신이 속한 스레드 풀만 사용하도록 한다.

그러나, 스레드 풀의 생명주기가 요청한 스레드 자체를 넘어서는 문제가 발생할 수 있다.

TLS에 스레드 풀, 메모리 풀을 저장하면 스레드 풀 환경에서는 스레드의 생명주기가 요청이나 작업의 생명주기보다 길거나 짧아질 수 있기 때문에 객체가 아직 사용 중인데 차괴되거나 이미 끝난 요청을 해제할 제어 문제가 발생한다. 따라서 TLS는 접근 최적화 목적만 두고 생명주기 관리 도구로 사용하거나, 소유권이 필요한 리소스를 저장하면 안된다.

---

# 3.7 대표적인 메모리 관련 버그

## 3.7.1 지역 변수의 포인터 반환하기

함수에서 사용한 지역변수는 함수 실행이 끝나면 반환되고, 스택 프레임에도 없게 되므로 main 함수에서 포인터로 사용할 수 없다.

## 3.7.2 포인터 연산의 잘못된 이해

포인터 연산에서 1을 더하느 것은 1바이트 만큼 이동이 아니라, 포인터의 자료형 크기만큼 이동하는 것을 의미한다. 예를 들어, 포인터가 int형일 때, 1을 더하면 4바이트만큼 이동한다.

## 3.7.3 문제 있는 포인터 역참조하기

```json
int a;
scanf("%d",a);
```

scanf는 a값을 주소로 취급하여 표준 입력 값을 해당 주소에 쓴다. 위의 코드에서는 a 값이 고정되어 있지 않으므로 상황에 따라 여러가지 결과가 나온다.

1. a값이 코드영역이나 기타읽기전용 영역을 가리키는 포인터 값으로 해석되면 운영체제는 이 프로세스를 강제종료시킨다.
2. a값이 스택영역을 가리키는 포인터 값으로 해석되면 다른 함수의 스택 프레임이 파괴되어 프로그램 제어권을 잃게 된다.
3. a값이 힙영역 또는 데이터영역을 가리키는 포인터로 해석되면 프로그램이 동적으로 할당한 메모리가 파괴되어 프로그램 제어권을 읽게 된다.

## 3.7.4 초기화되지 않은 메모리 읽기

```json
void add(){
	int *a = (int*)malloc(sizeof(int));
	*a +=10;
}
```

위의 코드에서 힙 영역에서 동적으로 할당된 메모리가 항상 0으로 초기화 되지 않기 때문에 a에 10을 더할 수 없다.

malloc을 호출할 때는 다음의 사항을 주의해야 한다.

1. malloc은 여유 메모리 조각에서 반환할 주소를 찾는다. 이 메모리는 이미 사용되어있을 수도 있고, 그 경우 이전에 사용한 정보가 남아있을 수 있으므로 0이 아닐 수 있다.
2. malloc이 자체적으로 유지하는 메모리가 충분하지 않을 때 brk 같은 시스템 호출로 os에 메모리를 요청한다.  이 경우에는 메모리를 할당하기 때문에 0으로 초기화될 수도 있다.

## 3.7.5 이미 해제된 메모리 참조하기

```json
void add(){
	int *a = (int*)malloc(sizeof(int));
	...
	free(a);
	
	int b = *a;
}
```

해제된 a를 b가 참조하고 있따. 이 때, a가 가리키는 메모리에 어떤 값이 들어있는지는 다음과 같다.

1. a가 해제된 후 malloc으로 다시 할당하지 않았다면 a가 가리키는 값은 이전과 동일하다.
2. 이미 malloc으로 할당되었다면 a가 가리키는 메모리는 이미 덮어쓰기가 되었을 수 있으며, a를 참조한 값은 덮어쓰기가 된 데이터이다.

## 3.7.6 배열 첨자는 0부터 시작한다.

```json
void int(int n){
	int* arr = (int*)malloc(n * sizeof(int));
	
	for (int i=0; i<=n; i++){
		arr[i] = i;
	}
}
```

배열 크기를 n으로 초기화한 경우, for문으로 0 ~ n-1까지 반복 실행해야 한다. n까지 실행한 경우, malloc의 다음과 같은 작업에 따라 달라진다.

1. malloc이 arr이 반환한 메모리 자체가 n * sizeof(int)보다 크다면 문제가 발생하지 않는다.
2. n이 malloc이 사용하는 메모리라면 malloc 작업이 손상될 수 있다.

## 3.7.7 스택 넘침

```json
void buffer_overflow(){
	char buf[32];
	gets(buf);
	
	return;
}
```

사용자 입력이 32바이트를 초과하면 스택 프레임 내에 인접해 있는 데이터를 파괴한다. 함수 스택 프레임이 파괴되었을 때의 결과는 프로그램이 강제 종료되거나 갑자기 오류가 발생할 수 있다.

특히, 힙 영역에서의 오버플로우보다 스택 프레임은 함수의 반환 주소같이 중요한 정보가 들어있기 때문에 문제가 발생할 가능성이 훨씬 높다.

## 3.7.8 메모리 누수

```json
void memory_leak(){
	int *p = (int*)malloc(sizeof(int));
	return;
}
```

p 메모리는 해제되지 않고 프로세스 종료되기 때문에 메모리 누수가 발생한다. 누수가 쌓일 수록 프로세스의 힙 영역이 점점 늘어나다가 결국 유휴영역이 좁아지면서 메모리 부족 강제종료된다.

malloc이 메모리를 할당할 때, 힙 영역이 부족하면 page fault가 발생한다. 하지만 실제로는 프로세스에서 메모리 누수가 발생할 때 오류가 나는 경우가 훨씬 많다. 리눅스에서는 perf를 사용하여 이러한 시스템 이벤트를 발생시킨 함수의 호출 스택 정보를 추적 및 분석할 수 있다.

---

# 3.8 왜 SSD는 메모리로 사용할 수 없을까?

## 3.8.1 메모리 읽기/쓰기와 디스크 읽기/쓰기의 차이

메모리는 바이트 단위로 메모리 주소가 부여되어있다. cpu는 이 주소를 이용해 해당 내용을 직접 접근할 수 있다.

그러나, ssd는 조각 단위로 데이터를 관리하며, 조각의 크기는 매우 다양하다. 즉 바이트 단위 주소 지정 지원이 되지 않기 때문에 cpu가 ssd의 내용을 직접 접근할 수 없다.

## 3.8.2 가상 메모리의 제한

32비트 시스템의 최대 주소 지정 범위는 4gb이므로, 1tb 짜리 ssd를 메모리로 사용하더라도 프로세스는 4gb 이상의 메모리를 사용할 수 없다.

## 3.8.3 SSD 사용 수명 문제

SSD는 기록한 데이터의 누적 크기에 대한 사용 수명이 존재한다. cpu는 프로그램을 실행할 때 대량의 메모리 읽기, 쓰기 작업을 실행하는데 ssd를 메모리로 사용하면 ssd의 사용 수명에 의한 병목 현상이 발생할 수 있다. 메모리에는 이러한 문제가 없다

---

# 4. 1 이 작은 장난감을 CPU라고 부른다

## 4.1.1 위대한 발명

트랜지스터는 단자 한 쪽에 전류를 흘리면 나머지 단자 2개에 전류가 흐르게 하거나 흐르지 못하게 하는 간단한 기능을 수행한다.

## 4.1.2 논리곱, 논리합, 논리부정

트랜지스터로 다음과 같은 세 가지 회로를 만들 수 있다.

1. `논리곱 게이트` 스위치 2개가 동시에 켜질 때만 전류가 흐르고 등이 켜진다.
2. `논리합 게이트` 2개의 스위치 중 하나라도 켜져 있으면 전류가 흐를 수 있고 등이 켜진다.
3. `논리부정 게이트` 스위치를 끄면 전류가 흘러 등이 켜지지만, 스위치를 켜면 전류가 흐르지 않고 등이 꺼진다.

## 4.1.3 도는 하나를 낳고, 하나는 둘을 낳고, 둘은 셋을 낳으며, 셋은 만물을 낳는다.

3개의 논리 게이트를 가지고 모든 논리 함수를 표현할 수 있다. 이것으로 컴퓨더가 만들어졌다.

## 4.1.4 연산 능력은 어디에서 나올까?

cpu는 0과 1의 2진법만 알고 있으므로, 2진법으로 덧셈을 구현해보자.

- 0+0의 결과는 0이며 자리 올림수도 0이다.
- 0+1의 결과는 1이며 자리 올림수는 0이다.
- 1+0의 결과는 1이며 자리 올림수는 0이다.
- 1+1의 결과는 0이며 자리 올림수는 1이다.

이 때, 결과는 논리합 게이트, 자리 올림수를 논리곱 게이트로 이진수 덧셈을 구현할 수 있다.

## 4.1.5 신기한 기억 능력

부정 논리곱 게이트(논리곱 게이트와 논리 부정 게이트의 조합) 2개를 조합하면 회로에 1비트 정보를 저장할 수 있게 된다.

## 4.1.6 레지스터와 메모리의 탄생

부정 논리곱 게이트 2개의 조합을 여러번 겹치면 더 많은 비트를 저장할 수 있다. 이러한 조합을 레지스터라고 한다.

이처럼 더 복잡한 회로를 계속 구축하여 8비트가 1바이트가 되고, 각 바이트 별로 주소를 부여해 저장된 정보를 읽을 수 있는 메모리를 만들었다.

## 4.1.7 하드웨어 아니면 소프트웨어? 범용 장치

모든 연산 논리를 반드시 회로와 같은 하드웨어로 구성할 필요는 없다. 하드웨어는 변하지 않지만 소프트웨어는 변할 수 있기에 범용적인 하드웨어(컴퓨터) 위에서 각각의 소프트웨어를 실행시키면 더 많은 기능을 제공할 수 있다.

## 4.1.8 하드웨어의 기본 기술: 기계 명령

cpu는 덧셈과 같은 기본 연산 능력만 제공하고 소프트웨어에서 피연산자를 제공해 기능을 만든다. 그래서 cpu는 기본 연산 능력에 해당하는 명령어 집합으로 구성된다.

## 4.1.9 소프트웨어와 하드웨어 간 인터페이스: 명령어 집합

명령어 집합은 cpu가 실행할 수 있는 명령어와 각 명령어에 필요한 피연산자를 묶은 것이다. 명령어 한 개가 수행하는 작업은 매우 간단해서, 그 명령어를 서로 묶어서 하나의 고급 명령어를 만드는 것이다.

고급 명렁어를 cpu가 명령어 한개에 해당하는 것으로 변환하는 데에 필요한 것이 이전의 컴파일러이다.

## 4.1.10 회로에는 지휘자가 필요하다.

cpu 회로에서 연산으로 사용되는 부분, 저장으로 사용되는 부분을 관리할 필요가 있다. 회로의 각 부분을 함께 작업할 수 있도록 조정하거나 동기화하기 위해 클럭 신호를 사용한다.

클럭 신호는 전압을 변경할 때마다 전체 회로의 각 레지스터를 갱신한다. 클럭 주파수가 높을 수록 cpu가 1초에 더 많은 작업을 할 수 있게 된다.

## 4.1.11 큰일을 해냈다, CPU가 탄생했다!

각종 계산이 가능한 산술 논리 장치, 정보를 저장하는 레지스터, 작업 오케스트레이터 클럭 신호까지 이를 한 데 묶은 것을 중앙 처리 장치(cpu)라고 한다.

---

# 4.2 CPU는 유휴 상태일 때 무엇을 할까?

## 4.2.1 컴퓨터의 CPU 사용률은 얼마인가?

대부분 컴퓨터의 cpu 사용률은 7~8%로 굉장히 낮다. 몇백개의 프로세스가 열려있지만 기본적으로는 아무 작업도 하고있지 않으며, 특정 이벤트가 발생해 자신을 깨우기를 기다리고 있다.

## 4.2.2 프로세스 관리와 스케줄링

프로그램이 메모리에서 실행되면 프로세스 형태로 존재하고, 프로세스가 생성되면 운영체제가 관리하고 스케줄링한다.

운영체제는 프로세스에 우선순위를 할당하고, 우선순위에 따라 스케줄러가 스케줄링할 수 있도록 대기열에 프로세스를 넣어 관리한다.

## 4.2.3 대기열 상태 확인: 더 나은 설계

준비 완료 대기열이 비어있다면 현재 운영체제가  스케줄링해야 하는 프로세스가 없고, cpu가 유휴상태에 있다는 것을 의미한다.

예외처리 없이 이를 해결하기 위해 대기열을 가득 채워 스케줄러가 대기열에서 항상 실행할 수 있는 프로세스를 찾을 수 있도록 한다. ‘감시자’ 노드를 사용해 별도의 null 판단 로직을 제거하여 코드 오류 가능성을 줄이고 구조를 깔끔하게 유지한다.

유휴 작업이라는 프로세스를 따로 만들어서 시스템에 스케줄링 가능한 프로세스가 없을 때 스케줄러는 이 유휴 프로세스를 꺼내서 실행한다. 유휴 프로세스는 항상 준비 완료 상태에 있으며 우선순위는 가장 낮다.

## 4.2.4 모든 것은 cpu로 돌아온다

유휴 프로세스에 해당하는 기계 명령어가 바로 halt 이다. halt는 cpu 내부의 일부 모듈을 절전 상태로 전환해 전력 소비를 크게 줄인다. 가급적 절전 상태를 유지하도록 순환에 배치한다.

특권 명령어이기 때문에 커널 상태에서 cpu로만 실행할 수 있다. 응용 프로그램에서 호출할 수 있는 sleep 과는 다른 명령어이므로 혼동하지 말자.

## 4.2.5 유휴 프로세스와 cpu의 저전력 상태

halt 명령어를 실행했을 때, 커널은 시스템 유휴시간을 예측하고 이에 따라 어떤 수면 상태로 진입할지를 결정한다. 즉, 컴퓨터 시스템이 유휴 상태일 때 운영체제가 idle 스레드를 실행하고 CPU는 halt 계열 명령어를 통해 인터럽트가 발생할 때까지 대기 상태로 들어간다.

## 4.2.6 무한 순환 탈출: 인터럽트

운영체제는 일정 시간마다 타이머 인터럽트를 생성하고 cpu는 인터럽트 신호를 감지하고 운영체제 내부의 인터럽트처리 프로그램을 실행한다. 상응하는 인터럽트 처리 함수에서는 프로세스가 실행될 준비가 되었는지 판단하고, 준비가 되었다면 중단되었던 프로세스를 계속 실행한다. 준비되어있지 않다면 프로세스를 일시중지시키고 스케줄러는 준비 완료 상태인 다른 프로세스를 스케줄링한다.

유휴 프로세스의 경우에도 유휴 프로세스가 타이머 인터럽트로 일시중지되면 인터럽트 처리함수는 시스템에 준비 완료된 프로세스가 있는지 확인하고, 없다면 유휴 프로세스를 계속 실행한다.

즉, 프로그램에 무한 순환이 있더라도 운영체제는 타이머 인터럽트를 통해 프로세스의 스케줄링을 제어할 수 있으며 문제가 발생하지 않는다.

---

# 4.3 CPU는 숫자를 어떻게 인식할까?

## 4.3.1 숫자 0과 양의 정수

컴퓨터는 2진법으로 위치 기수법을 사용하며, 5를 2진법으로 표기하면 101이다.

> 5 = 1 * 2^2 + 0 * 2^1 + 1 * 2^0
> 

따라서 비트 K개를 사용하면 정수 2^k개를 나타낼 수 있다. 그 범위는 0~2^K-1dlrh, k가 8개인 8비트로 가정하면 표현 가능한 범위는 0~255이다. 이는 부호 없는 정수에 해당한다.

## 4.3.2 부호 있는 정수

그 범위를 반으로 나눠서 반은 양수로, 반은 음수로 사용하면 된다.

비트가 4개일 때, 표현할 수 있는 부호 없는 정수는 0~15가 된다. 부호 있는 정수로 표현하려면 절반은 1~7로 사용하고 나머지 절반을 -1~7로 사용하면 된다. 이 때, 최상위 비트에 정수 부호를 결정하며 0이면 양수, 1이면 음수로 정의한다.

## 4.3.3 양수에 음수 기호를 붙이면 바로 대응하는 음수: 부호 -크기 표현

0010이 +2를 의미하므로 최상위 비트를 1로 바꾸면 1010으로 -2가 된다.

그러나, 4비트로 숫자 표현 중 -0이라는 이상치가 발생한다. 0과 -0을 같게 표현할 방법이 필요하다.

## 4.3.4 부호 -크기 표현의 반전: 1의 보수

0010이 +2를 의미하므로 이를 완전히 반전시킨 1101을 -2로 표현하는 방법이다.

크기 표현과 마찬가지로 -0이 존재한다. 

## 4.3.5 간단하지 않은 두 수 더하기

크기 표현 방식으로 2 + (-2)를 하면 1100으로 -4가 되므로 모순이다.

1의 보수 결과는 1111로 -0에 해당한다. 최소한 모순은 아니지만, 가산기 위에 부호 있는 숫자의 정확한 덧셈을 보장하는 조합 회로가 추가적으로 필요하다.

## 4.3.6 컴퓨터 친화적 표현 방식: 2의 보수

2의 보수는 -1(1111)에 1(0001)을 더해 10000으로, 0000을 얻을 수 있지만 자리 올림수가 존재한다. 그러나 무자리 올림수는 무시할 수 있어서 -0을 없앨 수 있다.

## 4.3.7 CPU는 정말 숫자를 알고 있을까?

컴퓨터가 2의 보수 표현 방식을 사용하는 이유는 회로 설계를 단순화할 수 있기 때문이다. 가산기는 덧셈 과정에서 숫자가 양수인지 음수인지를 알지 못하며 단지 두 비트의 논리곱 연산이 자리 올림수라는 것만 알고 있다.

---

# 4.4 CPU가 if문을 만났을 때

## 4.4.1 파이프라인 기술의 탄생

전체 공정 단계를 수십 개로 나누고 각 단계마다 전문가를 배치한 최초의 산업 조립 라인 기술부터 시작한다. 대량 생산에 적용하면 효율성을 수백배 향상시킬 수 있다.

## 4.4.2 CPU: 메가팩토리와 파이프라인

cpu도 내부 처리 단계를 4가지로 나눌 수 있다.

- 명령어 인출(fetch)
- 명령어 해독(decode)
- 명령어 실행(execute)
- 명령어 쓰기(write)

각 4단계는 별도의 하드웨어에서 처리된다. 실제 cpu 내부에서는 기계 명령어 하나를 단계 수십 개로 분해해서 실행할 수도 있다.

## 4.4.3 if가 파이프라인을 만나면

if문은 일반적으로 컴파일러가 조건부 점프 명령어로 변환하며, 이 명령어는 분기 역할을 한다. 조건이 참이면 점프하고 그렇지 않으면 순차적으로 실행한다. 그러나 조건부 점프 명령어를 실행하기 전까지는 다음 명령어가 파이프라인에 미리 존재하지 않으므로 빈공간이 생겨 프로세서의 리소스를 완전하게 사용할 수 없는 문제가 발생한다.

## 4.4.4 분기 예측: 가능한 한 CPU가 올바르게 추측하도록

cpu는 뒤이어 어디로 분기할 가능성이 높은지 추측한다. 추측이 맞다면 파이프라인은 계속 실행할 것이고, 틀리다면 이미 실행 중이던 잘못된 분기 명령어를 전부 무효화한다. 이처럼 cpu 추측이 틀리면 바로 성능 손실이 발생한다.

배열이 정렬되어 있다면 if 조건의 결과도 매우 규칙적이게 되어 cp의 분기 예측이 거의 전부 들어맞는다. 정렬되어 있지 않으면, 기본적으로 무작위 이벤트이며 예측 실패율이 매우 높아지고 성능이 떨어진다.

따라서 컴파일러는 성능 최적화와 perf 같은 분석 도구로 분기 예측이 성능 병목 현상이 발생하는지를 확인해야 한다.

---

# 4.5 CPU 코어 수와 스레드 수 사이의 관계는 무엇일까?

## 4.5.1 레시피와 코드, 볶음 요리와 스레드

cpu는 기계 명령어에 따라 프로세스와 스레드를 실행한다. 운영체제 관점에선 cpu가 사용자 상태에서 실행하는 명령어는 모두 메모리 또는 특정 스레드에 속해있다.

cpu 코어 수와 스레드 수 사이에는 어떤 관계도 없다. 단일 코어 시스템이서는 메모리가 충분하고 운영체제에 제한이 없다면 얼마든지 많은 스레드를 생성할 수 있다.

또한 cpu는 자신이 실행하는 명령어가 어떤 스레드에 속하는지 알지 못한다. 이는 운영체제가 알아야 한다.

## 4.5.2 작업 분할과 블로킹 입출력

실행 시간이 5분인 작업 a와 b가 있다. 단일 코어 환경에서 두 작업을 완료하는데 필요한 시간은 10분이다. 스레드 여러개가 번갈아 실행되기는 하지만 진정한 병렬 처리라고 할 수 없다.

하지만 스레드가 특정 작업을 기다리지 않고 진행하는 것이라면 필요에 따라 스레드 여러 개를 생성하고 작업을 분할하여 스레드를 실행해도 된다. 이는 단일 코어인지 다중 코어인지는 신경쓰지 않아도 된다.

## 4.5.3 다중 코어와 다중 스레드

스레드에는 일정한 입출력과 동기화 등이 필요하기 때문에 이 때는 스레드 수를 적당히 늘려 운영체제가 cpu에 할당할 수 있는 충분한 스레드를 확보하면 시스템 성능을 향상시킬 수 있다. 하지만 스레드 수가 한계에 달하면 한 스레드에서 다른 스레드로 전환할 때 부담이 증가하기 때문에 전체 성능이 떨어진다.

적당한 스레드 수는 수치화하기 어렵고 실제 프로그램에서 지속적으로 테스트 해야 한다.