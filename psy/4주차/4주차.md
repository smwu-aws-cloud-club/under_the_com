# 3.1 메모리의 본질, 포인터와 참조

## 3.1.1 메모리의 본질은 무엇일까? 사물함, 비트, 바이트, 객체

메모리는 메모리셀에 0, 1을 보관하고, 이를 1비트라고 한다. → 1비트는 0 또는 1이다.

예/아니오와 같은 2가지 보다 더 많은 정보를 표현하기 위해 비트 8개를 묶은 1바이트를 사용한다.

모든 바이트는 메모리 주소를 가지고 있어서, 메모리 주소 한 개를 사용해 메모리 여러 개를 찾을 수 있다. 이를 주소지정이라고 한다.

1바이트는 0~255까지 256가지의 경우밖에 없기 때문에 범위를 더 넓힌 4바이트인 int 정수형을 사용한다.

정보 조합을 표현하기 위해 범위를 더 넓힌 12바이트의 구조체, 객체를 사용한다.

## 3.1.2 메모리에서 변수로: 변수의 의미

프로그래밍 언어 없이 1+2를 계산해보자.

CPU는 메모리에서 값을 읽어 레지스터에 저장해야 연산을 수행할 수 있기 때문에, 우선 1과 2를 각각 1바이트씩 사용하여 메모리에 저장한다. 이 때, store 명령어를 사용한다.

```json
store $1 6 // store {저장할 값} {메모리 주소}
```

메모리 주소의 값을 읽기 위해 load 명령어를 사용한다.

```json
load r1 6 // load {레지스터} {메모리 주소}
```

메모리 주소 6에 변수 a를 둘 수 있다. 이 때, a는 다음과 같은 의미가 있다.

1. 값 1을 나타낸다.
2. 이 값은 메모리 주소 6에 저장된다.

## 3.1.3 변수에서 포인터로: 포인터 이해하기

각 변수 a, b가 있을 때, 전체 8바이트 메모리에서 a가 5바이트를 차지하고 있다고 하자. 이 때, 다음과 같은 연산이 발생한다면

```json
b = a
```

a와 b로 전체 메모리 크기보다 큰 10바이트를 차지하기 때문에 문제가 발생한다.

b가 a의 복사본을 만들지 않고, a의 주소를 저장하게 된다면 메모리를 절약할 수 있다. 이처럼 메모리 주소를 저장하는 변수를 포인터라고 한다.

어셈블리어 코드는 변수가 없기 때문에 다음과 같이 간접 주소 지정으로 표현한다.

```json
load r1 @1 // load {레지스터} {메모리 주소에 저장된 값}
```

## 3.1.4 포인터의 힘과 파괴력: 능력과 책임

자바와 파이썬은 주소라는 개념을 변수로 추상화 하기 때문에 메모리 주소를 확인할 수 없다.

반면에 c는 메모리 주소를 추상화하지 않기 때문에 값과 메모리 주소를 모두 저장할 수 있다.

```c
#include <stdio.h>

void main(){
	int a = 1;
	printf("var a is in %p\n", &a); // var a is in 0x7fffd8ca7954
}
```

이를 실행했을 때, a 변수가 메모리 주소가 0x7fffd8ca7954인 위치에 저장되어 있음을 알 수 있다.

---

# 3.2 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?

## 3.2.1 가상 메모리: 눈에 보이는 것이 항상 실제와 같지는 않다.

![IMG_9864.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9864.heic)

메모리의 모든 프로세스는 사진과 같은 모습을 하고 있다. 코드 영역이 0x4000000에서 시작하며, 서로 다른 프로세스 2개가 malloc 함수를 호출하면 둘 다 0x7f64cb8을 반환하는 등 동일한 시작 주소를 반환할 가능성이 매우 높다.

이는 두 프로세스 모두 같은 주소를 사용하는게 아닌, 0x7f64cb8가 가상메모리 주소에 해당한다. 실제 메모리 조작에서는 가상 메모리 주소를 페이지 테이블을 참조하여 실제 물리 메모리 주소로 변경되어 실행된다.

실제 물리 메모리 구조는 다음과 같은 특징이 있다.

1. 프로세스는 동일한 크기의 조각(chunk)으로 나뉘어 물리 메모리에 저장된다.
2. 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있다.

## 3.2.2 페이지와 페이지 테이블: 가상에서 현실로

프로세스에 있는 가상 메모리는 실제 물리 메모리에 무작위로 흩어져서 존재한다. 가상 메모리와 물리 메모리 사이의 사상 관계를 페이지 테이블로 관리한다.

프로세스의 전체 가상 메모리 주소를 저장하지 않고, 필요한 부분만을 사용하기 위해 프로세스 또한 주소 공간을 동일한 크기의 조각으로 나눈다. 이를 페이지라고 한다.

이처럼 두 프로세스가 동일한 가상 메모리 주소에 기록하더라도 가리키는 페이지가 서로 다른 물리 메모리 주소에 저장되기 때문에 문제가 발생하지 않는다.

---

## 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

## 3.3.1 프로그래머를 위한 도우미: 함수

동일한 기능을 하는  코드를 매번 반복해서 작성할 필요 없이 함수를 사용함으로써 코드를 재사용할 수 있다.

## 3.3.2 함수 호출 활동 추적하기: 스택

여러 함수의 호출로 이어진 진행 궤적을 살펴보면, 후입선출 순서로 스택과 같은 데이터 구조가 처리하기 적합하다. 이를 살펴보면 이진 트리와 탐색이라는 특징이 나타나고, 트리 구조의 순회가 재귀 구현 뿐만 아니라 스택 구현에서도 사용될 수 있는 이유이다.

## 3.3.3 스택 프레임 및 스택 영역: 거시적 관점

![IMG_9871.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9871.heic)

여러 함수의 호출 각각은 스택 프레임 또는 호출 스택에 생성된다. 이 스택 영역을 차지하는 메모리는 함수 호출 깊이에 따라 증가하고 함수 호출이 완료될 수록 감소한다.

## 3.3.4 함수 점프와 반환은 어떻게 구현될까?

함수 a가 함수 b를 호출하면 제어권이 a에서 b로 옮겨간다. 제어권이란, cpu가 어떤 함수에 속하는 기계 명령어를 실행하는지를 말한다. 제어권이 바뀔 때는 다음과 같은 정보가 필요하다.

1. 반환(return): 어디에서 왔는지에 대한 정보
2. 점프(jump): 어디로 가는지에 대한 정보

이러한 정보가 스택 프레임에 저장되어 있다.

### 함수 a에서 함수 b로 점프와 반환

![IMG_9865.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9865.heic)

현재 cpu에서 함수 a의 기계 명령어를 실행 중이고, 이어서 함수 b의 기계 명령어를 실행할 것이다.

```c
call 0x400540 // 함수 b의 기계 명령어
```

위의 어셈블리어 코드가 프로그래밍 언어에서 코드의 함수 호출이다.

![IMG_9866.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9866.heic)

함수 a의 스택 프레임에 함수 b를 호출한 다음 주소를 저장한다. 이후 함수 b로 점프하게 된다.

이와 같이, 여러 함수를 실행할 수록, 스택 프레임에 필요한 정보를 저장하면서 메모리 크기가 커진다.

![IMG_9867.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9867.heic)

함수 b는 마지막 기계 명령어인 ret까지 실행되는데, ret은 함수 a의 스택 프레임에 저장된 반환 주소를 전달한다. 이에 따라 함수 b의 실행이 완료되면 바로 함수 a로 점프하여 계속 실행할 수 있다.

## 3.3.5 매개변스 전달과 반환값은 어떻게 구현될까?

함수 a가 함수 b를 호출하면 함수 a의 매개변수를 레지스터에 저장하며, cpu가 함수 b를 실행할 때 이 레지스터에서 매개변수 정보를 얻을 수 있다. 반대의 경우도 마찬가지이다.

![IMG_9868.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9868.heic)

그러나 전달되 매개변수 수가 사용 가능한 레지스터 수보다 많다면 스택 프레임에 직접 넣을 수 있다. 이러한 경우, 새로 호출된 함수가 이전 함수의 스택 프레임에서 매개변수를 가져올 수 있다.

## 3.3.6 지역 변수는 어디에 있을까?

매개변수와 마찬가지로 레지스터에 저장할 수 있지만 로컬 변수가 레지스터 수보다 많으면 이 변수들도 스택 프레임에 저장한다.

![IMG_9869.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9869.heic)

## 3.3.7 레지스터의 저장과 복원

레지스터는 cpu의 내부 리소스로, 함수 a와 함수 b를 호출할 때 함수 a의 레지스터 기록 정보를 함수 b가 덮어쓰는 문제가 발생할 수 있다.

따라서 레지스터에 지역변수를 저장하기 전에 먼저 저장된 초깃값을 사용하고 나면 스택 프레임에 저장한다. 함수 실행이 완료된 후에 스택 프레임에 저장되어 있는 초깃값을 레지스터에 복원한다.

![IMG_9870.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9870.heic)

## 3.3.8 큰 그림을 그려보자, 우리는 지금 어디에 있을까?

> 매개변수가 너무 많으면 일부 매개변수가 스택에 저장되고, 레지스터 내용 중 일부는 스택 프레임에 저장된다. 그렇다면 매개변수가 너무 많아 레지스터에 저장되지 못한 정보는 어떻게 알 수 있을까?
> 

> 스택 영역의 증가와 감소는 구체적으로 어떻게 구현되고, 이를 구현하는 책임은 누구에게 있을까?
> 

---

# 3.4 힙 영역: 메모리의 동적 할당은 어떻게 구현될까?

## 3.4.1 힙 영역이 필요한 이유

프로그래머가 완전히 직접 제어할 수 있는 매우 큰 메모리 영역을 힙 영역이라고 한다.

## 3.4.2 malloc 메모리 할당자 직접 구현하기

힙 영역이 해결해야 할 두 가지 핵심 문제는 다음과 같다.

1. malloc 함수를 구현한다. 이 함수는 누군가 나에게 메모리 영역을 요청하면 힙 영역에서 가능한 메모리 영역을 찾아 요청자에게 반환하는 과정을 구현하는 것이다.
2. free 함수를 구현한다. 이 함수는 메모리 영역의 사용이 완료되었을 때 힙 영역에 이 메모리 영역을 반환하는 방법을 구현하는 것이다.

## 3.4.3 주차장에서 메모리 관리까지

메모리를 할당하기 위해 다음 두 가지 목표를 달성해야 한다.

1. 할당할 위치를 빠르게 찾는다. 여기에는 요청된 크기를 만족하는 여유 메모리를 최대한 빨리 찾는 조건이 포함된다.
2. 메모리 사용률을 극대화하고자 메모리에 가능한 한 많은 프로세스를 할당할 수 있어야 한다. 메모리를 요청할 때는 정해진 메모리 한도 내에서 가능한 한 많은 메모리 할당 요청을 만족시켜야 한다.

## 3.4.4 여유 메모리 조각 관리하기

어떤 영역이 사용 가능한 메모리고 어떤 영역이 이미 할당된 메모리인지 구분하는 방법이 필요하다.

메모리 조각에 연결 리스트와 메모리 사용 정보를 저장한다. 연결 리스트에는 다음 노드를 가리키는 포인터 대신 메모리 사용 정보를 저장하여 다음 노드 위치를 유추하도록 한다. 따라서 다음 두 가지 정보를 기록한다.

1. 해당 메모리 조각이 비어있는지 알려주는 설정값(flag)
2. 해당 메모리 조각의 크기를 기록한 숫자

![IMG_9872.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9872.heic)

각 메모리 조각 크기를 머리정보의 조각 크기에서 알 수 있고, 사용 가능한지 여부를 f/a로부터 알 수 있다.

## 3.4.5 메모리 할당 상태 추적하기

머리 정보를 통해 전체 힙 영역을 쉽게 추적할 수 있다. 머리 정보의 마지막 비트를 확인하여 메모리 조각에 할당할 수 있는지에 대한 여뷰 또한 확인할 수 있고, 할당되었다면 할당 정보를 추적할 수도 있다.

## 3.4.6 어떻게 여유 메모리 조각을 선택할 것인가: 할당 전략

### 최초 적합 방식

가장 먼저 발견한 요구 사항을 만족하는 메모리 항목을 반환하는 방법이다.

그러나 앞부분에 작은 메모리 조각이 많이 남을 가능성이 높고 다음 메모리를 할당할 때 더 많은 여유 메모리 조각을 탐색해야 하는 문제가 발생한다.

### 다음 적합 방식

메모리를 요청할 때 처음부터 검색하지 않고 적합한 여유 메모리 조각이 마지막으로 발견된 위치에서 시작해서 검색한다. 

그러나 메모리 사용률이 최초 적합 방식에 미치지 못한다는 것이 연구 결과로 밝혀졌다.

### 최적 적합 방식

사용 가능한 메모리 조각을 모두 찾고, 그중 요구 사항을 만족하면서 할당 후 가장 작은 조각을 반환하는 항목을 선택한다.

그러나 사용 가능한 모든 메모리 조각을 탐색해야 하므로 속도가 빠르지 않다.

## 3.4.7 메모리 할당하기

머리 정보 뒤 메모리 주소를 반환하고 머리 정보의 f/a를 a(allocated)로 표시한다.

선택된 메모리 조각이 요구 사항보다 클 경우, 남은 조각이 발생한다. 이를 내부 단편화라고 한다. 이 남은 부분 중 4바이트를 머리정보로 설정하여 여유 메모리 조각으로 표시한다.

## 3.4.8 메모리 해제하기

사용자가 메모리를 요청할 때 얻은 주소를 ADDR이라고 하자. ADDR에서 머리 정보 크기인 4바이트를 빼는 것으로  머리 정보를 얻을 수 있다. 이 머리 정보의 f/a를 f(free)로 바꾸면 해제가 완료된다.

해제할 메모리 조각에 인접한 메모리 조각도 비어있을 경우, 더 큰 메모리 조각으로 서로 병합한다.

## 3.4.9 여유 메모리 조각을 효율적으로 병합하기

![IMG_9873.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9873.heic)

메모리 꼬리 정보는 그 다음에 위치한 조각의 머리정보와 인접해 있어 현재 조각의 머리 정보에서 4바이트를 빼면 이전 조각의 꼬리 정보를 알 수 있다. 따라서 메모리를 해제할 때 인접한 여유 조각을 빠르게 병합할 수 있다.

즉, 머리 정보와 꼬리 정보는 메모리 조각을 암시적 양방향 연결리스트로 만든다.

---

# 3.5 메모리를 할당할 때 저수준 계층에서 일어나는 일

## 3.5.1 천지인과 CPU 실행 상태

cpu는 4가지 특권 단계로 구성된다. 이는 cpu의 여러가지 동작 상태를 나타내며 숫자가 작을 수록 특권은 커진다.

그 중 0단계는 커널 상태, 3단계는 사용자 상태이다.

## 3.5.2 커널 상태와 사용자 상태

cpu가 운영체제의 코드를 실행할 때 커널 상태에 놓인다. 반면 프로그래머가 작성한 응용 프로그램 코드는 사용자 상태에 해당한다. 사용자 상태에서는 특정 주소 공간에는 접근할 수 없고 cpu가 특권 명령어를 실행할 수 없다는 제한이 있다.

## 3.5.3 포털: 시스템 호출

cpu는 커널 상태에서는 응용 프로그램을 실행할 수 없고, 사용자 상태에서는 운영체제의 코드를 실행할 수 없다. 때문에 운영체제의 시스템 호출을 이용해 파일 읽기, 쓰기, 네트워크 데이터 통신같은 작업을 응용 프로그램 대신 처리한다.

시스템 호출은 cpu가 사용자 상태에서 커널 상태로 전환하여 운영체제의 코드를 실행하는 방법으로 사용자 요청을 수행한다.

## 3.5.4 표준 라이브러리: 시스템의 차이를 감춘다

시스템 호출은 운영체제(eg. 리눅스, 윈도우 등) 별로 완전히 다르다. 그래서 시스템 호출을 직접 사용하면 리눅스 프로그램은 윈도우에서 실행할 수 없다.

응용 프로그램을 추가적인 수정 없이 서로 다른 운영체제에서 실행할 수 있도록 하는 것이 표준 라이브러리이다. 표준 라이브러리의 코드는  사용자 상태에서도 실행할 수 있다.

계층적인 관점에서 전체 시스템의 모습은 다음과 같다.

```c
응용 프로그램
-----------
표준 라이브러리
-----------
  운영체제
-----------
  하드웨어
```

응용프로그램은 표준 라이브러리만 통신 대상으로 간주한다. 표준 라이브러리는 시스템 호출로 운영체제와 통신하며 운영체제는 저수준 하드웨어를 관리한다.

## 3.5.5 힙 영역의 메모리가 부족할 때

메모리 할당자 안의 여유 메모리 조각이 부족해지면 힙 영역의 위쪽인 유휴 영역으로 더 많은 메모리를 점유하게 된다.

![IMG_9874.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9874.heic)

힙 영역의 상단을 가리키는 brk 변수를 위로 이동해서 힙 영역 크기를 늘리거나 줄일 수 있다. 이를 위해 운영체제에 시스템 호출로 요청할 수 있다.

## 3.5.6 운영체제에 메모리 요청하기: brk

메모리 할당이 사용자 상태에서만 국한되지 않기에 전체 단계가 다음과 같이 달라질 수 있다.

1. 프로그램은 malloc을 호출하여 메모리 할당을 요청한다. malloc은 표준 라이브러리에 구현되어 있다.
2. malloc은 여유 메모리 조각을 찾지못하면 brk 시스템 호출 등을 통해 운영체제에 힙 영역을 늘릴 것을 요청한다. brk는 운영체제의 일부분이므로 커널 상태에 해당한다. 힙 영역이 늘어나면 malloc이 다시 한 번 적절한 여유 메모리 조각을 찾아 할당한다.

![IMG_9875.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9875.heic)

## 3.5.7 빙산의 아래: 가상 메모리가 최종 보스다

malloc을 이용해 힙 영역에 메모리를 요청하고 malloc 역시 운영체제를 통해 힙 영역을 확장하지만, 힙 영역을 포함한 전체 프로세스 주소 공간은 모두 실제 물리 메모리가 아닌 가상 메모리이다.

실제 물리 메모리는 할당한 메모리가 사용되는 순간에 할당하게 된다.

가상 메모리가 실제 물리 메모리와 연결되어 있지 않으면 page fault가 발생한다. 운영체제가 이를 감지하면 페이지 테이블을 수정하여 가상 메모리와 실제 메모리의 사상 관계를 설정하여, 실제 물리 메모리가 할당되게 된다.

malloc은 메모리의 2차 할당에 불과하며 할당 받는 것도 가상 메모리이며, 이 과정은 모두 사용자 상태에서 처리된다. 할당된 가상 메모리를 사용할 때는 반드시 사상관계가 있어야 커널 상태에서 실제 물리 메모리를 할당한다.

## 3.5.8 메모리 할당의 전체 이야기

malloc을 호출하여 메모리를 요청하면 다음 일이 일어난다.

1. malloc이 여유 메모리 조각을 검색하여 적절한 크기의 조각을 찾으면 이를 할당한다.
2. malloc이 적절한 여유 메모리 조각을 찾지 못하면 brk 같은 시스템 호출을 통해 힙 영역을 확장하여 더 많은 여유 메모리를 얻는다.
3. malloc이 brk를 호출하면 커널  상태로 전환되는데, 이 때 운영체제의 가상 메모리 시스템이 힙 영역을 확장한다. 확장된 메모리는 가상 메모리이며 운영체제는 아직 실제 물리 메모리를 할당하지 않았을 수 있다.
4. brk가 종료되면 Malloc으로 제어권이 변환되며 cpu가 사용자 상태로 전환된다. malloc이 적절한 여유 메모리 조각을 찾아 반환한다.
5. 메모리 요청 성공 후 다음 단계를 실행한다.
6. 코드가 새로 요청된 메모리를 읽거나 쓰면 page fault가 발생한다. 이 때 cpu는 사용자 상태에서 커널 상태로 전환되며, 운영체제가 실제 물리 메모리를 할당한다. 페이지 테이블 내 가상 메모리와 실제 물리 메모리의 사상 관계가 설정된 후, cpu는 다시 커널 상태에서 사용자 상태로 전환되어 다음 처리로 넘어간다.

![IMG_9876.heic](4%EC%A3%BC%EC%B0%A8%20-%203%205%EC%9E%A5%EA%B9%8C%EC%A7%80/IMG_9876.heic)