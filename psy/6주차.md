# 6주차 - 4장 마무리, 5.1장까지

날짜: 2026년 2월 4일
완료: No

# 4.6 CPU 진화론(상): 복잡 명령어 집합의 탄생

## 4.6.1 프로그래머의 눈에 보이는 CPU

CPU 입장에서는 어떤 프로그램을 실행시키던지 컴파일러로 기계 명령어를 실행하는 것과 똑같이 실행한다.

## 4.6.2 CPU의 능력범위: 명령어 집합

우리는 명령어 집합으로 CPU에게 실행시킬 일을 코드로 작성한다.

## 4.6.3 추상화: 적을 수록 좋다

예전에 프로그래머는 어셈블리어로 프로그램을 작성했다. 명령어 집합의 기능 자체는 매우 단순하지만 함수 호출, 순환 제어, 복잡한 주소 지정 패턴, 데이터 구조, 배열 접근 등 복잡한 연산을 해주는 고급언어가 필요해지면서 의미상 간격을 줄여야 했다.

## 4.6.4 코드도 저장 공간을 차지한다

‘저장 개념에서 프로그램과 프로그램이 사용하는 데이터에 어떤 차이도 없어야 하며, 모두 컴퓨터의 저장 장치 안에 저장될 수 있어야 한다.’ 라는 폰 노이만의 핵심 사상에 따른다.

실행 파일은 기계 명령어와 데이터를 모두 포함하고 있고, 프로그래머가 작성한 코드는 디스크 저장 공간을 차지하며 실행 시에는 메모리에 적재되므로 메모리 저장 공간을 차지한다.

## 4.6.5 필연적인 복잡 명령어 집합의 탄생

매우 작은 메모리에 더 많은 프로그램을 적재하기 위해 복잡 명령어 집합을 설계해야 했다.

그러나, cpu의 명령어 집합은 모두 직접 연결 방식으로, 특정 조합 회로로 직접 제어되는 구조였다. 이는 명령어 실행에는 매우 효율적이지만 유연성이 떨어졌다.

하드웨어의 변경은 매우 번거롭기 때문에 대부분의 명령어에 포함된 연산으로 명령어 집합을 더 간단한 명령어로 구성하여 cpu에 연결하고 복잡 명령어는 이를 조합하는 방식으로 이를 해결했다. 이를 마이크로코드 설계라고 한다.

## 4.6.6 마이크로코드 설계의 문제점

마이크로코드의 버그를 수정하는 일은 훨씬 어렵고, 마이크로코드의 설계가 트랜지스터를 매우 많이 소모한다는 문제점이 드러났다.

---

# 4.7 CPU 진화론(중): 축소 명령어 집합의 탄생

## 4.7.1 복잡함을 단순함으로

복잡 명령어 집합에서 성능을 향상시키는 것으로 여겨지는 명령어는 실제로 cpu 내부에서 마이크로코드에 의해 가로막힌다는 사실이 밝혀졌다. 따라서 마이크로코드를 제거하면 오히려 프로그램이 빠르게 실행되고 cpu를 구성하는데 사용되는 트랜지스터를 절약할 수 있다.

마이크로코드 설계는 복잡한 기계 명령어를 cpu 내부에서 더 간단한 기계 명령어로 변환하는 것으로, 컴파일러가 생성된 기계 명령어를 이용해 cpu 내부에서 실행되는 마이크로코드에 영향을 미칠 방법이 없다. 그래서 마이크로코드에 버그가 있으면 컴파일러는 이를 대처할 수 없다.

또한 일부 복잡한 기계 명령어가 같은 일을 하는 간단한 명령어 여러개를 실행하는 것보다 느리게 실행된다는 사실도 밝혀졌다.

## 4.7.2 축소 명령어 집합의 철학

복잡 명령어의 문제점을 바탕으로 축소 명령어 집합의 철학이 생겼다.

### 명령어 자체의 복잡성

마이크로코드가 없으면 컴파일러에서 생성된 기계 명령어의 cpu 제어 능력이 크게 향상된다. 복잡한 명령어를 제거하고 대신 간단한 명령어 여러 개로 대체한다.

### 컴파일러

축소 명령어 집합을 사용하는 cpu는 더 많은 세부 사항을 컴파일러에 제공하여 cpu에게 더 강력한 제어권을 갖게 해준다.

### LOAD/STORE 구조

복잡 명령어에서는 기계 명령어 하나만으로 메모리에서 데이터를 가져오고, 잡업을 수행 후 메모리에 다시 쓰는 작업을 할 수 있다.

그러나, 축소 명령어 집합에서는 LOAD와 STORE라는 전용 기계 명령어가 메모리의 읽고 쓰기를 수행하고 다른 명령어들은 cpu 내부의 레지스터만 처리할 수 있다.

## 4.7.3 복잡 명령어 집합과 축소 명령어 집합의 차이

다음과 같은 계산 과정을 복잡 명령어 집합과 축소 명령어 집합에서 각각 어떻게 구현하는지를 보자.

1. 메모리 주소 A의 데이터를 읽어 레지스터에 저장한다.
2. 메모리 주소 B의 데이터를 읽어 레지스터에 저장한다.
3. ALU가 레지스터 값을 이용해 곱셈 연산을 수행한다.
4. 곱셈 결과를 다시 메모리에 쓴다.

### 복잡 명령어 집합의 경우

이 단계를 단 하나의 명령어로 완료할 수 있다.

```json
MULT A B
```

### 축소 명령어 집합의 경우

```json
LOAD RA, A
LOAD RB, B
PROD RA, RB
STORE A, RA
```

복잡 명령어 집합보다 더 많은 저장공간이 필요하며 이는 어셈블리어로 코드를 작성하는 프로그래머를 번거롭게 한다. 그러나 프로그래머가 직접 어셈블리어로 코드를 작성하는게 아니라, 이를 컴파일러에게 맡기고 컴파일러가 구체적인 기계 명령어를 자동으로 생성하게 하므로 의의가 있다.

## 4.7.4 명령어 파이프라인

축소 명령어 집합에서 생성된 명령어의 장점은 다음과 같다.

1. 명령어들이 매우 간단하므로 cpu 내에서 코드를 해석하는데 복잡한 하드웨어 구조를 필요로하지 않아 트랜지스터를 절약할 수 있다.
2. 절약한 트랜지스터를 cpu의 다른 기능으로 활용할 수 있다.
3. 각 명령어가 매우 간단하기 때문에 실행 시간이 모두 거의 동일하다.

---

# 4.8 CPU 진화론(하): 절체절명의 위기에서 반격

## 4.8.1 이길 수 없다면 함께하라: RISC와 동일한 CISC

축소 명령어 집합의 주요 장점이 파이프라인 기술을 잘 활용할 수 있다는 것이다. 복잡 명령어 집합은 명령어 실행 시간이 고르지 않아 파이프라인을 활용할 수 없다.

따라서 복잡 명령어 집합의 명령어를 cpu 내부에서 축소 명령어 집합의 간단한 명령어로 변환하여 축소 명령어 집합에 가깝게 바꾼다. 이 축소 명령어 집합의 간단한 명령어와 유사한 명령어들을 마이크로 명령어라고 한다.

이 방식은 복잡 명령어 집합의 호환성을 유지하면서 동시에 축소 명령어 집합의 장점을 얻을 수 있다.

## 4.8.2 하이퍼스레딩이라는 필살기

cpu는 한 번에 하나의 스레드에 속한 기계 명령어만 실행할 수 있다. 시스템에 n개의 cpu 코어가 있다면 운영체제는 N개의 준비 완료 상태인 스레드를 n개의 cpu 코어에 할당해서 동시에 실행할 수 있다.

하이퍼스레딩을 사용하면 하이퍼스레딩 기술이 탑재된 cpu가 한 번에 스레드 두 개에 속하는 명령어 흐름을 처리할 수 있어 cpu 코어 한 개가 cpu 코어 여러 개인 것처럼 보이게 할 수 있다.

명령어 간 종속성으로 파이프라인이 항상 완벽하게 채워진 상태에서는 실행될 수 없다. 빈 공간이 생긴다면 추가 명령어 흐름으로 채워 전체 파이프라인을 채워서 cpu의 리소스를 최대한으로 활용하는 방식이다.

프로그래머가 인지하는 스레드는 관리의 주체가 운영체제이기 때문에 하드웨어 스레드에 해당하는 하이퍼스레딩과는 상관이 없다. 따라서 운영체제는 이를 인식할 수 없기 때문에 시스템에 더 많은 Cpu 코어가 사용 가능하다고 인식하는 것이다.

## 4.8.3 장점은 취하고 약점은 보완하다: CISC와 RISC의 통합

복잡 명령어 집합 구조와 축소 명령어 집합 구조가 비슷해져 가고 있음에도 다음과 같은 차이점이 있다.

1. 축소 명령어 집합은 명령어 길이가 일정하기 때문에 컴파일러 최적화에서 더 많은 장점이 있다.
2. 메모리에 접근할 때 축소 명령어 집합은 LOAD/STORE 구조인데, 복잡 명령어 집합에는 이러한 설계가 없다.

---

# 4.9 CPU, 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 통달하기

## 4.9.1 레지스터

레지스터가 필요한 이유는 cpu가 메모리에 접근하는 속도가 느리기 때문이다. 프로세스가 생성되면 코드와 코드에서 사용하는 데이터는 메모리에 적재되며, 메모리 데이터를 CPU가 사용할 레지스터로 옮겨서 기계 명령어를 실행한다.

## 4.9.2 스택 포인터

함수가 실행될 때 함수에 정의된 로컬 변수와 매개변수 등을 저장하는 독립적인 메모리 공간이 있는데 이를 스택 포인터라고 한다. 스택의 가장 중요한 정보는 스택 상단으로, 이 정보는 스택 하단을 가리키는 스택 포인터에 저장된다.

함수 호출이 단계가 깊어질 수록 스택 프레임 수도 증가하며, 호출이 완료되면 호출의 반대 순서로 스택 프레임 수가 줄어든다.

## 4.9.3 명령어 주소 레지스터

보통 PC라고 부른다. 프로그래머가 고급 언어로 프로그램을 작성하면 전체 코드로 컴파일러에서 기계 명령어를 만든다.

프로그램이 실행되면 실행할 기계 명령어의 주소가 PC에 저장되며, cpu는 이 PC에 저장되어 있는 주소에 따라 메모리에서 명령어를 가져와 실행한다. 일반적으로 명령어는 순차적으로 실행되지만, if 문과 같이 분기 점프, 함수 호출 반환같이 새로운 명령어 주소를 저장하기도 한다.

## 4.9.4 상태 레지스터

예를 들어 산술 연산이 포함된 명령어는 수행 중에 자리 올림수가 발생하거나 넘침이 발생할 수 있다. 이 때 이런 정보는 상태 레지스터에 저장된다.

이외에 cpu는 기계 명령어를 실행할 때 커널 상태와 사용자 상태를 가진다. cpu가 어떤 상태인지가 상태 레지스터에 저장되어 있어 동작 상태를 관리할 수 있다.

## 4.9.3 상황 정보

레지스터를 통해 프로그램이 실행된 직후부터 현시점까지 세세한 단면을 알 수 있으며, 현시점에 레지스터에 저장된 모든 정보를 일반적으로 상황 정보라고 한다.

상황 정보는 프로그램의 실행 시 상황 정보를 가져오고 저장해서 언제든지 프로그램을 일시중지할 수 있으며, 반대로 이 정보를 이용해 프로그램 실행을 재개할 수도 있다. cpu는 함수호출, 시스템 호출, 스레드 전환, 인터럽트 처리 시 실행 중인 프로그램을 중단해야 한다. 이 때 CPU는 이후 복구를 대비해 중단되기 전 상태를 저장한다.

## 4.9.6 중첩과 스택

함수의 호출과 같이 cpu의 모든 작업은 중첩된 구조를가지고 있다. 이러한 중첩 구조를 처리하기 위해 스택을 사용한다.

## 4.9.7 함수 호출과 실행 시간 스택

함수 호출시 어려운 점은 복귀할 때 함수 반환 주소뿐만 아니라 사용한 레지스터 정보 등도 포함된다는 것이다. 따라서 모든 함수 실행시 스택 프레임에 함수 실행 시 상태 정보를 저장한다.

함수 A가 함수 B를 호출할 때 실행 시 정보는 함수 A의 스택 프레임에 저장되며 함수 B의 실행이 완료되면 스택 프레임 정보를 기반으로 함수 A의 실행이 재개된다. 이는 함수 호출마다 스택에 후입선출 순서로 스택 프레임이 생성된다.

## 4.9.8 시스템 호출과 커널 상태 스택

디스크 파일을 읽고 쓰거나 새로운 스레드를 생성할 때 이런 요청을 수행하는 것은 cpu이다. 때문에 cpu 역시 내부적으로 이 요청을 처리하는 함수를 호출하고 함수를 호출할 때는 실행 시간 스택이 필요하다. 이를 커널 상태 스택이라고 한다.

사용자 스레드가 운영체제의 서비스를 요청해야 하는 경우 시스템 호출을 사용해야 한다. cpu가 해당 명령어를 실행할 때 사용자 상태에서 커널 상태로 전환되며 커널 상태에서 사용자 상태 스레드에 대응하는 커널 상태 스택을 찾은 후 대응하는 커널 코드를 실행하여 시스템 호출 요청을 처리한다.

시스템 호출 과정은 다음과 같다.

1. 프로그램이 사용자 상태에서 실행된다.
2. 사용자 상태의 함수에서 시스템 호출이 되면 시스템 호출에 대응하는 기계 명령어를 찾는다.
3. cpu가 사용자 상태에서 커널 상태로 전환된다.
4. 사용자 상태 스레드의 레지스터 정보와 실행 상황 정보는 커널 상태 스택에 저장된다.
5. 커널에서 관련 코드를 실행한다.
6. 시스템 호출이 완료되면 커널 상태 스택에 저장된 사용자 상태 프로그램의 상황 정보에 따가 cpu 상태가 복원된다.
7. cpu가 커널 상태에서 사용자 상태로 전환된다.

## 4.9.9 인터럽트와 인터럽트 함수 스택

컴퓨터는 인터럽트 작동 방식을 이용해 처리되기 때문에 프로그램 실행 도중에 키보드의 키 입력, 마우스의 움직임, 네트워크 수신 같은 작업을 처리할 수 있다.

인터럽트는 현재 cpu의 실행 흐름을 끊고 특정 인터럽트 처리 함수로 점프하며, 인터럽트 처리 함수의 실행이 완료되면 원래 위치로 다시 점프한다.

인터럽트의 실행 시간 스택은 두 가지 방식이 있다.

1. 인터럽트 처리 함수에 자체적인 실행 시간 스택이 없는 경우 인터럽트 처리 함수는 커널 상태 스택을 이용해 인터럽트 처리를 실행한다.
2. 인터럽트 처리 함수에 ISR 스택이라는 자체 실행 시간 스택이 있는 경우가 있다. 인터럽트를 처리하는 것은 cpu라서 모든 cpu가 자신 만의 인터럽트 처리 함수 스택을 가진다.

인터럽트 처리 함수 실행 과정은 다음과 같다.

1. 인터럽트 신호가 발생하면 현재 프로그램의 실행이 일시중지된다.
2. cpu는 사용자 상태에서 커널 상태로 전환된다.
3. cpu가 사용자 상태 스레드에서 대응하는 커널 상태 스택을 찾아 커널 상태 스택에 사용자 상태 스레드의 실행 상황 정보를 저장한다.
4. cpu는 인터럽트 처리 함수의 시작 주소로 점프한다. 인터럽트 처리 함수가 실행되는 동안 커널 상태 스택은 사용자 상태 실행 시간 스택과 마찬가지로 함수의 호출과 반환에 따라 그 크기가 증가하거나 감소한다.
5. 인터럽트 처리 함수의 실행이 완료되면 커널 상태 스택에 저장된 상황 정보에 따라 cpu 상태가 복원된다.
6. cpu가 커널 상태에서 사용자 상태로 전환되고, 사용자 상태스레드가 계속 실행된다.

## 4.9.10 스레드 전환과 커널 상태 스택

두 스레드 A와 스레드 B가 있을 때, 스레드 A가 실행 중이라고 가정한다.

시스템 내부의 타이머가 인터럽트 신호를 발생시키면 cpu느 인터럽트 신호를 수신 후 현재 스레드의 실행을 일지중지한다. 사용자 상태에서 커널 상태로 전환하며 커널 안의 타이머 인터럽트 처리 프로그램을 실행한다.

타이머 인터럽트 처리 프로그램은 스레드 A에 할당된 cpu 시간 조각이 전부 사용되었는지 판단하고, 시간이 남아있다면 사용자 상태로 돌아가서 실행을 계속한다.
시간 조각이 모두 사용되었다면 cpu는 스레드 B와 같은 다른 스레드에 할당되어야 한다. 이를 스레드 전환이라고 하고 다음과 같은 두 가지 작업을 포함한다.

1. 주소 공간을 전환한다.
2. cpu를 스레드 A에서 스레드 B로 전환한다. 스레드 A의 cpu 상황 정보를 저장하고 스레드 B의 cpu 상황 정보를 복원하는 것까지 포함한다.

모든 리눅스 스레드에는 프로세스 서술자인 tast_struct 구조체가 있으며 그 안의 thread_struct 구조체가 cpu의 상황 정보를 저장하는 역할을 한다.

cpu가 스레드 A에서 스레드 B로 전환할 때 일단 실행 중인 스레드 A의 cpu 상황 정보를 스레드 A의 서술자에 저장하고, 스레드 B의 서술자에 저장된 상황 정보를 cpu로 복원한다.

만약 스레드 B를 실행하려는 도중, 스레드 B도 시간 조각이 모두 사용되어 일시중지되었다면 스레드의 B는 자신이 일시중지 되었다는 사실을 모르고 있으며 자신이 사용자 모드로 다시 전환해야 한다는 것만 알고 있다.

이후 스레드 B는 커널 상태 스택에 저장된 상황 정보를 이용해 사용자 상태로 다시 점프하여 계속 실행된다.

---

# 5.1 캐시, 어디에나 존재하는 것

## 5.1.1 CPU와 메모리의 속도 차이

일반적인 시스템에서 메모리의 속도는 cpu의 100분의 1이다.

## 5.1.2 도서관, 책상, 캐시

캐시는 가격이 비싸고 용량이 제한적이지만 cpu 속도와 필적한 접근 속도를 가진다.

최신 cpu와 메모리 사이에는 L1캐시, L2캐시, L3캐시가 있다. cpu는 메모리에 접근해야할 때, L1 캐시를 먼저 본다. 적중하지 않으면 L2 캐시를 보고 적중하지 않으면 L3 캐시를 본다. L3도 적중하지 않았을 때 메모리에 직접 접근하여 캐시에 메모리를 갱신한다.

## 5.1.3 공짜 점심은 없다: 캐시 갱신

cpu는 캐시에 직접 기록한다. 이 때, 캐시의 데이터는 갱신되었지만 메모리의 데이터를 아직 예전의 것이 남아있는 불일치 문제가 발생할 수 있다.

이를 해결하기 위해 캐시를 갱신할 때 메모리도 함께 갱신한다. 이를 연속 기입이라고 한다. 캐시 용량이 부족하면 자주 사용되지 않는 데이터를 제거해야 하는데, 이 때 캐시에서 제거된 데이터가 수정된 적이 있다면 이를 메모리에 갱신한다. 캐시의 갱신과 메모리의 갱신이 분리되므로 비동기에 해당하며, 이를 후기입이라고 한다.

## 5.1.4 세상에 공짜 저녁은 없다: 다중 코어 캐시의 일관성

다중 코어 환경에서 시스템이 cpu 코어가 2개 있다면 이 두 코어에서는 서로 다른 스레드 2개가 실행된다. 만약 메모리 변수 1개에 대해 각 캐시에 복사본이 1개씩 생긴다면 갱신할 때 두 캐시에 몯 동기적으로 수정되지 않는 문제가 발생한다.

이를 해결하기 위해 cpu는 변수를 업데이트할 때 해당 변수가 다른 cpu 코어의 캐시에도 있는지 확인하고, 있다면 해당 캐시도 갱신한다.

## 5.1.5 메모리를 디스크의 캐시로 활용하기

컴퓨터 시스템의 메모리 사용률은 보통 100%에 도달하지 않기 때문에 이 여유 공간을 활요해 디스크의 캐시로 활용한다. 파일을 기록할 때 저수준 영역에서는 메모리 내 캐시에 기록하기만 하고 반환될 가능성이 높고, 이 때 파일의 최신 데이터는 아직 디스크에 갱신되지 않았을 수 있다. 데이터가 유실될 수 있기 때문에 입출력 라이브러리가 동기화 또는 캐시 비우기 함수를 제공하여 이를 방지한다.

매번 파일을 읽을 때마다 디스크 입출력이 발생하지 않느다. 해당 파일 내용이 이미 메모리 내에 있어 캐시가 적중할 경우 디스크 접근을 하지 않고 파일 적재 속도도 빨라진다.

## 5.1.6 가상 메모리와 디스크

프로세스 주소 공간의 데이터는 디스크로 대체될 수 있기 때문에 디스크 입출력을 포함하고 있지 않더라도 메모리 사용률이 높은 경우에는 cpu가 프로그램을 실행할 때도 디스크에 접근해야하다.

## 5.1.7 CPU는 어떻게 메모리를 읽을까?

cpu는 가상 메모리 주소를 사용한다. cpu가 메모리를 사용할 때 실행하는 읽기, 쓰기 명령어가 사용하는 것도 가상 메모리 주소이며 이 주소를 실제 물리 메모리 주소로 변환되어야 한다. 변환된 주소로 캐시를 검색해서 실제 물리 메모리를 접근하게 된다.

가상 메모리의 존재로 프로세스의 데이터가 디스크에 임시로 보관되어 있을 수 있다. 이 때, 해당 데이터를 메모리에서도 찾을 수 없을 가능성이 있으며 디스크의 프로세스 데이터를 메모리에 다시 적재한 후 메모리를 읽어야 한다.

## 5.1.8 분산 자원 지원

단일 장치의 디스크만으로는 빅데이터를 완전히 저장할 수 없다. 이를 해결하기 위해 분산 파일 시스템을 사용한다.

사용자 장치는 분산 파일 시스템을 직접 마운트할 수 있고, 로컬 디스크는 원격의 분산 파일 시스템에서 전송된 파일을 저장한다.

따라서 네트워크를 통하지 않고 로컬 디스크에 직접 접근하므로 원격의 분산 파일 시스템의 캐시로 간주된다.