# 2.5 콜백 함수를 철저하게 이해한다

## 2.5.1 모든 것은 다음 요구에서 시작된다

함수의 모듈을 여러 ‘현지화’ 요구대로 만드려면 조건문으로만은 설계가 부족하다.

- 각 케이스 별로 if ~ elseif 문이 수천 개가 필요해질 수도 있기 때문이다.

## 2.5.2콜백이 필요한 이유

함수는 매개변수를 사용함으로써 재사용성을 높일 수 있다.

여러 요구사항을 충족하도록 함수를 매개변수처럼 선언하여 ‘현지화’된 함수를 전달하면 수천개의 조건문 없이 문제를 해결할 수 있다.

```c
void formd_C(){
		...
}
make_donut(formd_C);
```

이를 콜백 함수라고 한다.

## 2.5.3 비동기 콜백

### Blocking 상태로 인한 무한 대기 상태

```c
make_donut(formed_D);
something_important();
```

위와 같은 코드일 때, 실행 환경이

1. 단일 스레드 환경
2. 대규모 데이터 처리 및 복잡한 연산(CPU Bound)
3. I/O 대기

일 때 make_donut()에서 대기로 인해 something_important()가 실행되지 않을 수 있다.

### 비동기 콜백 방식으로 새로운 스레드에게 위임

```c
void real_make_donut(func f){
		...
		f();
		...
}

void make_donut(func f){
		thread t(real_make_donut, f);
}

make_donut(formed_D);
something_important();
```

새로운 스레드를 생성하면 즉시 반환되고 이후 something_important()가 실행된다.

도넛은 스레드가 시작해야 생성이 되기 때문에 something_important()가 실행될 때 실제 도넛은 생성되지 않았을 수도 있다.

- 비동기는 순서를 보장하지 않는다.

호출 스레드(t)가 콜백 함수 실행(make_donut)에 의존하지 않는 것을 비동기 콜백이라고 한다.

## 2.5.4 비동기 콜백은 새로운 프로그래밍 사고방식으로 이어진다

비동기 호출 방식에서는 작업 처리가 두 부분으로 나뉘어 함수를 호출하는 스레드가 아닌 다른 스레도 또는 프로세스 또는 시스템에서 처리된다.

두번째 호출 부분은 프로그래머의 제어 범위를 벗어나며 ‘언제 실행될지’, ‘무엇을 하는지’를 알 수 없다. 때문에 콜백 함수에 프로그래머가 아는 정보를 담아 전달해야 한다.

- c언어 예시
    
    ```c
    #include <stdio.h>
    #include <pthread.h>
    #include <unistd.h>
    #include <stdlib.h>
    
    // 1. 전달하고 싶은 정보를 담은 구조체 (Context)
    typedef struct {
        char *userName;
        char *flavor;
    } OrderInfo;
    
    // 2. 콜백 함수 (나중에 시스템/스레드에 의해 실행됨)
    void my_callback(char *name, char *donut) {
        printf("\n[콜백 실행] %s님, 주문하신 %s이 완성되었습니다!\n", name, donut);
    }
    
    // 3. 비동기 작업을 수행하는 함수 (핵심 모듈)
    void* make_donut_worker(void *arg) {
        OrderInfo *info = (OrderInfo *)arg;
        
        printf("%s 도넛을 만들기 시작합니다...\n", info->flavor);
        sleep(3); // 3초 동안 도넛을 만드는 중 (비동기 작업 시뮬레이션)
        
        // 작업 완료 후, 전달받은 정보를 사용하여 콜백 호출
        my_callback(info->userName, info->flavor);
        
        free(info); // 동적 할당 해제
        return NULL;
    }
    
    int main() {
        // 4. 프로그래머가 아는 정보(이름, 맛)를 보따리(구조체)에 담음
        OrderInfo *myOrder = (OrderInfo *)malloc(sizeof(OrderInfo));
        myOrder->userName = "철수";
        myOrder->flavor = "초코";
    
        // 5. 비동기 호출 (스레드 생성)
        pthread_t thread_id;
        printf("메인 스레드: 도넛 주문을 비동기로 던집니다.\n");
        
        // 이 순간 제어권이 스레드로 넘어가며 프로그래머의 직접 제어를 벗어남
        pthread_create(&thread_id, NULL, make_donut_worker, (void *)myOrder);
    
        // 6. 메인 스레드는 기다리지 않고 자기 할 일을 함
        printf("메인 스레드: 도넛이 만들어지는 동안 다른 업무를 봅니다.\n");
        for(int i = 1; i <= 3; i++) {
            printf("메인 스레드 업무 중... %d\n", i);
            sleep(1);
        }
    
        pthread_join(thread_id, NULL); // 스레드 종료 대기
        return 0;
    }
    ```
    
    - my_callback은 전역에서 정의됐지만 실제 호출은 make_donut_worker(전역 환경이 아닌 외부, 또는 다른 스레드)가 한다. 이 때 미리 담아준 info로 누가 주문했는지 main에게 전달해준다.

## 2.5.5 콜백 함수의 정의

콜백 함수와 호출자는 서로 다른 계층에 존재한다.

서드 파티 라이브러리는 수단(HOW)를 제공한다. 이 결과값을 목적(WHAT)에 맞게 콜백 함수에 담아 전달하는 것이다. 

목적이란 이벤트(미래의 특정 시점), 결과 데이터 후처리 등 다양한 경우가 있다. 이러한 여러 목적을 대응하기 위해 역할을 분리하여 콜백 함수를 지정하는 것이다.

## 2.5.6 두가지 콜백 유형

동기 콜백을 하게 되면 다음과 같다. 이를 블로킹 콜백이라고도 한다.

```c
주스레드 - 호출                                 반환
            \ 라이브러리 함수 실행 - 콜백 함수 실행 /
```

비동기 콜백을 하게되면 다음과 같다.

```c
주스레드 - 호출 ------------------------------- 반환
            \ 라이브러리 함수 실행 - 콜백 함수 실행 /
```

- 호출이 즉시 완료되고 일정 시간이 지나면 콜백 함수가 실행된다.
- 이 때, 라이브러리가 실행되는 동시에 서로 다른 스레드에서 주 프로그램이 같이 실행될 수 있다.

## 2.5.7 비동기 콜백의 문제: 콜백 지옥

비동기 콜백으로 함수가 꼬리에 꼬리를 물면 어느 콜백에서 메모리를 해제해야 하는지 알 수 없어진다.

- c언어 예시
    
    ```c
    #include <stdio.h>
    #include <pthread.h>
    #include <stdlib.h>
    #include <unistd.h>
    
    // 데이터 구조체
    typedef struct {
        char *item;
    } Data;
    
    // 최종 단계: 배송 완료 콜백
    void on_delivery_complete(Data *d) {
        printf("[4] 최종 완료: %s 배송 성공!\n", d->item);
        free(d);
    }
    
    // 3단계: 배송 시작 (포장이 끝나야 실행됨)
    void* start_delivery(void *arg) {
        Data *d = (Data *)arg;
        printf("[3] 배송 중... (%s)\n", d->item);
        sleep(1);
        on_delivery_complete(d); // 다음 콜백 호출
        return NULL;
    }
    
    // 2단계: 포장하기 (제조가 끝나야 실행됨)
    void* start_packing(void *arg) {
        Data *d = (Data *)arg;
        printf("[2] 포장 중... (%s)\n", d->item);
        sleep(1);
        
        // 비동기로 배송 시작
        pthread_t t;
        pthread_create(&t, NULL, start_delivery, d);
        pthread_detach(t);
        return NULL;
    }
    
    // 1단계: 도넛 제조
    void* make_donut(void *arg) {
        Data *d = (Data *)arg;
        printf("[1] 도넛 제조 중... (%s)\n", d->item);
        sleep(1);
        
        // 비동기로 포장 시작
        pthread_t t;
        pthread_create(&t, NULL, start_packing, d);
        pthread_detach(t);
        return NULL;
    }
    
    int main() {
        Data *myDonut = (Data *)malloc(sizeof(Data));
        myDonut->item = "초코 도넛";
    
        printf("메인: 주문을 시작합니다.\n");
        make_donut(myDonut); // 지옥의 시작점
    
        // 메인 스레드가 종료되지 않도록 대기
        sleep(5);
        return 0;
    }
    ```
    

---

# 2.6 동기와 비동기를 철저하게 이해한다

## 2.6.1 고된 프로그래머

동기는 종속적, 연관된, 기다림의 성격이 드러나고, 비동기는 비종속적, 무관한, 기다릴 필요 없는, 동시 발생의 성격이 드러난다.

## 2.6.2 전화 통화와 이메일 보내기

전화 통화의 경우 A가 말할 때 B는 계속 기다려야 하므로, 의존성, 연관된, 기다림 등의 이미지가 떠오른다.

이메일의 경우 내가 작성하는 동안 다른 사람도 같이 작성할 수 있다. 마찬가지로 내가 이메일 작성과 발송 후 기다림과 동시에 다른 일을 처리할 수 있다.

## 2.6.3 동기 호출

### 예제 코드

```c
funcA(){
		...
		
		funcB(); // funcB가 완료될 때까지 기다림
		
		// funcB는 프로세스를 반환하고 계속 진행함
		...
}
```

funcA가 funcB를 호출하면 funcB가 실행 완료될 때까지 funcA의 나머지 코드는 실행되지 않는다.

따라서 반드시 funcB가 끝날 때까지 기다려야 하며, 이것이 동기 호출이다.

파일 입출력의 경우에도 읽기 스레드가 다른 스레드이고, 호출자가 잠시 대기하고 읽기 스레드가 실행 중일 뿐이다.

## 2.6.4 비동기 호출

디스크의 파일 읽고 쓰기, 네트워크 데이터 송수신, 데이터베이스 작업 처럼 시간이 많이 걸리는 IO 작업을 백그라운드로 실행하다.

따라서 파일 읽기 작업이 완료되지 않은 상대에서도 읽기 함수는 즉시 반환될 수 있다.

- 파일 읽기 작업과 함수는 동시에 실행되기 때문이다.

비동기 호출(파일 읽기 작업)이 완료에 따라 그 결과를 어떻게 처리해야 할까?

### 호출자가 실행 결과를 전혀 신경쓰지 않을 때

콜백 함수를 사용해서 파일 읽기 작업을 비동기 호출할 때 파일 내용을 처리하는 함수를 매개변수로 전달할 수 있다.

### 호출자가 실행 결과를 반드시 알아야 할 때

파일 읽기 작업이 완료되면 호출자에게 작업 완료를 나타내는 신호나 메시지를 보낸다. 이 경우 결과 처리는 함수 호출 스레드에서 한다.

## 2.6.5 웹 서버에서 동기와 비동기 작업

### 주 스레드가 데이터베이스 처리 결과를 전혀 신경쓰지 않을 때

동기 방식에서는 주 스레드의 유휴시간 때문에 앞의  데이터베이서 처리가 완료될 때까지 기다려야 한다.

반대로 비동기 방식으로는 유휴시간 대신 그 자리를 끊임없이 다음 작업으로 계속 이어지므로 동기 방식보다 요청 처리 속도가 훨씬 더 빨라진다.

### 주 스레드가 데이터베이스 작업 결과에 관심을 가질 때

알림 방식을 이용해 주 스레드가 메시지를 수신하면 이전 사용자 요청의 후반부를 계속 처리한다. 비동기 호출만큼 극단적으로 효율적이지는 않지만 동기보다는 효율적이다.

---

# 2.7 아 맞다! 블로킹과 논블로킹도 있다

## 2.7.1 블로킹과 논블로킹

함수A가 함수B를 호출할 때, 함수B를 호출함과 동시에 os가 함수A가 실행 중인 스레드나 프로세스를 일시중지 시킨다면 함수B에 대한 호출 방식은 블로킹이다. 그렇지 않다면 논블로킹 방식이다.

## 2.7.2 블로킹의 핵심 문제: 입출력

사람의 입출력 속도가 너무 느리기 때문에, 함수A의 입출력 중간중간에 블로킹하고 함수B에게 넘겨주어 cpu 자원을 효율적으로 할당한다.

## 2.7.3 노블로킹과 비동기 입출력

네트워크 데이터 수신이 논블로킹 호출의 예이다. recv 함수를 호출할 때 os는 스레드를 일시 중지시키는 대신 즉시 반환하여 호출 스레드가 이후 작업을 계속하도록 한다.

## 2.7.4 피자 주문에 비유하기

블로킹 호출은 피자 가계에서 직접 가서 주문하는 것에 비유할 수 있다. 피자가 완성될 때까지 가게 안에서 기다리고 있어야 한다. 즉, 블로킹 된 것으로 볼 수 있다.

논블로킹 호출은 전화로 피자를 주문하는 것에 비유할 수 있다. 피자가 완성될 때까지 다른 일을 할 수 있다. 논블로킹 호출 상황에서 인내심에 따라 다음과 같은 상황이 있다.

### 매우 인내심이 강한 경우

언제 배달이 도착하는지는 관심 없고 도착하면 전화가 올 것이기 때문에 계속 자기 할 일만 하고 있는다.

### 인내심이 부족한 경우

5분마다 전화를 걸어 피자가 완성되었는지 물어본다. 전화만 하게 된다면 동기와 다를 바가 없어진다는 특징이 있다.

## 2.7.6 비동기와 논블로킹

```c
void handler(void *buf){
		// 수신된 네트워크 데이터를 처리합니다.
}

while (1){
		fd = accept();
		recv(fd, buf, NON_BLOCKING_FLAG); //호출 후 바로 반환, 논블로킹
		
		while (!check(fd){
				// 순환감지
		}
		
		handler(buf);
}
```

recv 함수는 논블로킹으로 호출되지만 while문에 의해 끊임없이 호출되기 때문에(eg. 인내심이 부족한 경우) 전체적인 관점에서 보면 동기라고 할 수 있다.

반복문에서 cpu 리소스가 쓸데없이 소모되므로 매우 비효율적이라고 할 수 있다.

---

# 2.8 높은 동시성과 고성능을 갖춘 서버 구현

## 2.8.1 다중 프로세스

다중 프로세스 병행 처리의 장점은 다음과 같다.

1. 프로그래밍이 간단해서 이해하기 쉽다.
2. 개별 프로세스의 주소 공간은 서로 격리되어 있어서 한 프로세스가 강제종료되더라도 다른 프로세스에게 영향을 끼치지 않는다.
3. 다중 코어 리소스를 최대한 활용할 수 있다.

그러나 단점 또한 있다.

1.  각 프로세스의 주소 공간이 격리되어있기 때문에 통신이 필요할 때 난이도가 올라간다.
2. 스레드보다는 프로세스가 부담이 커서 빈번한 생성과 종료는 시스템의 부담을 증가시킨다.

## 2.8.2 다중 스레드

다중 스레드의 장점은 다음과 같다.

1. 프로세스의 주소 공간을 공유하기 때문에 통신을 위한 별도의 통신 작동 방식이 필요없고 스레드 안전이 보장된다.
2. 매우 가볍고 생성과 종료에 드는 부담이 적다.
3. 스레드 중 일부가 블로킹되더라도 다른 스레드에게는 영향을 미치지 않는다.

단점은 다음과 같다.

1. 한 스레드에 문제가 발생해 강제종료되면 같은 프로세스를 쓰던 스레드들도 같이 강제 종료 된다.
2. 같은 프로세스 주소 공간을 사용하기 때문에 동시에 공유 리소스의 데이터를 읽고 쓸 수 없다.
    - 동기화 시 상호배제와 같은 방식을 사용해야 한다.
3. 교착상태를 일으킬 수 있다.

## 2.8.3 이벤트 순환과 이벤트 구동

이벤트 순환은 이벤트가 도착할 때까지 기다렸다가 도착하면 유형을 확인하고 대응되는 이벤트 핸들러를 호출한다.

## 2.8.4 첫 번째 문제: 이벤트 소스와 입출력 다중화

여러 개의 이벤트를 어떻게 하나씩 가져올 수 있을까?

이벤트와 이벤트 순환 사이에 epoll을 넣어 입출력 다중화 방식을 구현한다. 이벤트 하나에 해당하는 소켓 여러개를 감시하다가 데이터가 들어오면 이벤트 순환에 넘겨주게 된다.

## 2.8.5 두 번째 문제: 이벤트 순환과 다중 스레드

다음 두 가지의 경우 이벤트 순환을 동일한 스레드에서 실행할 수있다.

1. 입출력 작업이 전혀 없다.
2. 처리 함수가 간단해서 처리 시간이 매우 짧다.

그러나 사용자의 요청을 처리하는데 cpu 시간을 많이 소모하게 된다면 다중 스레드 환경이 필요하다. 이벤트 핸들러가 각 스레드 하나씩 분배하여 요청 속도를 가속화한다. 이러한 설계 방법을 반응자 패턴이라고 한다.

## 2.8.6 카페는 어떻게 운영되는가: 반응자 패턴

주방에 쉐프 한 명과 요리사가 있다고 했을 때, 요리사 한 명이 요리 하나를 담당하여 역할을 분배하는 방식이 반응자 패턴에 해당한다.

## 2.8.7 이벤트 순환과 입출력

### 입출력 작업에 대응하는 논블로킹 인터페이스가 있는 경우

논블로킹 인터페이스는 작업을 요청만 하고 결과를 기다리지 않고 바로 반환된다. 그래서 이벤트는 블로킹 되지 않는다.

결과적으로 스레드 관리 없이, 이벤트 순환(단일 스레드) 내에서 수많은 입출력 요청을 한꺼번에 처리할 수 있다.

### 입출력 작업에 블로킹 인터페이스만 있는 경우

이벤트 순환 내에서 어떤 블로킹도 호출하면 순환 스레드 자체가 일시중지되기 때문에 전체 시스템이 종료된다. 그래서 블로킹 입출력 호출이 포함된 작업은 다른 스레드에게 전달해서 별도의 이벤트로 수행한다.

## 2.8.8 비동기와 콜백 함수

하나의 요청에 4개의 서비스가 관여한다고 하자.

각 상황에 따라 스레드를 여는 방법은 스레드 스케줄링과 전환에 큰 비용이 들고 cpu의 불필요한 리소스를 차지하게 된다.

따라서 비동기 호출로 수정하여 4개의 서비스를 이벤트로 분배한다.

## 2.8.9 코루틴: 동기 방식의 비동기 프로그래밍

코루틴의 도움으로 동기 방식으로 프로그래밍하더라도 비동기 실행과 같은 효과를 얻을 수 있다.

코루틴이 한 핸들러에서 일시 중지되면 준비 완료된 다른 코루틴을 실행하기 위해 전환되며, 일시 중지된 코루틴에 핸들러가 응답한 후 처리 결과를 반환하면 다시 준비 상태가 되어 스케줄링 되기를 대기한다.

전체 구조는 다음과 같다.

```c
IO(n) -> epoll -> 이벤트 순환 스레드 -> 코루틴 생성 -> 준비된 코루틴(m) -> 각 스레드에서 코루틴 실행(m)
```

## 2.8.10 CPU, 스레드, 코루틴

CPU가 커널 상태 스레드를 생성하고 스케줄링을 한다. 스레드 우선순위에 따라 CPU 연산 리소스를 할당한다.

프로그래머는 스레드에 할당된 시간 내 실행할 코루틴을 결정하여 CPU 시간을 사용자 상태에서 재차 할당한다.

---

# 2.9 컴퓨터 시스템 여행: 데이터, 코드, 콜백, 클로저에서 컨테이너, 가상머신까지

## 2.9.1 코드, 데이터, 변수, 포인터

비효율적인 반복을 피하기 위해 변수, 함수, 포인트가 생겼다.

## 2.9.2 콜백 함수와 클로저

콜백 함수가 정의된 A에서만 얻을 수 있고, 콜백 함수를 실행한 B에서는 얻을 수 없는 실행 시간이나 환경이나 데이터를 사용해야할 때가 있다. 이러한 정보를 콜백 함수와 한데 묶어 변수로 취급할 때 클로저가 생성된다.

```python
def add():
	b=10
	
	deg add_inner(x):
		return b + x
f = add()
print(f(2))
```

위의 코드에서 add_inner 함수는 실행 시간 환경인 b 변수를 묶어서 전달하는 클로저라고 할 수 있다.

## 2.9.3 컨테이너와 가상 머신 기술

컨테이너의 장점은 다음과 같다.

1. 서로 격리되어있다.
2. 장시간 반복 사용이 가능하다.
3. 적재와 하역이 빠르다.
4. 항구와 선박에서 사용되는 표준 크기로 구성되어있다.

컨테이너는 os에서 제공하는 기능으로 프로세스를 격리하고 CPU, 메모리, 디스크에 대한 접근을 제어하는 방식으로 컨테이너에 포함된 프로세스가 전체 os 안에서 자기 자신의 프로세스만 존재하고 있다고 가상화 하게 된다.

가상화 기술은 sw로 hw를 추상화하고 hw 리소스를 가상 컴퓨터 여러 개로 나눈다. 그 위에서 os를 실행한 것을 가상 머신이라고 한다. 이들 밑의 기반으로써 여러개의 가상머신을 관리하는 가상 머신 감시자가 있고 이를 하이퍼바이저라고 한다.