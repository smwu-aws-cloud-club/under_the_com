# 4.1 이 작은 장난감을 CPU라고 부른다 

## 4.1.1 위대한 발명 

- 트랜지스터(transistor)
- 프로그래머가 작성한 프로그램이 아무리 복잡해도 소프트웨어가 수행하는 기능은 최종적으로 이 작은 물건의 간단한 계폐 작업으로 완성 

## 4.1.2 논리곱, 논리합, 논리부정 

- 논리곱 게이트
- 논리합 게이트
- 논리부정 게이트 

## 4.1.3 도는 하나를 낳고, 하나는 둘을 낳고, 둘은 셋을 낳으며, 셋은 만물을 낳는다 

- 논리적 완전성(logical completeness) -> 논리곱 게이트, 논리합 게이트, 논리부정 게이트로 모든 논리 함수 표현 가능 
- 충분한 논리곱 게이트, 논리합 게이트, 논리부정 게이트가 있으면 어떤 논리 함수도 구현 가능 
- 이외에는 어떤 형태의 논리 게이트 회로도 필요하지 않음 

## 4.1.4 연산 능력은 어디서 나올까? 

- 배타적 논리합 -> 두 입력 값이 서로 다르면 결과가 1이고 두 입력 값이 서로 같으면 결과가 0 
- 논리곱 게이트와 배타적 논리합 게이트를 이용해 이진수 덧셈 구현 
- 간단한 연산으로 가산기(adder) 구현 

## 4.1.5 신기한 기억 능력 

- 입력과 출력은 정보를 저장할 수 있는 회로가 필요 
- 정보를 '기억'하는 회로 -> 부정 논리곱 게이트 두 개를 조합 
- 부정 논리곱 게이트 -> 먼저 논리곱 연산을 처리한 후 논리부정 연산을 처리
- 1과 0을 입력했다면 논리곱 연산한 결과는 0이 되고 논리부정 연산한 결과는 1이 됨 -> 부정 논리곱 게이트 

## 4.1.6 레지스터와 메모리의 탄생 

- 4비트를 저장할 수 있는 회로
- 조합회로 -> 레지스터(register) 
- 더 많은 정보 저장/주소 지정(addressing) 기능 제공/더 복잡한 회로 구축 
- 8비트를 1바이트로 규정하고 각각의 바이트에 번호를 부여 -> 회로에 저장된 정보 읽기 -> 메모리(memroy) 탄생 
- 레지스터와 메모리 모두 회로와 연결되어 있어야 함 

## 4.1.7 하드웨어 아니면 소프트웨어? 범용 장치

- 모든 논리 함수를 논리곱 게이트, 논리합 게이트, 논리부정 게이트를 사용하여 구현해야 할 필요가 있는가? 
- 하드웨어는 소프트웨어를 기준으로 다양한 논리함수 창조 가능 
- 모든 연산 논리를 반드시 회로 같은 하드웨어로 구현할 필요는 없음 
- 하드웨어는 변하지 않지만 소프트웨어는 변할 수 있기에 
-> 변하지 않는 하드웨어에 서로 다른 소프트웨어를 제공 -> 하드웨어가 완전히 새로운 기능 제공 가능 
- 서로 다른 소프트웨어가 설치된 컴퓨터는 서로 다른 기능을 가질 수 있음 

## 4.1.8 하드웨어의 기본 기술: 기계 명령

- CPU에게 조합 회로를 이용해 실행되는 기계 명령어로 명령함
- CPU 표현 방식은 명령어 집합을 이용하여 구현됨 

## 4.1.9 소프트웨어와 하드웨어 간 인터페이스: 명령어 집합 

- 명령어 집합(instruction set) -> CPU가 실행할 수 있는 명령어(opcode)와 각 명령어에 필요한 피연산자(operand) 묶음 
- 서로 다른 유형의 CPU는 서로 다른 명령어 집합을 가짐 

## 4.1.10 회로에는 지휘자가 필요하다 

- 회로는 연산 및 저장 능력을 가지며 명령어로 회로에 명령 가능함 
- 각 회로가 함께 작업 가능하도록 조정하거나 동기화하려면 어떻게 해야 하는가? 
- CPU에서 지휘자 역할(회로의 조정) -> 클럭 신호(clock signal)
- 클럭 신호가 전압을 변경하면 전체 회로의 각 레지스터, 즉 전체 회로 상태가 갱신됨 -> 전체 회로가 함께 동작 가능
- 클럭 주파수-> 1초 동안 지휘봉을 흔드는 횟수
- 클럭 주파수가 높을 수록 CPU가 1초에 더 많은 작업을 할 수 있음 

## 4.1.11 큰일을 해냈다, CPU가 탄생했다! 

- 계산이 가능한 산술 논리 장치, 정보 저장 가능한 레지스터, 작업을 함께하도록 제어하는 클럭 신호의 묶음
-> 중앙 처리 장치(central processing unit), 즉 CPU 또는 프로세서(processor) 

# 4.2 CPU는 유휴 상태일 때 무엇을 할까? 

## 4.2.1 컴퓨터의 CPU 사용률은 얼마인가? 

- 많은 프로세스는 기본적으로 아무 작업도 하지 않으며 대기 상태임 
- 나머지 CPU 시간은 어디로? 

## 4.2.2 프로세스 관리와 스케줄링 

- 프로그램이 메모리에서 실행되면 프로세스 형태로 존재하며 프로세스가 생성되면 OS가 관리하고 스케줄함
- OS가 프로세스를 관리하는 방법은? 
- OS는 프로세스에 우선순위를 할당하고 우선순위에 따라 
스케줄러(scheduler)가 스케줄링을 할 수 있도록 상응하는  대기열에 프로세스를 넣음
 
## 4.2.3 대기열 상태 확인: 더 나은 설계 

- 커널 설계자는 유휴 작업이라는 프로세스 생성 -> 윈도우의 'System Idle Process'
- 시스템에 스케줄링 가능한 프로세스가 없을 때 스케줄러는 유휴 프로세스를 꺼내서 실행함 
- 유휴 프로세스는 항상 준비 완료 상태에 있으며 우선순위는 가장 낮음 
- 시스템에 할 일이 없으면 유휴 프로세스가 실행되는데 얘는 무엇을 할까? 

## 4.2.4 모든 것은 CPU로 돌아온다 

- 시스템에 유휴 상태가 존재할 가능성을 고려해서 '정지'를 의미하며 설계한 기계 명령어 -> halt 명령어
- CPU 내부의 일부 모듈을 절전 상태로 전환해 전력 소비를 크게 줄임 
- halt 명령어도 실행을 위해 순환에 배치 bcz 절전 상태의 유지 
- halt 명령어는 특권 명령어이기에 커널 상태에서 CPU로만 실행 가능함 
- 일시 중지(suspend)와 halt 명령어 혼동 주의 
- sleep 와 같은 함수를 호출하면 해당 함수를 호출한 프로세스만 일시 중지되는데
이때 프로세스가 여전히 실행 상태라면 CPU는 유휴 상태로 진입 불가능 
- CPU가 halt 명령어를 실행한다는 것 -> 시스템 내 더 이상 실행할 준비가 완료된 프로세스가 없음 

## 4.2.5 유휴 프로세스와 CPU의 저전력 상태 

- halt 명령어를 지속적으로 실행해주는 순환이 있어 유휴 작업 프로세스는 이미 구현 완료 상태 
- 스케줄링 가능한 프로세스가 더 이상 없다면 스케줄러가 유휴 플세스를 실행하는데 순환 구조에서 계속 halt 명령어를 실행 
- halt 명령어로 CPU는 저전력 상태로 진입 
- 컴퓨터의 시스템이 유휴 상태일 때 CPU는 halt 명령어를 실행함 
- 전세계에 있는 모든 CPU가 대부분의 시간을 이 명령어에 쓰이는 것이 신기하지 않음? 

## 4.2.6 무한 순환 탈출: 인터럽트 

- 순환은 무한 순환 구조 형태인데 OS는 어떻게 빠져나오는가? 
- 컴퓨터 OS는 일정 시간마다 타이머 인터럽트(timer interrupt)를 생성 -> CPU는 인터럽트 신호를 감지하고 OS 내부의 인터럽트 처리 프로그램을 실행함 -> 상응하는 인터럽트 처리 함수에서 프로세스가 실행될 준비가 되었는지 판단 -> 준비가 되었다면 중단되었던 프로세스 실행 /준비되어 있지 않다면 프로세스를 일시 중지시키고 스케줄러는 준비 완료 상태인 다르 프로세스를 스케줄링 
- 프로그램에 무한 순환이 있더라도 OS는 여전히 타이머 인터럽트를 통해 프로세스의 스케줄링 제어 가능하고 무한 순환이 있다고 OS까 실행하지 못하는 문제는 발생하지 않음 

# 4.3 CPU는 숫자를 어떻게 인식할까? 

## 4.3.1 숫자 0과 양의 정수 

- 컴퓨터 시스템의 2진법 
- 비트 k개를 사용하면 정수 2^k 개 나타내기 가능 
- 범위는 0~2^k-1이고 k가 8개인 8비트라면 표현 가능한 범위는 0~255 -> 부호 없는 정수(unsigned integer)에 해당 

## 4.3.2 부호 있는 정수 

- 양의 정수를 표현하는 방법 -> k 비트가 주어지면 2^k개 표현 가능 
- 비트가 4개 있을 때 이를 이용해서 표현할 수 있는 부호가 없는 정수는 0~15 
- 부호가 있는 정수를 표현하려면 절반은 `~7에 나누어주고 나머지 절반은 -1~7에 나누어주기 
- 최상위 비트(most significant bit)가 정수 부호를 결정 -> 0이면 양수/0이 아니면 음수 

## 4.3.3 양수에 음수 기호를 붙이면 바로 대응하는 음수: 부호-크기 표현 

- 부호-크기 표현(sign-magnitude) 

## 4.3.4 부호-크기 표현의 반전: 1의 보수 

- 1의 보수(one's complement)
- 부호 있는 숫자는 부호-크기 표현이든 1의 보수 표현이든 모두 표현 가능하니 상관 없지 않나? 
- 두 숫자를 더하는 문제가 발생 

## 4.3.5 간단하지 않은 두 수 더하기 

- 컴퓨터의 덧셈은 가산기 조합 회로로 구현 
- 부호-크기 표현이나 1의 보수를 이용하여 덧셈을 계산하려면 두 가지 방식 모두 부호 있는 숫자의 정확한 덧셈을 보장하는 조합 회로를 추가하는 것이 불가피 -> 회로 설계의 복잡도를 증가 

## 4.3.6 컴퓨터 친화적 표현 방식: 2의 보수 

- 2의 보수(two's complement)
- 2의 보수에는 -0 이라는 표현이 없으며 1의 보수로 표현한 양수에 을 더하면 2의 보수에서 대응하는 음수가 된다는 것 

## 4.3.7 CPU는 정말 숫자를 알고 있을까? 

- 가산기는 양수와 음수에 대해 신경을 쓰지 않으며 근본적으로 연속된 숫자가 가지고 있는 의미도 이해하지 못함 
- 두 비트의 배타적 논리합 연산이 덧셈의 결과라는 것/두 비트의 논리곱 연산이 자리 올림수라는 것만 알고 있음 
- 프로그래머 -> 사고 문제를 프로그램 방식으로 표현
- 컴파일러 -> 인간이 이해할 수 있는 프로그램을 CPU를 제어하는 0과 1로 구성된 기계 명령어로 변환 
- CPU는 근본적으로 어떤 프로그래밍 언어도 이해하지 못하며 프로그래밍 언어를 이해하는 것은 컴파일러 

# 4.4 CPU가 if 문을 만났을 때

## 4.4.1 파이프라인 기술의 탄생 

- 조립 라인 기술 -> 전체 공정 단계를 수십 개로 나누고 각 단계마다 전문가 배치 
- 조립 라인은 전체 자동차 조립 시간을 줄이는 것이 아니라 공장의 처리 능력을 늘리는 것 

## 4.4.2 CPU: 메가팩토리와 파이프라인 

- CPU 자체를 하나의 메가팩토리(megafactory)로 볼 수 있음 -> 기계 명령어를 실행
- CPU는 1초에 수십억 개의 기계 명령를 실행할 수 있기에 명실상부한 효율 좋은 조립 라인 
- CPU가 기계 명령어를 처리하는 과정
1. 명령어 인출(instruction fetch)
2. 명령어 해독(instruction decode)
3. 실행(execute)
4. 다시쓰기(writeback)
- 각 단계는 별도의 하드웨로 처리
- 현재 CPU는 기계 명령어를 초당 수십억 개 처리할 수 있으며 파이프라인(pipeline) 기술은 필수적 

## 4.4.3 if가 파이프라인을 만나면

- if문을 컴파일러가 조건부 점프 명령어로 변환하고 해당 명령어는 분기 역할을 함 
- 조건이 참이면 점프하고 그렇지 않으면 순차적으로 실행
- 그러나 조건부 점프 명령어를 실행하기 전까지는 점프해야하는지 알 수 없으며 이는 파이프라인에 영향을 미침 
- CPU에서는 분기 점프 명령어가 실행을 완료하기 전에 다음 명령어는 이미 파이프라인에 들어가 있어야 함
- 그렇지 않으면 파이프라인에 '빈 공간'이 생겨 프로세서의 리소스를 완전하게 사용할 수 없음
- 명령어 실행이 완료되지 않은 시점에서 CPU는 어떤 분기의 명령어를 파이프라인에 넣어야 할지 어떻게 알 수 있는가? -> 예측

## 4.4.4 분기 예측: 가능한 한 CPU가 올바르게 추측하도록 

- CPU는 분리할 가능성을 추측 
- 추측이 맞으면 파이프라인은 전진 틀리면 파이프라인에서 실행 중이던 잘못된 분기 명령어를 전부 무효화 
-> 추측이 틀리면 바로 성능 손실
- 최신 CPU의 이러한 '추측' 과정을 분기 예측이라고 함 -> 프로그램 실행 이력을 기반으로 예측을 실행 
- 배열이 정렬되어 있으면 CPU의 추측은 거의 전부 들어맞음
- 배열이 정렬되어 있지 않다면 분기 예측 실패율이 높아지고 프로그램 성능이 떨어짐 
- 프로그래밍 언어의 likely/unliekely 매크로(macro) -> 컴파일러에 가능성이 더 높은 분기를 알려줌 
- 프로그래머가 고급 프로그래밍 언어를 사용해 코드를 작성할 때 특정 상황에서는 여전히 CPU에 신경을 써야 함 

# 4.5 CPU 코어 수와 스레드 수 사이의 관계는 무엇일까? 

## 4.5.1 레시피와 코드, 볶음 요리와 스레드 

- CPU는 기계 명령어에 따라 프로세스와 스레드를 실행 
- OS 입장에서 CPU가 사용자 상태에서 실행하는 명령어는 스레드 또는 특정 스레드에 속해 있음 
- CPU 코어 수와 스레드 수 사이에는 어떤 필연 관계도 없음 
- CPU는 하드웨어인데 반해 스레드는 소프트웨어 개념, 즉 실행 흐름이자 작업임
- 단일 코어 시스템에서도 충분히 많은 스레드를 생성 가능 -> 충분한 메모리와 제한 없는 OS 
- CPU는 자신이 실행하는 명령어가 어떤 스레드에 속하는지 이해 X -> CPU 입장에서도 이해할 필요 X 
- OS가 이해해야 함
- CPU는 PC 레지스터 주소에 따라 메모리에서 기계 명령어를 꺼내 실행하는 것만 하면 됨 
- 스레드를 사용하는 일반적인 상황에서 CPU 코어 수에 주의가 필요함 

## 4.5.2 작업 분할과 블로킹 입출력 

- 단일 코어 시스템에서 CPU는 일정 시간 동안 단 하나의 스레드만 실행할 수 있기에 
스레드 여러 개가 번갈아 실행은 가능하지만 병렬 처리는 아님
- 단일 코어에서 다중 스레드가 의미가 없나? NO
- 여러 개로 분할된 하위 작업을 별도의 스레드에서 배치하면 OS에서는 이를 스케줄링하고 실행하므로 동시에 여러 작업 실행 가능 
- 스레드가 특정 작업을 기다리지 않고 진행하는 것이라면 필요에 따라 스레드 여러 개를 생성하고 작업을 분할하여 스레드에서 실행 가능
- 시스템이 단일 코어인지 다중 코어인지는 신경 쓸 필요가 없음 

## 4.5.3 다중 코어와 다중 스레드 

- 2003년부터 다중 코어 시스대가 도래했는데 단일 코어의 성능을 끌어올리기가 어려웠기 때문 -> 스레드 개념 유행 
- 다중 프로세스도 다중 코어를 최대한 활용할 수 있지만 번거로움 -> 더 복잡한 프로세스 간 통신 방식과 전환에 드는 비용이 문제 
- 다중 코어 리소스를 최대한 활용해야 할 때 프로그래머가 선호하는 도구는 스레드 
- 스레드는 일정한 입출력과 동기화 등이 필요하므로 스레드 수를 적당히 늘려 OS가 CPU에 할당할 수 있는 충분한 스레드를 확보하면 시스템 성능을 향상시킬 수 있음 
- 스레드 수가 한계에 달하면 OS 성능이 떨어지기 시작하는데 한 스레드에서 다른 스레드로 전환할 때 부담이 증가하기 때문 

# 4.6 CPU 진화론(상): 복잡 명령어 집합의 탄생 

## 4.6.1 프로그래머의 눈에 보이는 CPU

- 우리가 작성하는 모든 프로그램은 컴파일러로 간단한 기계 명령어로 변환
- CPU 입장에서는 프로그램에 따른 차이가 없음 -> 명령어가 많은가 적은가의 창
- 명령어는 실행 파일에 저장되며 프로그램이 실행되면 메모리에 적재됨 -> CPU는 단순히 메모리에서 명령어를 읽어서 실행 

## 4.6.2 CPU의 능력 범위: 명령어 집합 

- CPU는 유형에 따라 고유한 능력 범위를 가짐 
- CPU의 능력 범우에는 특별한 이름 명령어 집합(instuction set architecture)이 있음 -> 여러가지 명령어가 포함 
- 명령어 집합은 CPU를 설명할 때에만 사용됨 
- 서로 다른 형태의 CPU는 다른 유형의 명령어 집합을 가지고 있음 
- 첫 번째 명령어 집합 유형이자 처음으로 탄생한 명령어 집합인 복잡 명령어 집합 컴퓨터(Complex Instruction Set Computer, CISC)

## 4.6.3 추상화: 적을수록 좋다 

- 프로그램이 직접 어셈블리어로 작성되었던 시기에는 명령어 집합이 더 풍부하고 명령어 기능도 강해야 한다고 여김 
- 프로그래머에게는 자주 사용하는 작업마다 대응하는 특정 명령어가 있는 것이 합리적 
-> 모든 사람이 어셈블리어로 직접 프로그램을 작성했기 때문에 매우 편리한 방식 
- 의미상 간격(semantic gap) 이어주기 
- 기계 명령어와 고급 언어 개념 간의 차이를 줄여야 더 적은 코드로 더 많은 작업을 할 수 있음 

## 4.6.4 코드도 저장 공간을 차지한다 

- 폰 노이만 구조(Von Neumann architecture) -> 저장 개념에서 프로그램과 프로그램이 사용하는 데이터에 어떤 차이도 없어야 하며
모두 컴퓨터의 저장 장치 안에 저장될 수 있어야 함 
![Image](https://github.com/user-attachments/assets/89d86b14-cc63-45c2-8c78-bab81971fa7d)
- 폰 노이만 주고에서 실행 파일은 기계 명령어와 데이터를 모두 포함 
- 프로그래머가 작성한 코드는 디스크 저장 공간을 차지하며 실행 시에는 메모리에 적재되므로 메모리 저장 공간을 차지함 
- 인텔 1103 메모리 칩의 출시 -> 컴퓨터 업계에 동적 램(DRAM) 시대의 서막 -> 메모리 
- 작은 메모리에 더 많은 프로그램을 적재하려면 기계 명령어를 매우 세밀하게 설계해서 프로그램이 차지하는 저장 공간 줄이기 

1. 하나의 기계 명령어로 더 많은 작업을 완료할 수 있으므로 프로그래머가 더 휴율적으로 코드를 작성할 수 있게 해준다.
2. 기계명령어 길이가 고정되어 있지 않다. 기계명령어 길이가 가변적이므로 프로그램 자체가 차지하는 저장공간을 줄일 수 있다
3. 기계 명령어는 밀도를 높여 공간을 절약하려고 고도로 인코딩된다

## 4.6.5 필연적인 복잡 명령어 집합의 탄생 

- 이 시기 CPU 명령어 집합은 모두 직접 연결(hardwired) 방식 -> 명령어 인출, 해독, 실행 등 각 단계가 특정 조합 회로로 직접 제어 
- 명령어 실행에는 효율적이지만 유연성이 떨어지기에 명령어 집합의 변경에 대응하기 어려움 
- 새로운 명령어를 추가하면 CPU 설계와 디버깅 복잡도가 높아지며 특히 복잡 명령어 집합의 명령어는 길이가 고정되어 있지 않아
명령어에 복잡한 연산이 포함되면 문제가 악화됨 
- 하드웨어를 변경하는 것은 번거로집만 소프트웨어는 쉽게 변경 가능 
- 대부분의 명령어에 포함된 연산을 더 간단한 명령어로 구성된 작은 프로그램으로 정의하고 CPU에 저장하면 모든 기계 명령어에 대응하여 전용 하드웨어 회로를 설계할 필요가 없음 -> 소프트웨어가 하드웨어를 대체 -> 마이크로코드(microcode) 
- 더 많은 명령어를 추가할 때 주요 작업은 마이크로코드 수정에 집중 -> 하드웨어 수정은 거의 필요 X -> CPU 설계 복잡도를 낮춤 

## 4.6.6 마이크로코드 설계의 문제점 

- 복잡 명령어 집합이 등장하며 프로그램어는 어셈블리어로 프로그램을 더 쉽게 작성하고 이로 인해 발생하는 프로세서 설계의 복잡한 문제는 마이크로코드로 단순화할 수 있게 됨 -> 설계가 문제를 발생시킴 
- 마이크로코드의 버그를 수정하는 것은 일반 프로그램의 버그를 수정하는 것보다 후러씬 어려우며 트랜지스터를 매우 많이 소모함 
- 마이크로코드가 야기한 복잡한 문제는 해결하기 어려우며 마이크로코드 자체가 해결해야 하는 대상 