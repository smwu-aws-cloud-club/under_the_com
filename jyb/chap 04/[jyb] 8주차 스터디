# 4.7 CPU 진화론(중): 축소 명령어 집합의 탄생 

## 4.7.1 복잡함을 단순함으로 

- 80-20 법칙(80-20 rule)을 빌프레드 파레토가 발견 
- CPU는 약 80% 시간 동안 명령어 집합의 기계 명령어 중 20%를 실행
- 복잡 명령어 집합에서 비교적 복잡한 명령어 중 일부는 자주 사용되지 않으며 
컴파일러를 설계하는 프로그래머는 고급 언어를 더 간단한 기계 명령어의 조합으로 변환하는 경향이 있음 
- 복잡 명령어 집합에서 선응을 향상시키는 것으로 여겨지는 명령어 -> 실제로 CPU 내부에서 마이크로코드에 의해 가로막힘
- 따라서 마이크로코드를 제거하면 오히려 프로그램이 더 빠르게 실행 , CPU를 구성하는 트랜지스터 절약 가능 
- 복잡한 명령어를 간단한 명령어 여러 개로 대체하면 안 되는 이유?

## 4.7.2 축소 명령어 집합의 철학

- 복잡 명령어 집합에 대한 반성을 바탕으로 축소 명령어 집합(reduced instuction set) 철학의 탄생 -> 3가지 측면

1. 명령어 자체의 복잡성 
- 복잡한 명령어를 제거하고 대신 간단한 명령어 여러 개로 대체하는 매우 단순한 아이디어 
- CPU 내부 마이크로코드 설계가 필요하지 않음 -> 마이크로코드가 없으면 컴파일러에서 생성된 기계 명령어의 CPU 제어 능력 크게 향상
- 명령어 집합을 줄인다 -> 하나의 명령어 당 들여야 하는 연산이 더 간단하다

2.컴파일러
- 컴파일러가 CPU에 대해 더 강력한 제어권을 가짐
- 축소 명령어 집합을 사용하는 CPU는 더 많은 세부 사항을 컴파일러에 제공
- 축소 명령어 집합은 '흥미로운 작업을 컴파일러에 넘기기(Relegate Interesting Stuff of Complier) 라는 이름으로 불림 

3. LOAD/STORE 구조 
- 축소 명령어 집합의 명령어는 레지스터 내 데이터만 처리 가능/메모리 내 데이터는 직접 처리 불가능
- 그러나 데이터는 여전히 메모리에 저장되어 있음 -> 누가 메모리를 읽고 쓰는가? 
- 원래 축소 명령어 집합에서는 LOAD와 STORE 라는 전용 기계 명령어로 메모리를 읽고 씀 
-> 다른 명령어는 CPU 내부의 레지스터만 처리 가능, 메모리 읽기 쓰기 불가능 -> 복잡 명령어 집합과 매우 분명한 차이 


## 4.7.3 복잡 명령어 집합과 축소 명령어 집합의 차이

1. 복잡 명령어 집합의 경우 
- 복잡 명령어 집합의 CPU에는 MULT(곱셈)라는 기계 명령어가 있음 
- CPU가 MULT 기계 명령어를 실행하면 여러가지 동작 수행 -> 메모리 읽기, 두 숫자 곱하기, 결과 다시 메모리에 작성하기 
- 고급 언어와 기계 명령어 사이의 차이를 줄이는, 프로그래머가 최소한의 코드로 작업 완료하고 프로그램의 저장 공간 절약

2. 축소 명령어 집합의 경우
- 축소 명령어 집합은 일련의 간단한 명령어 여러 개를 사용하여 작업 완료 
- 데이터 읽기, 두 숫자 곱하기, 결과 다시 메모리에 작성하기 작업에 각각 대응하는 LOAD, PROD, STORE 명령어로 작업 단계적 완료 
- LOAD -> 메모리에서 레지스터로 메모리 적재
- PROD -> 두 레지스터에 저장된 숫자의 곱셈 연산 수행
- STORE -> 레지스터의 데이터를 다시 메모리에 작성하기 

- 동일한 작업에 대해 복잡 명령어 집합을 사용하는 프로그램은 기계 명령어 하나가 필요한 반면, 
축소 명령어 집합을 사용하는 프로그램은 기계 명령어 4개가 필요함 
- 축소 명령어 집합을 사용하는 프로그램은 보다 많은 저장 공간이 필요, 어셈블리어로 코드를 작성하는 프로그래머 번거롭게 함
- 그러나 축소 명령어 집합 설계는 원래 이 작업을 컴파일러에 맡기고 컴파일러가 구체적인 기계 명령어를 자동으로 생성하게 하는 것임 

## 4.7.4 명령어 파이프라인

- 파이프라인 기술은 기계 명령어 하나가 실행되는 시간을 단축(X) -> 처리량을 늘릴 수 있음 
- 모든 명령어의 실행 시간을 대체적으로 동일하게 -> 가능한 한 파이프라인이 더 높은 효율로 기계 명령어를 처리하도록 
- 파이프라인 기술 덕분에 축소 명령어 집합으로 설계된 CPU는 성능 면에서 복잡 명령어 집합으로 설계된 상대 제압 가능 

## 4.7.5 천하에 명성을 떨치다 

- 축소 명령어 집합을 사용하는 상용 CPU가 1980년대 중반 
- 결국 다른 모든 CPU 제조업체는 축소 명령어 집합을 따르고 축소 명령어 집합의 설계 사상 적극적으로 채택 
- 복잡 명령어 집합의 암흑기 

# 4.8 CPU 진화론(소): 절체절명의 위기에서 반격

## 4.8.1 이길 수 없다면 함께하라: RISC와 동일한 CISC 

- 축소 명령어 집합의 주요 장점은 파이프라인 기술의 활용 
-> 복잡 명령어 집합은 명령어 실행 시간이 고르지 않아 파이프라인 사용 불가능 
- 복잡 명령어 집합이 축소 명령어 집합에 가깝게 변화시키기 
-> 복잡 명령어 집합의 명령어를 CPU 내부에서 축소 명령어 집합의 간단한 명령어로 변환 -> 마이크로 명령어(micro-operation) 
- 복잡 명령어 집합을 사용하지만 내부 실행 방식은 축소 명령어 방식과 유사하게 됨 
-> 복잡 명령어 집합의 호환성 유지+축소 명령어 집합의 장점 -> 일석이조 

## 4.8.2 하이퍼스레딩이라는 필살기 

- 복잡 명령어 집합의 하이퍼스래딩(hyper-threading) 개발 
- 하이퍼스레딩 = 하드웨어 스레드(hardware thread)
- 그동안은 CPU가 한 번에 한 가지 일만 할 수 있다고 간주
- 하이퍼스레딩을 사용하면 하이퍼스레딩 기능이 탑재된 하나의 물리 PCU 코어는 운영체제에 환각을 심어 
실제로 컴퓨터 시스템에 물리 CPU 코어 하나만 있지만 운영 체제는 논리적으로 CPU 코어가 여러 개 있는 것으로 인식 
- 하이퍼스레딩 기능이 있는 CPU 코어는 실제로 동시에 스레드 두 개를 실행할 수 있음 
-> 하이퍼스레딩 기술이 탑재된 CPU는 한 번에 스레드 두 개에 속하는 명령어 흐름을 처리할 수 있으며 이를 통해 CPU 코어 한 개가 CPU 코어 여러 개인 것처럼 보이게할 수 있음 
- 하이퍼스레딩 기술이 가능한 이유 -> 파이프라인 기술
- 명령어 간 종속성으로 파이프라인이 항상 완벽하게 채워진 사태에서 실행될 수 없고 '빈 공간' 발생 -> 추가 명령어를 도입하여 빈 공간을 
채우면 전체 파이프라인을 채워서 실행할 수 있어 CPU의 리소스를 최대한 활용 가능 
- 프로그래머가 인지할 수 있는 소프트웨어 스레드는 생성, 스케줄링,관리의 주체가 운영 체제
- 하드웨어 스레드에 해당하는 하이퍼스레딩은 CPU 하드웨어의 기능으로 운영 체제와는 상관없음 
- 운영체제 입장에서 하이퍼스레딩은 알 수 없는 대상 -> 운영 체제가 시스템에 더 많은 CPU 코어가 사용 가능하다고 인식 가능하게 

## 4.8.3 장점은 취하고 약점은 보완하다: CISC와 RISC의 통합 

 - 하이퍼스레딩 기술은 복잡 명령어 집합에서 제안되었지만 해당 기술은 축소 명령어 집합에도 도입 가능 + 일부 고성능 축소 명령어 집합 구조 CPU에서도 하이퍼스레딩 사용 
 - 복잡 명령어 집합과 축소 명령어 집합은 점점 닮아가고 있음 -> 그럼에도 차이점이 있음 
 - 축소 명령어 집합 -> 컴파일러가 중요, 명령어 길이가 일정하기에 명령어 길이가 가변적인 복잡 명령어 집합에 비해 컴파일러 최적화에서 더 많은 장점이 있음 
 - 메모리에 접근할 때 축소 명령어 집합은 여전히 LOAD/STORE 구조인데 반해 복잡 명령어 집합은 이런 설계 없음 
 
## 4.8.4 기술이 전부는 아니다: CISC와 RISC 간 상업적 전쟁 

- 복잡 명령어 집합이랑 축소 명령어 집합이 싸우는 얘기 

# 4.9 CPU, 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 통달하기 

## 4.9.1 레지스터

- CPU 레지스터가 필요한 이유 -> 속도 
- 프로세스가 생성되면 코드와 코드에서 사용하는 데이터는 메모리에 적재 _> 기계 명령어를 실행할 때 메모리 데이터를 CPU가 사용할 레지스터로 옮겨야 함 
- 레지스터와 메모리는 본질적으로 차이가 없고 둘 다 정보를 저장할 때 사용
- 레지스터의 읽기와 쓰기 속도가 훨씬 빠르고 제조 비용도 훨씬 비싸기에 용량의 한계 발생
- 프로세스 실행 시 정보를 모두 메모리에 저장하고 CPU가 사용할 때만 임시로 레지스터에 보관 

## 4.9.2 스택 포인터

- 실행되는 모든 함수는 스택 프레임을 가짐
- 스택의 가장 중요한 정보는 스택 상단(stack top)으로, 스택 상단 정보는 스택 하단(stack bottom)을 가리키는 스택 포인터(stack pointer)에 저장됨 
- 포인터로 함수 호출 스택 추적 가능 
- 스택 프레임(stack frame) -> 함수가 실행될 때 함수에 정의된 로컬 변수와 전달된 매개변수 등을 저장하는 독립적인 메모리 공간 
- 함수 호출 단계가 깊어질 수록 스택 프레임의 수 증가 -> 함수 호출이 완료되면 함수 호출의 반대 순서로 스택 프레임의 수 감소 
- 함수의 실행 시간 스택은 프로그램의 실행 상태 중 가장 중요한 정보 

## 4.9.3 명령어 주소 레지스터 

- 프로그래머가 고급 언어로 프로그램을 작성하면 컴파일러는 일련의 기계 명령어를 생성 -> CPU는 어떻게 명령어를 실행하는가? 
- 프로그램이 실행되면 첫 번째로 실행할 기계 명령어의 주소가 PC 레지스터에 저장되며 CPU는 PC 레지스터에 저장되어 있는 주소에 따라 메모리에서 명령어를 가져와 실행 
- 명령어는 일반적으로 순차적으로 실행 -> PC 레지스터의 값은 순차적으로 증가 
- CPU의 PC 레지스터가 CPU의 실행 흐름을 제어
- 기계 명령어가 직접 실행 상태에 따라 CPU가 다음에 어떤 상태를 실행해야 하는지 결정 

## 4.9.4 상태 레지스터

- CPU 내부에는 스택 레지스터와 명령어 주소 레지스터 외에도 상태 레지스터(status register)가 있음 
- x86구조에서는 FLAGS 레지스터라고/ARM 구조에서는 응용 프로그램 상태 레지스터(application program status register)라고 함 
- 대부분의 프로그래머가 작성한 응용 프로그램은 모두 사용자 상태에서 실행 
- 사용자 상태에서는 CPU가 특권 명령어를 실행 불가능/커널 상태에서 CPU는 특권 명령어를 포함한 어떤 명령어든 실행 가능 
- CPU가 사용자 상태에서 동작하는지, 커널 상태에서 동작하는지 어떻게? -> CPU 내부 상태 레지스터
- CPU가 현재 어떤 상태에서 동작 중인지 표시하는 특정한 비트 -> 상태 레지스터 값을 바꾸어 CPU 동작 상태 변경 가능 -> CPU가 사용자 상태와 커널 상태를 전환 

## 4.9.5 상황 정보 

- 현시점에 레지스터에 저장된 모든 정보 -> 상황정보 
- 프로그램 실행 시 상황 정보를 가져오고 저장할 수 있다면 언제든지 프로그램의 실행을 일시 중지 가능 -> 정보를 이용해 프로그램 실행 재개 또한 가능 
- 상황 정보를 저장하고 복원해야 하는 이유 -> CPU가 오름차순(ascending order)으로 기계 명령어를 실행하지 않기 때문 
- 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 _> CPU에 의한 기계 명령어의 순차적 실행 방해 불가능 -> 복구를 대비해서 중단되기 전 사태를 저장해야 함 -> 상황 정보를 저장하는 방법? 

## 4.9.6 중첩과 스택 

- 중단과 재개 
- 중첩된 구조 -> 작업의 시작과 완료를 후입선출 순서로 완료 
- 스택은 중첩 구조 처리를 위해 탄생 
- 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리는 모두 중첩 구조이기에 스택을 이용해 처리 
- 스택은 일종의 구조(mechanism)로서 그 자체를 어떻게 구현할 것인가와는 관련 X 
- 소프트웨어로 스택 구현 가능 OR 하드웨어로 스택 구현 가능 

## 4.9.7 함수 호출과 실행 시간 스택 

- 함수 호출할 때 문제 -> CPU가 호출된 함수의 첫 번째 기계 명령어로 점프한 이후 함수 실행이 완료되면 다시 원래 위치로 점프해야 함 
- 함수 상태의 보존과 복원을 포함, 보존해야 하는 상태 정보에는 반환 주소 뿐 아니라 사용한 레지스터 정보 등도 포함
- 모든 함수 실행 시 독점적인 자신만의 저장 공간을 가지고 있으며 이 저장 공간에 함수 실행 시 상태 정보 저장 가능 
-> 저장 공간의 이름은 스택 프레임(stack frame)

## 4.9.8 시스템 호출과 커널 상태 스택 

- 스레드를 생성하는 주체는 운영체제 
- 요청을 처리하기 위해 운영 체제는 내부적으로 이 요청을 처리하는 함수를 호출해야 하고 함수 호출하려면 실행 시간 스택이 필요함 
- 운영 체제가 시스템 호출을 완료하는 데 필요한 실행 시간 스택은 커널 상태 스택(kernel mode stack) 
- 모든 사용자 상태 스레드는 커널 상태에 대응하는 커널 상태 스택을 가지고 있음 
- 사용자 스레드가 운영 체제의 서비스를 요청해야 하는 경우 시스템 호출 사용 필요 
- 시스템 호출은 특정 기계 명령어에 대응 
- CPU가 해당 명령어를 실행할 때 사용자 상태에서 커널 상태로 전환 -> 커널 상태에서 사용자 상태 스레드에 대응하는 상태 스택을 찾은 후 여기에 대응하는 커널 코드를 실행하여 시스템 호출 요청을 처리 

## 4.9.9 인터럽트와 인터럽트 함수 스택 

1. 인터럽트 처리 함수에 자체적인 실행 시간 스택이 없는 경우 인터럽트 처리 함수는 커널 상태 스택을 이용해 인터럽트 처리를 실행
2. 인터럽트 처리 함수에 인터럽트 처리 함수(interrupt service routine) 스택, 즉 ISR 스택이라는 자체적인 실행 시간 스택이 있는 경우가 있음 인터럽트를 처리하는 것은 CPU라서 이때 모든 CPU가 자신만의 인터럽트 처리 함수 스택을 가짐 

## 4.9.10 스레드 전환과 커널 상태 스택 

- 시스템에 두 스레드 A와 B
- 스레드 A는 현재 실행 중, 스레드 B는 일시 중지 상태 
- 시스템 내부의 타이머가 인터럽트 신호를 발생시키면 CPU는 인터럽트 신호를 수신한 후 현재 스레드의 실행을 일시 중지하고 사용자 상태에서 커널 상태로 전환하면 커널 안의 타이머 인터럽트 처리 프로그램(timer interrupt handler)을 실행 
- 타이머 인터럽트 처리 프로그램은 스레드 A에 할당된 CPU 시간 조각이 전부 사용되었는지 판단하고 시간이 남아있으면 사용자 상태로 돌아가 실행을 계속함 
- 스레드 A의 시간 조각이 모두 사용되었다면 CPU는 스레드 B와 같은 다른 스레드에 할당되는 스레드 전환이 발생 
- 스레드 전환 작업 
1. 주소 공간 저장 -> 스레드 A와 스레드 B는 주소 공간이 서로 다른 서로 다른 프로세스에 속함
2. CPU를 스레드 A에서 스레드 B로 전환 -> 스레드 A의 CPU 상황 정보를 저장하고 스레드 B의 CPU 상황 정보를 복원 

# 4.10 요약 

- 트랜지스터부터 CPU의 기본 동작 원리를 단계별로 이해
- CPU가 변화해온 과정, 복잡 명령어 집합과 축소 명령어 집합 
- 함수 호출, 시스템 호출, 인터럽트 처리, 스레드 전환의 구현 원리 설명 
- CPU의 상황 정보를 저장하고 복원하는 작업 없이는 불가능, 정보의 저장과 복원은 스태이라는 구조로 처리 
- CPU가 메모리와 상호작용하는 방법 