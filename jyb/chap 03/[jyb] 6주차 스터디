# 3.4 힙 영역: 메모리의 동적 할당은 어떻게 구현될까? 

- 모든 함수는 각자만의 스택프레임이 있음 -> 반환주소/함수의 지역변수/매개변수/사용되는 레지스터 정보 저장 
- 스택 프레임은 스택 영역 내에 구성 -> 함수의 호출 단계가 증가하면 스택 영역의 메모리가 증가 
- 함수 호출이 완료 -> 기존 스택 프레임 정보는 더이상 사용 X -> 스택 영역의 메모리 감소 
- 주의사항

1.  프로그래머는 함수의 호출 과정이 완료되어 스택 프레임에 저장되어 있던 내용이 더 이상 사용되지 않는, 즉 무효화(invalidation)된
스택 프레임 내용에 대해 어떠한 가정도 하면 안 됨 
2. 지역 변수 수명 주기(lifecycle)은 함수호출과 동일함
- 장점
1. 프로그래머가 지역변수가 차지하는 메모리의 할당 및 반환 문제에 신경 쓸 필요 X
2. 함수 호출할 때 지역 변수가 스택 프레임에 저장됨 
- 단점 
1. 함수를 뛰어넘어 사용하는 것이 불가능 (함수가 반환된 후 지역 변수가 저장되어 있던 메모리가 더 이상 유효하지 않기 때문) 
2. 지역 변수는 프로그래머의 관리 대상이 아님 

## 3.4.1 힙 영역이 필요한 이유 

- 특정 데이터를 여러 함수에 걸쳐 사용하려면? -> 전역 변수를 사용하라고 할 수 있음
- 그러나 전역 변수는 모든 모듈에 노출되어 있는데 이것을 원하지 않을 수도 있음 
-> 프로그래머가 직접 관리하는 특정 메모리 영역에 저장해야 함 
- 메모리 수명 주기에는 프로그래머가 완전히 직접 제어할 수 있는 큰 메모리 영역 즉 힙 영역(heap segment)가 필요 
- C/C++ 언어는 malloc 함수/new 예약어를 사용해 힙 영역에 메모리를 요청하고 free 함수/delete 예약어를 사용해 해당 메모리 반환
- 힙 영역에서 메모리의 할당과 해제가 구현되는 방법은? -> malloc 과 유사한 메모리 할당자 직접 구현 필요 

## 3.4.2 malloc 메모리 할당자 직접 구현하기 

- C/C++ 언어에서는 메모리의 동적 할당과 해제 요청은
 malloc 메모리 할당자라고 하는 전문적으로 힙 영역에서 메모리를 할당하고 해제하는 프로그램으로 전달되어 처리됨 
- 실행파일을 생성할 때 링커는 C 표준 라이브러리를 자동으로 링크하고 표준 라이브러리 내에 malloc 메모리 할당자가 포함됨
- 따라서 프로그래머는 직접 메모리 할당 구현할 필요 없이 프로그램 내에서 malloc을 호출하여 메모리를 할당함 
- 힙 영역 메모리 할당자가 해결하는 핵심 두 문제
1. malloc 함수를 구현 -> 누가 메모리 영역을 요청하면 힙 영역에서 가능한 메모리 영역을 찾아 요청자에게 반환하는 과정 구현
2. free 함수를 구현 -> 메모리 영역의 사용이 완료되었을 때 힙 영역에서 메모리 영역을 반환하는 방법을 구현 

## 3.4.3 주차장에서 메모리 관리까지

- 요청하는 메모리 크기가 일정하지 않다면? 
1. 요청된 크기를 만족하는 여유 메모리를 최대한 빨리 찾기 
2. 메모리를 요청할 때는 정해진 메모리 한도 내에서 가능한 한 많은 메모리 할당 요청을 만족시키기 
- 메모리를 요청할 때 메모리에서 적절한 크기의 여유 메모리를 찾아야 하는데 어떤 것이 여유/할당인지 어떻게 알 수 있는가? 

## 3.4.4 여유 메모리 조각 관리하기

- 사용 가능한 메모리 조각을 관리하려면 사용 가능한 메모리와 할당된 메모리를 구분하는 방법이 필요함 
- 연결 리스트(linked list) 방법 -> 모든 메모리 조각을 연결 리스트로 관리/사용가능 OR 할당된 메모리 기록 편리 
- BUT 연결 리스트를 생성하려면 메모리 할당을 해야 하는데 메모리 할당을 하려면 메모리 할당자를 사용해야 함 
-> 우리는 메모리 할당자를 구현하는 것이므로 아직 존재하지 않는 메모리 할당자에 메모리를 요청? 오.. 
- 따라서 연결 리스트와 메모리 사용 정보를 할당 OR 해제된 전체 메모리 조각 그 자체에 함께 저장해야 함 
- 기록해야 하는 정보
1. 해당 메모리 조각이 비어 있는지 알려주는 설정값(flag)
2. 해당 메모리 조각의 크기를 기록한 숫자 
- 힙 영역의 모든 메모리를 남김없이 할당하는 것은 불가능 -> 일부분은 메모리 조각에 대한 필수 정보를 저장하기 위해 별도 사용 필수 

## 3.4.5 메모리 할당 상태 추적하기

## 3.4.6 어떻게 여유 메모리 조각을 선택할 것인가: 할당 전략

- 메모리를 요청할 때 메모리 할당자는 적절한 크기의 여유 메모리 조각을 찾아야 함
- 메모리 조각 중 어떤 것을 반환해야 하는가? 

1. 최초 적합 방식 
- 처음부터 탐색하다가 가장 먼저 발견된 요구 사항에 만족하는 항목을 반환  
- 단순하지만 처음부터 사용 가능한 메모리 조각을 찾으므로 메모리 할당 과정에서 앞 부분에 작은 메모리 조각이 많이 남음
- 다음 메모리를 할당할 때 더 많은 여유 메모리 조각을 탐색해야 함 

2. 다음 적합 방식 
- 메모리를 요청할 때 적합한 여유 메모리 조각이 마지막으로 발견된 위치에서 시작함 
- 이론적으로 최초 적합 방식보다 더 빠르게 여유 메모리 조각 탐색 가능 

3. 최적 적합 방식 
- 사용 가능한 메모리 조각을 모두 찾고 요구 사항을 만족하면서 크기가 가장 작은 조각을 반환 
- 메모리를 더 잘 활용하지만, 메모리를 할당할 때 사용 가능한 모든 메모리 조각을 탐색하므로 위의 두 방법만큼 빠르지 않음 

## 3.4.7 메모리 할당하기

- 여유 메모리 조각에서 메모리가 낭비되고 내부 단편화(fragmentation)이 발생 -> 해당 메모리 조각의 남은 부분 사용 불가능 
- 여유 메모리 조각을 두 개로 분할하여 앞부분은 할당 후 반환/뒷 부분은 작은 크기의 새로운 여유 메모리 조각으로 만들기 

## 3.4.8 메모리 해제하기

- 사용자가 메모리를 요청할 때 얻은 주소를 해제할 때 free와 같은 해제 함수에 주소를 전달함 
- 해제되는 메모리 조각과 인접한 메모리 조각이 여유 메모리 조각일 때 해제 여부만 기록하면? 문제가 발생 
- 인접한 메모리 조각이 비어 있을 때는 더 큰 메모리 조각으로 서로 병합 
- 메모리 조각의 할당과 해제를 반복하면? -> 불필요한 작업을 많이 수행하지만 여전히 가장 간단함 
- 실제 메모리 할당자는 대부분 여유 메모리 조각 병합을 연기하는 전략을 세움 

## 3.4.9 여유 메모리 조각을 효율적으로 병합하기

- 이전 메모리 조각에 대한 정보를 모른다면, 어떻게 해야 빠르게 이전 메모리 조각 정보를 얻을 수 있는가? 
- 메모리 조각 끝에 다시 꼬리 정보(footer)를 추가 -> 이전 조각의 꼬리 정보는 그 다음에 위치한 조각의 머리 정보와 인접
-> 현재 조각의 머리 정보에서 4byte를 빼면 이전 조각의 꼬리 정보 획득 가능 -> 메모리를 해제할 때 인접한 여유 조각 빠르게 병합 가능 

# 3.5 메모리를 할당할 때 저수준 계층에서 일어나는 일 

- 메모리를 요청하면 저수준 계층에서 어떤 일이 일어나는가? 

## 3.5.1 천지인과 CPU 실행 상태

![Image](https://github.com/user-attachments/assets/f335b645-09c6-4ed0-b484-e5639fcbad32)
- x86 CPU는 네 가지 특권 단계(privilege level)을 제공 
- 특권이란 일부 명령어를 실행할 수 있는 것
- 일부 기계 명령어는 CPU가 가장 높은 특권 상태일 때만 실행 가능 
- 일반적으로 시스템은 CPU의 특권 단계 중 0과 3 두 단계만 사용함 
1. 특권 3단계는 사용자 상태(user mode)
2. 특권 0단계는 커널 상태(kernel mode) 

## 3.5.2 커널 상태와 사용자 상태

- 커널 상태에서는 CPU가 모든 기계 명령어 실행 가능/모든 주소 공간 접근 가능/제한 없이 하드웨어 접근 가능 
- 사용자 상태는 프로그래머가 작성한 '일반적인' 코드를 CPU가 실행할 때 해당하는데 특정 주소 공간에 접근 절대 불가능 
-> 이러한 제한이 없다면 세그먼테이션 오류(segmentation fault) 발생 
- CPU는 사용자 상태일 때 특권 명령어를 실행할 수 없음 
- 일반적인 응용 프로그램은 사용자 상태 

## 3.5.3 포털: 시스템 호출

- CPU는 커널 상태에서는 응용 프로그램을 실행할 수 없지만 사용자 상태에서는 운영 체제 코드 실행 가능 
- 응용 프로그램이 파일 읽기, 쓰기, 네트워크 데이터 송수신 등 운영 체제의 서비스를 요청한다면? 
- 시스템 호출(sytsem call) -> 프로그래머가 운영 체제에 서비스를 요청할 수 있는 특정한 기계 명령어로 구현된 방법 
- 시스템 호출 명령어를 실행하면 CPU는 사용자 상태에서 커널 상태로 전환되어 운영 체제의 코드를 실행해서 사용자 요청을 수행 
- 시스템 호출이 별도의 장소에 있는 이유는? 

## 3.5.4 표준 라이브러리: 시스템의 차이를 감춘다

- 우리가 시스템 호출을 직접 사용하면 리눅스의 프로그램은 윈도우에서 직접 실행이 불가능함 
- 우리는 사용자에게서 저수준 계층 간 차이를 감추는 일종의 표준이 필요 
-> 프로그래머가 작성한 프로그램을 추가적인 수정 없이 서로 다른 운영 체제에서 실행 가능 
- C 언어에서는 표준 라이브러리(standard library)가 그 일을 수행함 
- 프로그래머는 표준 라이브러리를 호출해 파일 읽고 쓰기/네트워크 통신을 수행하며
표준 라이브러리는 실행 중인 운영 체제에 따라 대응되는 시스템 호출을 선택함 
- malloc과 같은 메모리 할당자는 운영 체제 일부분이 아니라 표준 라이브러리의 일부로 구현됨 
- C언어에서 기본적으로 사용되는 malloc은 여러 종류의 메모리 할당자 중 하나에 불과하며 다양한 유형의 메모리 할당자가 있음 
- 메모리 할당자는 각자 적합한 활용 방식이 있기에 특정 상황에 가장 적합한 메모리 할당자를 선택하는 것이 중요함 

## 3.5.5 힙 영역의 메모리가 부족할 때

- 메모리 할당자 안의 여유 메모리 조각이 부족해지면? 
![Image](https://github.com/user-attachments/assets/77e7bb01-492a-48a7-8905-29af89ae3c8b)
- 힙 영역과 스택 영역 사이에 여유 공간이 있음 
- 스택 영역이 함수 호출 단계가 깊어질수록 아래쪽으로 메모리 점유 공간이 늘어나는 것처럼 
힙 영역의 메모리가 부족하면 위쪽으로 더 많은 메모리를 점유함 -> 힙 영역이 늘어나면 여유 메모리 부족 문제가 해결됨
- 힙 영역을 늘릴 수 있는 방법은?
- malloc은 메모리가 부족해지면 운영 체제에 메모리를 요청해야 함 -> 운영 체제가 왕초임
- 리눅스의 모든 프로세스에는 힙 영역의 최상단을 가리키는, break를 의미하는 brk 변수가 있음 
- brk 변수 값을 위로 이동해서 힙 영역을 확장시키려면 시스템 호출이 필요함 

## 3.5.6 운영 체제에 메모리 요청하기: brk

- brk 시스템 호출을 통해 힙 영역의 크기를 조절할 수 있음 
- 이러한 시스템 호출이 있으므로 힙 영역이 부족하면 
즉시 운영 체제에 힙 영역을 늘릴 것을 요청할 수 있으며 더 많은 메모리 확보가 가능함 
- 메모리 할당이 더 이상 사용자 상태의 힙 영역에만 국한되지 않기에 메모리 할당 단계가 달라짐 

1. 프로그램은 표준 라이브러리에 구현되어 있는 malloc을 호출하여 메모리 할당을 요청함
2. malloc은 여유 메모리 조각을 검색하고 적절한 크기의 조각을 찾으면 할당함 (사용자 상태에서 처리)
3. malloc이 여유 메모리 조각을 찾지 못하면 brk 시스템 호출을 통해 운영 체제에 힙 영역을 늘리는 것을 요청함 (커널 상태에서 처리)
-> 힙 영역이 늘어나면 malloc이 다시 한 번 적절한 여유 메모리 조각을 찾아서 할당해줌 

## 3.5.7 빙산의 아래: 가상 메모리가 최종 보스다

- 프로세스 입장에서 메모리는 모두 가상 
- malloc의 호출이 반환되면 프로그래머가 받아오는 메모리는 가상 메모리 -> 실제 물리 메모리가 전혀 할당되지 않은 상태일 수도
- 실제 물리 메모리는 언제 할당되는가? -> 실제로 할당한 메모리가 사용되는 순간에 물리 메모리가 할당됨 
- 가상 메모리가 실제 물리 메모리와 연결되어 있지 않으면 내부적으로 페이지 누락 오류(page fault) 발생 가능 
- 운영 체제가 해당 오류를 감지하면 페이지 테이블 수정 -> 가상 메모리와 실제 물리 메모리의 사상 관계 설정 -> 실제 물리 메모리 할당 
- 프로그램이 할당된 가상 메모리를 사용할 때도 실제 물리 메모리와 사상 관계에 있어야 하며 
해당 시점이 되어야만 커널 상태에서 실제 물리 메모리가 할당됨 
- 운영 체제만 실제 물리 메모리 할당 가능 

## 3.5.8 메모리 할당의 전체 이야기

1. malloc이 여유 메모리 조각 검색 -> 적절한 크기의 조각 찾으면 할당
2. 적절한 크기의 조각을 찾지 못하면 brk 시스템 호출을 통해 힙 영역을 확장해 더 많은 여유 메모리를 얻음 
3. malloc이 brk를 호출하면 커널 상태로 전환 -> 운영 체제의 가상 메모리 시스템이 힙 영역을 확장하기 시작함
-> 이렇게 확장된 메모리 영역은 가상 메모리에 불과 -> 운영 체제는 아직 실제 물리 메모리를 할당하지 않았을 수도 
4. brk 실행이 종료되면 malloc으로 제어권 반환, CPI도 커널 상태에서 사용자 상태로 전환 -> malloc이 적절한 여유 메모리 조각을 반환
5. 프로그램 성공적으로 요청 -> 다음 단계 실행
6. 코드가 새로 요청된 메모리 읽거나 쓰면 시스템 내에서 페이지 누락 인터럽트 (page fault interrupt) 발생 -> CPU는 당시 사용자 상태에서 커널 상태로 전환 -> 운영 체제가 실제 물리 메모리 할당 시작 -> 페이지 테이블 내 가상 메모리와 실제 물리 메모리 사상 관계 설정
-> CPU는 다시 커널 상태에서 사용자 상태로 전환 -> 다음 처리로 넘어감 

- malloc을 통해 빈번하게 메모리 할당/해제 하는 작업은 시스템 성능에 일정 수준의 영향을 미침 
- malloc을 사용하지 않을 방법은? -> 메모리 풀(memory pool) 

# 3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?

- malloc은 범용 제품 -> 특정 상황에 최적화되어 있지 않음 
- 매우 복잡하고 운영 체제와 연관이 있고 메모리 할당과 해제 요청이 시스템 성능에 영향을 끼치는 범용적인 malloc을 사용하는 대신 
특정 상황을 위해 자체적으로 메모리 할당 전략 구현 가능 -> 메모리 풀 기술 

 ## 3.6.1 메모리 풀 대 범용 메모리 할당자

1. malloc은 표준 라이브러리의 일부/memory pool은 응용 프로그램의 일부 
2. memory pool 기술은 특정 상황에만 메모리 할당 성능을 최적화 -> 범용성 최악 
- memroy pool 기술이 성능을 최적화하는 방법은? 

## 3.6.2 메모리 풀 기술의 원리

- 한 번에 큰 메모리 조각을 요청하고 그 위에 자체적으로 메모리 할당 및 해제를 관리 -> 표준 라이브러리와 운영 체제 우회 
- 특정 사용 패턴에 따른 추가 최적화 
- 특정  상황에 최적화되어 구현된 memory pool은 범용 메모리 할당자에 비해 개큰이점 
-> 프로그래머가 해당 상황에 사용되는 메모리의 사용 패턴을 이해하지만 범용 메모리 할당자는 전혀 고려하지 않으므로 

## 3.6.3 초간단 메모리 풀 구현하기

- 간략화를 위해 사용자 요청 처리 시 단 한종류의 객체를 사용한다고 가정
- 한번에 커다란 메모리를 할당하고, 이를 작은 조각으로 나누어 사용
- 특정 객체만 사용한다는 가정 하에 유용함 

## 3.6.4 약간 더 복잡한 메모리 풀 구현하기

- 다양한 크기의 객체를 사용한다면, 필연적으로 메모리를 관리해야 함 
- 이를 위해 메모리 조각들을 연결리스트로 연결하고, 포인터를 사용해 서로의 위치를 기록
- 메모리가 부족해지면 malloc을 통해 추가적인 메모리를 요청해야 하는데, 이때 항상 기존 메모리의 두 배를 요청 
-> 이는 C++의 vector 컨테이너 확장 전략과 유사 -> 이러한 방식으로 지나치게 빈번한 메모리 할당을 방지 가능 
- 또한 사용 가능한 메모리의 시작 위치를 나타내는 Free_ptr 포인터가 있어, 시작 지점을 빠르게 찾을 수 있음 
- 메모리 해제는 요청이 종료되는 시점에만 한 번 발생 -> 이를 통해 메모리 해제를 최소화 가능 

## 3.6.5 메모리 풀의 스레드 안전 문제 

- 스레드 세이프를 위해 메모리 풀에 직접 락을 걸 수 있나? -> 그러나 이는 성능에 큰 영향을 미칠 수 있음
- 따라서 각 스레드별로 별도의 메모리 풀을 사용하는 것이 좋음 -> 이를 통해 락을 걸지 않고도 스레드 세이프를 보장 가능 

# 3.7 대표적인 메모리 관련 버그

## 3.7.1 지역 변수의 포인터 반환하기

## 3.7.2 포인터 연산의 잘못된 이해

## 3.7.3 문제 있는 포인터 역참조하기

## 3.7.4 초기화되지 않은 메모리 읽기

## 3.7.5 이미 해제된 메모리 참조하기

## 3.7.6 배열 첨자는 0부터 시작한다

## 3.7.7 스택 넘침

- 함수 스택 프레임이 파괴되었을 때 이상적인 결과는 프로그램이 즉시 충돌하여 강제 종료되는 것 
- 프로그램이 장시간 실행되다가 갑자기 오류가 발생하거나 실행 시간 예외(runtime exception)가 발생하지 않으면서 잘못된 결과를 지속적으로 제공할 수도 있음 
- 스택 프레임에도 중요한 정보가 있어서 스택 버퍼 넘침(stack buffer overflow)는 문제를 일으킬 수 있음 
 
## 3.7.8 메모리 누수

- 메모리를 요청한 후 바로 반환할 때 프로세스가 종료되기 전까지 메모리를 다시 해제하지 못할 경우 메모리 누수(memory leak) 발생
- 메모리 누수는 자동 쓰레기 수집(automatic garbage collection)을 지원하지 않는 언어에서 흔함
- 프로그램이 메모리를 계속 요청하기만 하고 해제를 하지 않으면 프로세스의 힙 영역이 늘어나 결국 운영 체제가 강제로 프로세스 종료
-> 리눅스에서는 이를 메모리 부족 강제 종료(out of memory killer)라고 함
- 메모리 누수 문제 분석 도구 구현 방식 

1. malloc과 free의 사용 상황 추적 -> 프로그램 실행 속도 저하/코드 재컴파일 필요 등의 단점 존재 
2. 리눅스에서는 perf 와 같은 도구를 사용 

# 3.8 왜 SSD는 메모리를 사용할 수 없을까? 

- SSD의 읽기 속도가 빠르다면 SSD를 메모리로 사용할 수 있는가? 
- SSD를 실제 메모리로 사용한다면 컴퓨터 속도가 느려짐 -> 데이터 읽기/쓰기 관점에서는? 

## 3.8.1 메모리 읽기/쓰기와 디스크 읽기/쓰기의 차이

- 메모리 주소 지정 단위는 byte -> 각 byte마다 메모리 주소가 부여되어 있으며 CPU가 이 주소를 사용하여 해당 내용에 직접 접근
- 그러나 SSD는 매우 다양한 크기의 조각 단위로 데이터를 관리 -> CPU가 파일의 특정 byte에 직접 접근 불가능
-> byte 단위 주소 지정이 지원되지 않음 
- 메모리는 byte 단위, 디스크는 조각 단위로 주소가 지정됨 
- CPU는 SSD에 저장된 데이터에 직접 접근할 수 없기 때문에 CPU는 SSD 또는 디스크에서 직접 프로그램을 실행할 수 없음 

## 3.8.2 가상 메모리의 제한

- 최신 운영 체제의 메모리 관리는 기본적으로 가상 메모리 기반 -> SSD는 메모리로 사용할 수 없음 

## 3.8.3 SSD 사용 수명 문제 

- SSD 제조 원리에 따라 SSD 와 같은 저장 장치에는 사용 수명 제한이 있음 
- CPU에서 프로그램을 실행할 때 대량의 메모리 읽기/쓰기 작업을 실행하므로 
SSD를 메모리로 사용하면 사용 수명 때문에 시스템에 병목 현상이 발생할 수 있음 -> 메모리는 이런 문제가 없음 

# 3.9 요약 

- 메모리는 CPU가 기계 명령어를 실행할 때 필요한 모든 정보를 저장하는 역할을 함 
- 사실 단순한 형태임 -> 0 아니면 1을 저장한 개별 사물함일 뿐
- 그러나 메모리에는 함수 실행 시 정보를 저장하고 함수의 호출, 반환이 되는 스택 영역과 
할당 요청된 메모리의 수명 주기를 프로그래머가 직접 관리해야 하는 힙 영역이 있음
- 물리 메모리 위에 가상 메모리를 추상화하여 최신 운영 체제가 각 프로세스에 메모리를 독접적으로 부여하는 것처럼 만들면 
프로그래머는 연속된 주소 공간에서 프로그래밍이 가능하며 매우 편리함  
