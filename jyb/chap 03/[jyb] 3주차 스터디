# 2.5 콜백 함수를 철저하게 이해한다

## 2.5.1 모든 것은 다음 요구에서 시작된다
- 핵심 모듈 함수만 사용하면 조건이 추가될 때마다 코드를 수정해야 하는 문제 발생
- 해결책: 핵심 모듈 함수를 수정하는 대신 **콜백 함수**를 사용하여 처리

## 2.5.2 콜백이 필요한 이유
- 특정 기능을 수행하는 함수를 직접 수정하지 않고 원하는 기능을 추가할 수 있도록 설계
- 사용자가 정의한 함수를 매개변수로 전달하여 실행하는 방식
- 이벤트 발생 시 처리할 함수를 미리 등록하여 실행 가능 (이벤트 중심 프로그래밍)

## 2.5.3 비동기 콜백
- 함수 실행이 길어지면 반환이 지연될 수 있음
- 우선순위가 높은 작업을 먼저 처리하기 위해 스레드를 활용하여 비동기 실행
- **비동기 콜백**: 호출 스레드가 콜백 함수 실행에 의존하지 않음

## 2.5.4 비동기 콜백은 새로운 프로그래밍 사고방식으로 이어진다
### 동기 호출
1. 함수를 호출하고 결과를 획득
2. 획득한 결과를 처리 (함수 반환을 기다려야 함)
```
res = request();
handle(res);
```

### 비동기 호출
- 함수 실행 후 바로 반환, 결과 처리는 별도 실행
```
request(handle);
```
- 함수 호출 스레드와 결과 처리 스레드가 다를 수 있음
- 호출자는 어떤 작업을 수행해야 하는지 알고 있으므로, 해당 작업을 콜백 함수로 전달

## 2.5.5 콜백 함수의 정의
- 다른 코드에 매개변수로 전달되는 실행 가능한 코드
- 직접 호출하는 것이 아니라 외부 모듈이 호출
- 서드파티 라이브러리는 사용자가 원하는 작업을 알 수 없으므로, 콜백 함수로 정의하여 전달해야 함
- 네트워크 응답 도착, 파일 다운로드 완료 등의 이벤트 중심 프로그래밍에 적합

## 2.5.6 두 가지 콜백 유형
### 동기 콜백 (블로킹 콜백)
- 함수가 반환되기 전에 콜백 함수 실행
- 실행 흐름이 직관적이지만, 동기 실행으로 인해 프로그램 성능 저하 가능

### 비동기 콜백 (지연 콜백)
- 함수가 즉시 반환되고 일정 시간이 지나 콜백 함수 실행
- 콜백 함수와 주 프로그램이 동시에 실행 가능 (다른 스레드 또는 프로세스 활용)
- 다중 코어 리소스를 효과적으로 활용하며, 입출력 작업 및 웹 서비스에 적합

## 2.5.7 비동기 콜백의 문제: 콜백 지옥
- 복잡한 비즈니스 로직을 비동기 콜백으로 처리하면 코드가 난해해짐 (콜백 중첩 증가)
- 코드 단순성 및 가독성을 높이기 위해 **코루틴**을 활용하여 해결 가능


# 2.6 동기와 비동기를 철저하게 이해한다

## 2.6.1 고된 프로그래머

### 동기 작업
- 작업을 주고 완료할 때까지 대기
- 예시: 전화, 무전기

### 비동기 작업
- 작업이 끝나기 전까지 다른 작업을 수행 가능
- 여러 작업을 동시에 진행하여 효율성 증가
- 예시: 이메일

---

## 2.6.2 전화 통화와 이메일 보내기
- **전화 통화(동기)**: 한 사람이 말하면 다른 사람은 듣기만 해야 함 → 기다림 필요
- **이메일(비동기)**: 보내고 다른 일을 하다가 답장을 받으면 확인 → 기다릴 필요 없음

---

## 2.6.3 동기 호출
### 특징
- 동일한 스레드에서 실행됨
- 호출된 함수의 처리가 끝나야 다음 작업이 실행됨

### 블로킹 입출력
- 입출력 작업에서 호출 스레드를 일시 중지
- 커널이 데이터를 읽어오면 스레드가 다시 실행됨
- 효율이 낮을 수 있음

---

## 2.6.4 비동기 호출
### 특징
- 시간이 오래 걸리는 작업(예: 파일 읽기, 네트워크 요청, DB 처리)을 백그라운드에서 실행
- 호출자가 기다리지 않고 즉시 다음 작업을 수행 가능
- 효율적이지만 코드가 복잡해질 수 있음

### 작업 완료 시점 파악 방법
1. **호출자가 실행 결과를 신경 쓰지 않는 경우** → 콜백 함수 사용
    ```cpp
    void handler(void* buf) {
        // 파일 내용 처리
    }
    read(buf, handler); // read 함수가 완료되면 handler 실행
    ```
2. **호출자가 실행 결과를 알아야 하는 경우** → 알림 방식 사용
    - 작업 완료 후 호출자에게 신호/메시지를 보냄

---

## 2.6.5 웹 서버에서 동기와 비동기 작업
### 동기 방식
- 작업이 끝날 때까지 스레드가 대기
- 유휴 시간이 발생하여 비효율적

### 비동기 방식
1. **DB 처리 결과를 신경 쓰지 않는 경우**
    - 주 스레드는 A, B, C를 처리 → DB 요청 후 콜백 함수를 등록 → D, E, F를 수행
    - 주 스레드의 유휴 시간이 없어 효율적
    - 코드가 복잡해질 수 있음

2. **DB 처리 결과를 알아야 하는 경우**
    - DB 스레드가 알림 방식으로 결과를 주 스레드에 전달
    - 주 스레드는 DB 응답을 기다리지 않고 다른 요청을 처리 가능
    - 동기 방식보다 효율적이지만 모든 상황에서 최적은 아님

---

### 결론
- 동기 방식은 이해하기 쉽지만 효율이 낮음
- 비동기 방식은 효율적이지만 코드가 복잡해질 수 있음
- 상황에 맞게 적절한 방식 선택 필요

# 2.7 블로킹과 논블로킹

## 2.7.1 블로킹과 논블로킹
- 함수 A가 함수 B를 호출할 때, 함수 B를 호출함과 동시에 운영체제가 함수 A가 실행 중인 스레드나 프로세스를 일시 중지시키면 **블로킹 호출**
- 그렇지 않다면 **논블로킹 호출**
- 블로킹 호출의 핵심은 스레드 또는 프로세스가 일시 중지되는 것

## 2.7.2 블로킹의 핵심 문제: 입출력
- 대부분 블로킹은 입출력과 관련이 있음 (입출력을 처리하는 데 시간이 오래 걸림)
- 입출력 작업 중 CPU 제어권을 다른 스레드에 넘겨 다른 작업을 수행 가능
- 입출력 완료 후 다시 CPU 제어권을 가져와 작업을 지속
- CPU 제어권을 상실했다가 되찾는 동안 스레드나 프로세스는 블로킹됨
- 블로킹 입출력 방식은 CPU 리소스를 최대한 활용하는 데 도움

## 2.7.3 논블로킹과 비동기 입출력
- 호출 스레드가 일시 중지되지 않으면서 입출력 작업을 시작하는 것을 **논블로킹**
- 이런 유형의 입출력 작업을 **비동기 입출력**이라고 함
- 네트워크 데이터 수신 예제:
  - 데이터를 수신하는 `recv` 함수가 논블로킹이면 즉시 반환됨
  - 호출 스레드는 자신의 작업을 계속 진행
  - 데이터 수신 작업은 커널이 처리하여 비동기적으로 실행

**데이터 수신 확인 방법**
1. 요청 전달 시 결과를 확인하는 폴링 함수를 제공하고, 이를 호출하여 수신된 데이터가 있는지 확인
2. 데이터가 수신되면 스레드에 메시지나 신호 등을 전송하는 알림 방식
3. `recv` 함수를 호출할 때, 데이터 수신 처리를 담당하는 콜백 함수를 매개변수로 전달

## 2.7.4 피자 주문에 비유
- **블로킹 호출**: 피자 가게에 직접 가서 피자가 완성될 때까지 기다림
- **논블로킹 호출**: 전화로 피자를 주문하고 다른 일을 하다가 배달이 도착하면 응답 (알림 방식)
- **논블로킹 ≠ 비동기**

## 2.7.5 동기와 블로킹
- 동기 호출은 반드시 블로킹이 아닐 수 있지만, 블로킹 호출은 항상 동기 호출임

## 2.7.6 비동기와 논블로킹
- 네트워크 데이터 수신 예제:
  - `recv`: 데이터 수신 함수
  - `handler`: 네트워크 데이터 처리 함수
  - `NON_BLOCKING_FLAG`: `recv` 함수를 논블로킹 호출로 설정하는 플래그
- **비동기이자 논블로킹**: `handler` 함수를 `recv` 함수에 콜백으로 전달
- **동기이자 논블로킹**: `check` 함수를 사용하여 데이터 도착을 감지 (비효율적)

# 2.8 높은 동시성과 고성능을 갖춘 서버 구현

## 2.8.1 다중 프로세스

다중 프로세스는 가장 간단한 형태의 병행 처리 방식으로, 부모 프로세스가 사용자 요청을 수신한 후, 자식 프로세스를 생성하여 해당 사용자 요청을 처리한다. 즉, 모든 요청에는 각각 대응하는 프로세스가 존재한다.

### 다중 프로세스의 장점
1. 프로그래밍이 간단하다.
2. 개별 프로세스의 주소 공간이 서로 격리되어 있어 하나의 프로세스에 문제가 발생해도 다른 프로세스에 영향을 주지 않는다.
3. 다중 코어 리소스를 최대한 활용할 수 있다.

### 다중 프로세스의 단점
1. 개별 프로세스의 주소 공간이 서로 격리되어 있어 프로세스 간 통신 방식이 복잡하다.
2. 프로세스를 생성하는 데 부담이 크며, 프로세스의 빈번한 생성과 종료로 인해 시스템의 부담이 증가할 수 있다.

## 2.8.2 다중 스레드

스레드는 하나의 프로세스 내에서 실행되며, 같은 프로세스 주소 공간을 공유하기 때문에 별도의 프로세스 간 통신 기법 없이 데이터 교환이 가능하다. 또한, 프로세스와 달리 스레드는 생성과 종료에 드는 부담이 적다. 각 요청에 대응하는 스레드를 생성하여 사용자 요청을 처리하는 방식이다.

### 다중 스레드의 장점
1. 스레드는 같은 주소 공간을 공유하므로 데이터 교환이 쉽다.
2. 프로세스보다 생성 및 종료 비용이 낮아 빠르게 처리할 수 있다.

### 다중 스레드의 단점
1. 스레드가 같은 주소 공간을 공유하기 때문에 하나의 스레드에 문제가 발생하면 같은 프로세스를 공유하는 모든 스레드와 프로세스에 영향을 미칠 수 있다.
2. 여러 스레드가 공유 데이터를 동시에 읽고 쓰면 데이터 정합성 문제가 발생할 수 있어 동기화 기법(예: 상호 배제, 뮤텍스, 세마포어 등)이 필요하다.
3. 높은 동시성을 가지는 경우, 과도한 메모리 소비나 성능 저하가 발생할 수 있다.

## 2.8.3 이벤트 순환과 이벤트 구동

병행 프로그래밍을 위해 이벤트 기반의 동시성을 이용하는 이벤트 기반 프로그래밍 기법을 사용할 수 있다.

### 이벤트 기반 프로그래밍의 주요 요소
1. **이벤트**: 네트워크 데이터 수신 여부, 파일의 읽기 및 쓰기 가능 여부 등의 관심 대상
2. **이벤트 처리 함수 (이벤트 핸들러)**: 이벤트가 발생하면 해당 이벤트 유형을 확인하고, 대응하는 이벤트 핸들러를 호출한다.

이벤트는 지속적으로 발생하므로 `while` 또는 `for` 반복문을 사용해 반복적으로 처리하는데, 이를 **이벤트 순환(Event Loop)**이라고 한다.

## 2.8.4 이벤트 소스와 입출력 다중화

입출력 다중화를 통해 운영 체제가 여러 개의 입출력 이벤트를 효율적으로 처리할 수 있도록 한다. 리눅스에서는 `epoll`을 사용하여 입출력 다중화를 구현할 수 있다.

```c
int epoll_fd = epoll_create(); // epoll 생성
Epoll_ctl(epoll_fd, fd1, fd2, fd3, fd4...); // 서술자를 epoll이 처리하도록 지정
while (1) {
    int n = epoll_wait(epoll_fd);
    for (int i = 0; i < n; i++) {
        // 특정 이벤트 처리
    }
}
```

`epoll_wait()`를 이용해 이벤트가 발생한 fd 리스트를 반환하여 이벤트 순환의 엔진이 되고, 지속적으로 다양한 이벤트를 제공한다.

## 2.8.5 이벤트 순환과 다중 스레드

이벤트 핸들러가 입출력 작업이 없고 짧은 시간 내 실행되는 경우, 이벤트 순환과 동일한 스레드에서 실행할 수 있다. 하지만 CPU 연산을 많이 사용하는 경우, 단일 스레드에서는 처리 속도가 느려질 수 있다.

이때 다중 코어를 활용하여 속도를 높이기 위해 **다중 스레드를 사용**할 수 있다. 이벤트 핸들러를 독립적인 스레드에 배치해 작업자 스레드를 만들고, 이벤트를 작업자 스레드에 분배하는 이벤트 순환 스레드를 생성하는 방식이 있다. 이러한 설계를 **반응자 패턴(Reactor Pattern)**이라고 한다.

## 2.8.6 반응자 패턴의 예시: 카페 운영 방식

카페 운영 방식을 반응자 패턴에 비유할 수 있다.
- 카운터에서 한 명의 종업원이 주문을 받고, 여러 명의 요리사가 요리를 만들어 제공하는 방식
- 고객 → 이벤트 순환, 요리사 → 작업자 스레드

## 2.8.7 이벤트 순환과 입출력

이제 요청 처리 과정에서 입출력 작업이 포함된다고 가정하면, 입출력 방식에 따라 다르게 처리해야 한다.

1. **논블로킹 입출력 (Non-blocking I/O)**: 이벤트 순환 내에서 직접 호출 가능
2. **블로킹 입출력 (Blocking I/O)**: 이벤트 순환이 중지되지 않도록 작업자 스레드에서 실행해야 함

## 2.8.8 비동기와 콜백 함수

서버 기능이 복잡해지면서 여러 서버가 분산 배치되고, 원격 프로시저 호출(RPC, Remote Procedure Call)을 통해 서버 간 통신이 이루어진다. RPC 호출은 기본적으로 **블로킹 방식**이기 때문에 CPU 리소스를 충분히 활용하지 못하는 문제가 있다.

이를 해결하기 위해 RPC 호출을 **비동기 방식**으로 수정할 수 있다.

```c
GetUserInfo(request, callback);
```

비동기 호출에서는 함수가 즉시 반환되지만, 응답 결과가 나중에 도착할 수 있기 때문에 콜백 함수를 등록해야 한다.

## 2.8.9 코루틴: 동기 방식의 비동기 프로그래밍

코루틴(Coroutine)은 일시 중지(`yield`)와 재개가 가능한 함수로, 동기적으로 보이지만 비동기적으로 실행할 수 있다.

코루틴을 사용하면 RPC와 같은 시간이 오래 걸리는 작업을 만났을 때, `yield`를 사용하여 작업자 스레드가 다른 코루틴을 실행할 수 있도록 한다. 이는 **비동기 실행의 효과를 가지면서도 동기 방식의 가독성을 유지하는 장점**이 있다.

## 2.8.10 CPU, 스레드, 코루틴 비교

- **CPU**: 기계 명령어를 실행하는 하드웨어
- **스레드**: 커널 상태 스레드(Kernel-level Thread), 커널이 생성하고 관리하며, CPU 연산 리소스를 할당받음
- **코루틴**: 사용자 상태 스레드(User-level Thread), 커널이 직접 관리하지 않으며, 프로그래머가 실행 스케줄을 제어할 수 있음

코루틴을 이용하면 블로킹 방식의 RPC 호출을 수행하더라도, 작업자 스레드는 블로킹되지 않고 효율적으로 동작할 수 있다. 이를 통해 높은 동시성과 고성능 서버를 구현할 수 있다.

# 2.9 컴퓨터 시스템 여행: 데이터, 코드, 콜백, 클로저에서 컨테이너, 가상 머신까지

## 2.9.1 코드, 데이터, 변수, 포인터
- **함수**: 명령어 여러 개를 하나의 별칭으로 묶은 것  
- **변수**: 데이터를 별칭으로 지칭하는 것  
- **참조(포인터)**: 변수를 사용하여 동일한 데이터를 가리키는 것 (C언어에서는 포인터로 구현)  

## 2.9.2 콜백 함수와 클로저
- **일급 객체 함수 (first-class function)**: 함수를 일반 변수처럼 다룰 수 있는 개념  
  - 함수를 변수에 할당, 매개변수로 전달, 반환값으로 사용 가능  
  - C언어에서는 불가능하지만, Python에서는 가능  
- **콜백 함수**: 다른 함수의 매개변수로 전달되는 함수  
  - 정의와 호출이 다른 곳에서 이루어짐  
  - 실행 환경이나 데이터를 콜백 함수가 사용할 수 있도록 보장해야 하는 문제 발생 가능  
- **클로저 (closure)**: 콜백 함수가 실행 시간 환경의 데이터를 함께 묶어 변수처럼 취급할 수 있도록 하는 개념  

## 2.9.3 컨테이너와 가상 머신 기술
- **코루틴**: CPU를 능동적으로 일시 중지하고, 다시 호출될 때 중단된 지점부터 실행하는 함수  
- **스레드**: 함수의 일시 중지와 재개가 운영 체제의 커널에서 구현되는 경우  
- **프로세스**: 스레드와 종속된 실행 시 리소스를 결합한 것  
- **컨테이너 (Container)**  
  - 프로그램이 실행에 필요한 환경과 함께 묶인 것  
  - 운영 체제에서 제공하는 기능을 활용해 프로세스를 격리하고, CPU/메모리/디스크 접근을 제어  
  - 컨테이너 내부 프로세스는 자기 자신만이 존재하는 것처럼 인식  
- **가상화 기술**  
  - 가상 머신 감시자(VMM, Virtual Machine Monitor)를 이용해 하드웨어 리소스를 추상화  
  - 여러 개의 가상 컴퓨터를 만들어 그 위에서 운영 체제를 실행하도록 함  
  - 이 기술을 **하이퍼바이저 (Hypervisor)** 라고 부름  
- **가상 머신 (Virtual Machine, VM)**  
  - 가상 머신 감시자에서 실행되는 운영 체제  
  - 실제 하드웨어 리소스를 독점적으로 사용하는 것처럼 동작  
  - 1세대 클라우드 컴퓨팅의 기반 기술  

컨테이너와 가상 머신 기술은 최신 클라우드 컴퓨팅의 핵심 기반이 됨.