# 프로그래밍 언어와 컴파일러의 작동 원리

- 프로그래밍 언어는 프로그래머가 컴퓨터에 명령을 내리는 도구 
- 프로그래밍 된 코드를 어떻게 인식할 수 있는가? 

## 1.1 여러분이 프로그래밍 언어를 발명한다면?

- 스위치로 불 논리(boolean logic)를 표현할 수 있다  
- 컴퓨터는 기본적으로 **이진수(0과 1)** 만 이해할 수 있다 
- CPU는 간단한 계폐 즉, **전원이 켜짐과 꺼짐**만 인식할 수 있는 원시적인 장치이다. 
- CPU는 매우 간단하지만 **속도가 매우 빠르다**는 장점이 있다 

### 저수준 언어(Low-Level Language)
- 초기에는 천공카드(punched card)를 사용하여 0과 1로 구성된 명령을 했다
- 이후 인간이 인식할 수 있는 기계 명령어를 CPU가 인식할 수 있는 0과 1로 구성된 바이너리로 변환하는 **어셈블리어(Assembly Language)**가 등장했다 

### 고급 프로그래밍 언어(High-Level Programming Language)
- 어셈블리어는 여전히 저수준 언어이다 
- 인간의 추상적인 표현을 CPU가 이해할 수 있는 구체적인 구현으로 **자동으로 변환**할 수 있는 방법을 찾아야 한다 
- 단도직입적인 명령어를 문(statement)으로 작성하고, 매개변수(parameter)와 함수, 그리고 여러가지 규칙들을 찾는다 
- 단계별로 중첩되는 복잡한 규칙들은 **재귀**의 개념으로 해결한다 
- 즉 고급 언어는 **명령의 규칙과 패턴**을 기반으로 프로그래밍을 가능하게 한다 

1. 개별 명령을 **Statement(문)** 으로 작성
2. 중첩된 Statement를 **Syntax(구문)** 으로 구성
3. Syntax를 **구문 트리(Syntax Tree)** 로 변환하여 컴퓨터가 이해할 수 있도록 준비
4. 컴파일러(Compiler)는 **리프 노드부터 재귀적으로** 기계 명령어로 번역

### 해석형 언어(Interpreted Language)
- 고급 언어를 CPU가 인식할 수 있는 기계 명령어로 번역하는 컴파일러 
- 각 CPU마다 사용하는 기계어가 다르기 때문에, CPU 형식에 관계없이 실행할 수 있도록 **표준 명령어 집합**을 사용한다 

- 이를 실행하기 위해 **CPU의 명령어 실행 과정을 모방하는 프로그램**이 필요하다
- 이를 **가상머신(Virtual Machine) 혹은 인터프리터(Interpreter)** 라고 부른다 

---

## 1.2 컴파일러는 어떻게 작동하는 것일까?

- 컴파일러(Compiler)는 **고수준 언어를 저수준 언어로 변환하는 프로그램**
- 소스 파일(source file)은 프로그래밍 언어의 구문 규칙에 따라 프로그래머가 작성한 코드 텍스트 파일 
- 소스 파일에는 CPU가 직접 실행할 수 있는 기계 명령어가 저장되고 컴파일러는 소스 코드를 기계 명령어로 번역한다 
- 즉, 컴파일러는 소스코드를 입력받아 실행 파일을 반환하는 **텍스트 처리 프로그램**이다 

### 1️⃣ 어휘 분석(Lexical Analysis)

- 어휘 분석은 소스코드에서 **토큰(Token)** 을 추출하는 과정이다 
- 토큰(Token)은 각 항목에 추가로 정보를 결합한 것을 의미한다 

- 예제 코드
```c
int a = 1;
int b = 2;

while (a < b) {
    b = b - 1;
}
```

- 이 코드에서 추출된 토큰 예시
```
T_Keyword      int
T_Identifier   a
T_Assign       =
...
```

### 2️⃣ 구문 분석(Parsing)

- **구문분석(Parsing)** 은 구문 문법(Syntax)에 따라 토큰을 해석하며, **문법 오류(Syntax Error)를 검사**하고 구문 트리를 생성하는 과정이다 
- 예를 들어, `while` 키워드를 발견하면 **다음 토큰이 반드시 `(` 여야 한다** 는 규칙을 적용해 검사를 진행한다 
-  **구문 트리(Syntax Tree)** 는 컴파일러가 구문에 따라 해석해 낸 구조를 표현한 것이다 
- 구문 분석을 통해 구문 트리를 생성한다 

---

### 3️⃣ 의미 분석(Semantic Analysis)

- 구문 트리가 올바른지 확인하며, **컴파일 오류를 검사** 한다 

- 예제

1. 정수와 문자열을 더할 수 없음 (`int + string` 오류)
2. 비교 연산(`a < b`)에서 좌우 피연산자의 타입이 다르면 오류 발생

---

### 4️⃣ 중간 코드 생성(Intermediate Representation, IR Code)

- 구문 트리를 탐색하여 **중간 코드(IR Code)** 를 생성한 후, 이를 단계적으로 변환한다 
- 중간 코드 변환 단계 
1. **어셈블리어(Assembly Language)** 로 변환
2. **기계 명령어(Machine Code)** 로 변환
- 이 과정은 매우 복잡하며 최적화도 함께 수행된다 

---

### 5️⃣ 대상 파일(Object File)과 링크(Linking)

- 소스코드가 **소스 파일(Source File)** 에 저장되듯, 기계 명령어는 **대상 파일(Object File)** 에 저장된다 
- 여러 개의 대상 파일을 묶어 하나의 실행 가능한 프로그램으로 만드는 과정을 **링크(Linking)** 라고 한다 
- 링크(Linking)을 담당하는 프로그램은 **링커(Linker)** 라고 한다 


## 1.3 링커(Linker)는 무엇을 하는가?

링커는 컴파일된 대상 파일들을 모아 하나의 실행파일로 만드는 작업을 수행한다.

### 🔧 링커의 주요 역할

#### 1️⃣ 심벌 해석 (Symbol Resolution)
- 외부 심벌의 정의를 찾아 연결
- 모든 외부 참조는 단 하나의 정의만 존재해야 함

#### 2️⃣ 재배치 (Relocation)
- 심벌의 메모리 주소를 결정하고 실제 주소로 대체
- 전역 변수와 함수 이름 등만 심벌로 포함됨

---

## 1.4 라이브러리(Library)란?

라이브러리는 자주 사용하는 함수들의 모음으로, 정적 혹은 동적으로 연결될 수 있다.

### 📦 정적 라이브러리 (Static Library)
- `.a`, `.lib` 파일로 존재
- 실행파일에 코드가 **직접 복사됨**

**장점**
- 실행 시 라이브러리가 없어도 됨

**단점**
- 불필요한 코드로 인해 크기 증가  
- 수정 시 전체 재컴파일 필요

---

### 🔄 동적 라이브러리 (Dynamic / Shared Library)
- `.so`, `.dll` 등의 형태
- 실행 시에 메모리에 적재되어 참조됨

**장점**
- 파일 크기 작음, 메모리 절약  
- 여러 프로그램이 하나의 라이브러리 공유  
- 플러그인 구조에 유리

**단점**
- 실행 시 성능 소폭 감소  
- 런타임에 라이브러리 없으면 실행 불가

---

## 💡 링커는 어떻게 메모리 주소를 정할까?

### 가상 메모리 (Virtual Memory)

- 실제 메모리가 아닌, 논리적 주소 공간
- 링커는 이 공간을 기반으로 메모리 배치 수행

**특징**
- 프로세스마다 독립된 가상 주소 공간  
- 페이지 테이블을 통해 실제 메모리로 매핑  
- 표준화된 구조 덕분에 링커가 주소를 사전에 배치 가능

---

## 🧩 요약: 컴파일러 vs 링커

| 구분 | 컴파일러 (Compiler) | 링커 (Linker) |
|------|----------------------|---------------|
| 역할 | 고급 언어 → 기계어 번역 | 여러 기계어 파일 → 실행 파일로 연결 |
| 입력 | 소스 파일 `.c` | 대상 파일 `.o` |
| 출력 | 대상 파일 `.o` | 실행 파일 `.exe`, `.out`, `.elf` |
| 주요 작업 | 어휘/구문/의미 분석, 중간 코드 생성 | 심벌 해석, 주소 재배치, 라이브러리 연결 |
