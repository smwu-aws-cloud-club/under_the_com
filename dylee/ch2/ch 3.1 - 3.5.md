# 1. 메모리의 본질, 포인터와 참조

## 비트, 바이트, 객체

- 메모리 셀: 메모리의 가장 작은 단위로, 비트(0 or 1)보관. 메모리 안에 저장된 객체 정수.. << 모두 0 또는 1
- bit
    - 1bit → 1,0 → T/F만
- byte
    - 1byte = 8bit → 8개의 메모리 셀 이용
    - 8bit → 2^8 = 256개의 case 표현 가능
    - 보통 4byte = integer → 2^32개의 조합 가능
    - 12byte = structure, object

## 변수

- 컴퓨터 구조에서의 연산 과정 → 메모리 주소는 사람에게 익숙하지 않음
    
    ```bash
    store $1 6 # 메모리 주소 6에 숫자  1 저장
    load r1 6 # 메모리 주소 6에 저장된 숫자를 r1 register로 load
    ```
    
- 메모리 주소에 별칭을 붙인 것 → 변수
- 메모리 주소만 알고 있으면 데이터를 찾을 수 있다

## 포인터

- 변수에 메모리 주소를 저장한 것으로 메모리 주소를 더 높은 수준으로 추상화한 것
- 포인터도 변수에 해당함!

```bash
# 간접 주소 지정
load r1 @1
# 메모리 주소 1에 저장된 값(3)을 읽어 -> 해당 값(3)을 메모리 주소로 간주 
# -> 이 주소(3)에 저장된 데이터가 진짜 데이터
```

- 포인터를 이용하면 → linked list의 효율이 올라감

### 포인터 - 메모리 주소

- Java/Python → 포인터 x → 메모리 주소 확인 x → 특정 메모리 위치에 있는 데이터 직접 조작 불가능
    - 하지만 포인터를 추상화한 참조가 있음
- C → 메모리 주소 추상화 x → 프로그래머가 직접 메모리 주소 알 수 있음
    - low level의 조작에 유리하지만, 사용할 때 주의해야 함

### 포인터 - 참조

- 참조
    - 포인터를 추상화한 것으로, 참조를 사용하면 데이터 복사 하지 않고도 데이터를 불러오거나 조작 가능
    - 포인터와 유사한 구조의 산술 연산은 불가
- 포인터 → 메모리 주소 추상화, 참조 → 포인터를 한번 더 추상화
- 물리 메모리 추상화 → 가상 메모리

# 2. 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?

**code segment & data segment**

- 실행파일 초기화 할 때 생성

**heap segment**

- 동적 메모리 할당에 사용
- C/C++ → malloc
- Java → class

**stack segment**

- 함수 호출에 사용 → 매개변수, 반환 주소, 레지스터 정보 등을 포함한 함수 실행 시 정보 저장

## 가상 메모리

- 현재 상황
    - 모든 프로세스의 코드 영역이 0x4000000에서 시작 → 서로 다른 프로세스 두 개가 메모리를 할당하기 위해 malloc 호출 → 동일한 시작 주소(0x7f64cb8)반환할 가능성이 높음 → 이 주소는 가상 메모리 주소(동일한 주소가 반환되어도 문제 x) → 메모리 조작 전 실제 물리 메모리 주소로 변경
- 프로세스들의 실제 물리 메모리에 할당된 형태 → chunk로 나뉘어서 물리 메모리에 저장되어 있고, 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있음
    - 따라서 os는 가상 메모리 ↔ 물리 메모리를 page table을 통한 mapping을 함
              
## page - page table

### page table

- 가상 메모리 ↔ 물리 메모리 mapping 관계를 유지
- 1 프로세스 1 page table
    - 가상 메모리 주소가 같아도 → 해당 가상 메모리 주소가 가리키는 page는 다른 물리 메모리 주소에 저장되므로 → 두 프로세스가 동일한 가상 메모리 주소에 기록해도 문제 발생 x

### page

- process의 주소 공간을 동일한 크기의 조각(page)으로 나눈 것

# 3. 스택 영역

## 함수

- 반복되는 코드를 줄이기 위해 동일한 기능을 하는 코드를 묶은 것(코드 재사용) → 코드 구현의 세부 사항을 감출 수 있음
- 함수 호출 시 구현은 몰라도 되고, 함수 이름, 매개변수, 반환값만 알면 됨(추상화)

## 함수 호출

- 호출 방식: LIFO → 이진 트리의 탐색
- 이진트리 탐색(java)
    
    ```bash
    
    ```
    

## 스택 프레임

- 함수가 실행될 때 사용되는 여러 가지 정보를 저장한 것
- process의 stack 영역에 생성 → 높은 주소가 맨 위에 있고, 낮은 주소 방향으로 커짐 → 스택 영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가하고, 함수 호출이 완료될수록 감소    

### 함수 jump & return

- 제어권: 현재 실행 흐름에 따라 다음에 실행될 명령어의 주소(PC)가 가리키는 코드 구간이 어디인지(함수/block)나타내는 것
    - 즉, 다음에 실행될 코드 위치(PC register)가 어디를 가리키는지 나타내는 것
- Jump & return 과정

1. 함수 A 연산 진행
2. 함수 A가 함수 B call
3. CPU가 함수 B로 Jump(제어권이 A → B로 이동) + call 명령어 뒤에 위치한 주소(0x40056a)를 함수 A의 stack frame에 넣음
4. 함수 B 실행 → 함수 B에도 stack frame 추가 → stack 영역이 차지하는 메모리 크기 증가
5. B 실행 완료 후 저장해 둔 반환 주소로 PC 복원 → 다시 A로 (제어권이 다시 A로 이동)

## 매개변수 전달 & 반환값

- x86-64
    - 매개변수 전달 & 반환값 가져오는 작업 → register로 수행
    -
