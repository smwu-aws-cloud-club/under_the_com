# 컴퓨터 밑바닥의 비밀: 챕터 2 정리 노트

## 2.5 콜백 함수

### 2.5.1 콜백 함수의 필요성
- 핵심 모듈 함수를 직접 수정하지 않고 유연하게 기능을 추가하기 위함
- 조건이 추가될 때마다 코드를 수정해야 하는 문제를 해결

### 2.5.2 콜백의 본질
- **콜백 함수** = 함수 변수
- 정의한 함수를 매개변수로 전달하여 실행하는 방식
- 코드를 변경하는 대신 필요한 기능을 함수로 정의하여 전달

### 2.5.3 비동기 콜백
- 호출 스레드가 콜백 함수 실행에 의존하지 않음
- 함수 실행이 길어질 때 다른 작업을 먼저 처리할 수 있게 함
```cpp
void make_donut(func f) {
  thread t(real_make_donut, f); // 스레드 시작
  something_important(); // 기다리지 않고 처리 가능
}
```

### 2.5.4 새로운 프로그래밍 사고방식
- **동기 호출**: 함수 반환을 기다렸다가 결과 처리
  ```
  res = request();
  handle(res);
  ```
- **비동기 호출**: 함수 호출 후 바로 반환, 결과는 별도로 처리
  ```
  request(handle);
  ```
- 호출자는 무엇을 해야 할지 알지만 언제 할지 모름
- 외부 모듈은 언제 해야 할지 알지만 무엇을 할지 모름
- 이 두 정보를 콜백 함수로 연결

### 2.5.5 콜백 함수의 정의
- 다른 코드에 매개변수로 전달되는 실행 가능한 코드
- 함수를 직접 호출하지 않고 외부 모듈이 호출
- 이벤트 중심 프로그래밍(네트워크 응답, 파일 다운로드 완료 등)에 적합

### 2.5.6 콜백 유형
1. **동기 콜백(블로킹 콜백)**
   - 함수가 반환되기 전에 콜백 함수 실행
   - 실행 흐름이 직관적이지만 성능 저하 가능

2. **비동기 콜백(지연 콜백)**
   - 함수 즉시 반환 후 일정 시간 뒤 콜백 함수 실행
   - 콜백 함수와 주 프로그램이 동시 실행 가능
   - 다중 코어 리소스 효율적 활용
   - 입출력 작업, 웹 서비스에 적합

### 2.5.7 콜백 지옥(Callback Hell)
- 복잡한 비즈니스 로직을 비동기 콜백으로 처리하면 코드 가독성 저하
- 콜백 안에 콜백이 중첩되는 구조
- 해결책: **코루틴** 활용

## 2.6 동기와 비동기

### 2.6.1 동기와 비동기의 개념
- **동기 작업**: 작업 완료까지 대기 (예: 전화, 무전기)
- **비동기 작업**: 작업 요청 후 다른 일 수행 가능 (예: 이메일)

### 2.6.3 동기 호출
- 동일한 스레드에서 실행됨
- 호출된 함수의 처리가 끝나야 다음 작업 실행
- **블로킹 입출력**: 입출력 작업에서 호출 스레드 일시 중지

### 2.6.4 비동기 호출
- 오래 걸리는 작업을 백그라운드에서 실행
- 호출자는 기다리지 않고 다음 작업 수행
- 효율적이지만 코드가 복잡해질 수 있음

### 작업 완료 파악 방법
1. **결과를 신경 쓰지 않는 경우**: 콜백 함수 사용
   ```cpp
   void handler(void* buf) {
       // 파일 내용 처리
   }
   read(buf, handler); // read 함수가 완료되면 handler 실행
   ```

2. **결과를 알아야 하는 경우**: 알림 방식 사용
   - 작업 완료 후 호출자에게 신호/메시지 전송

### 2.6.5 웹 서버에서의 동기/비동기
- **동기 방식**: 작업 완료까지 스레드 대기(유휴 시간 발생)
- **비동기 방식**:
  1. DB 처리 결과 불필요 시: 콜백 함수 등록 후 다른 작업 수행
  2. DB 처리 결과 필요 시: 알림 방식으로 결과 전달 받음

## 2.7 블로킹과 논블로킹

### 2.7.1 개념 정의
- **블로킹 호출**: 함수 B를 호출할 때 함수 A의 스레드/프로세스가 일시 중지됨
- **논블로킹 호출**: 함수 호출 시 중지되지 않음

### 2.7.2 블로킹의 핵심 문제: 입출력
- 입출력 작업 중 CPU 제어권을 다른 스레드에 넘김
- 제어권을 상실했다가 되찾는 동안 스레드/프로세스는 블로킹됨
- CPU 리소스 활용도 향상에 도움

### 2.7.3 논블로킹과 비동기 입출력
- **논블로킹**: 호출 스레드가 일시 중지되지 않으면서 입출력 작업 시작
- **비동기 입출력**: 커널이 처리하는 논블로킹 입출력 작업

### 데이터 수신 확인 방법
1. 폴링 함수로 데이터 수신 여부 확인
2. 알림 방식: 데이터 수신 시 메시지/신호 전송
3. 콜백 함수: 데이터 처리 함수를 매개변수로 전달

### 2.7.4 피자 주문 비유
- **블로킹 호출**: 피자 가게에서 완성될 때까지 기다림
- **논블로킹 호출**: 전화 주문 후 다른 일 하다가 배달 도착 시 응답

### 2.7.5-6 관계 정리
- 블로킹 호출은 항상 동기 호출
- 동기 호출이 반드시 블로킹은 아님
- 비동기이자 논블로킹: 콜백 함수 활용
- 동기이자 논블로킹: 폴링 방식(비효율적)

## 2.8 고성능 서버 구현

### 2.8.1 다중 프로세스
- 부모 프로세스가 요청 수신 후 자식 프로세스 생성하여 처리
- **장점**: 간단한 프로그래밍, 프로세스 격리, 다중 코어 활용
- **단점**: 프로세스 간 통신 복잡, 생성/종료 부담

### 2.8.2 다중 스레드
- 하나의 프로세스 내에서 여러 스레드가 주소 공간 공유
- **장점**: 데이터 교환 용이, 생성/종료 비용 낮음
- **단점**: 한 스레드 문제가 전체에 영향, 동기화 기법 필요, 과도한 동시성 시 성능 저하

### 2.8.3 이벤트 순환과 이벤트 구동
- **이벤트 기반 프로그래밍**: 이벤트 발생 시 대응 핸들러 호출
- **이벤트 순환(Event Loop)**: 반복적으로 이벤트 처리

### 2.8.4 입출력 다중화
- **epoll**: 리눅스에서 입출력 다중화 구현
- 이벤트 순환의 엔진 역할

### 2.8.5 이벤트 순환과 다중 스레드
- CPU 연산 많은 경우: 다중 스레드 활용
- 작업자 스레드와 이벤트 순환 스레드 분리
- **반응자 패턴(Reactor Pattern)**: 이벤트 순환 스레드가 작업자 스레드에 작업 분배

### 2.8.7 이벤트 순환과 입출력
- **논블로킹 인터페이스**: 이벤트 순환에서 직접 호출 가능
- **블로킹 인터페이스**: 작업자 스레드에 전달하여 처리

### 2.8.8 비동기와 콜백 함수
- **RPC(원격 프로시저 호출)**: 서버 간 통신 방법
- 동기 방식: 코드 명확하나 스레드 중단 발생
- 비동기 방식: 콜백 중첩으로 복잡해짐

### 2.8.9 코루틴: 동기 방식의 비동기 프로그래밍
- 동기 코드 형태로 작성하되 `yield`로 제어권 반환
- 일시 중지되어도 작업자 스레드 블로킹 안 됨
- 중지된 지점부터 이어서 실행
- 동기 코드의 가독성 + 비동기 실행의 효율성

### 2.8.10 CPU, 스레드, 코루틴 비교
- **스레드**: 커널 상태 스레드, CPU 리소스 할당 받음
- **코루틴**: 사용자 상태 스레드, 프로그래머가 실행 제어

## 2.9 컴퓨터 시스템 여행

### 2.9.1 기본 개념
- **변수**: 데이터를 별칭으로 지칭
- **포인터(참조)**: 변수로 동일 데이터 참조
- **함수**: 여러 명령어를 별칭으로 묶음

### 2.9.2 콜백 함수와 클로저
- **일급 객체 함수**: 함수를 변수처럼 취급
- **콜백 함수**: 다른 함수에 매개변수로 전달
- **클로저**: 콜백 함수와 실행 환경 데이터를 함께 묶음

### 2.9.3 컨테이너와 가상화
- **코루틴**: 능동적으로 일시 중지/재개 가능한 함수
- **스레드**: 커널 상태에서 일시 중지/재개 구현
- **프로세스**: 스레드와 실행 리소스 결합
- **컨테이너**: 프로그램과 실행 환경을 함께 묶어 격리
- **가상화 기술**: 하드웨어 리소스 추상화(하이퍼바이저)
- **가상 머신**: 가상 머신 감시자에서 실행되는 OS

컨테이너와 가상 머신은 현대 클라우드 컴퓨팅의 핵심 기반 기술
